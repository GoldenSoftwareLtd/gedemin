
(*

Безопасность.

не выводить записи, если есть поле aview и нет прав у пользователя
на просмотр записи.

если есть поле achag и у пользователя нет прав на изменение, то не давать
редактировать, копировать, удалять.

если есть поле afull и у пользователя нет прав, то не давать возможность
удалять.

программист обязан вставить в СКЛ текст проверку на права. он должен
использовать метапеременную, которая будет заменена на права пользователя.

разделение прав по операциям.

мы вводим следующие мета-операции для базового класса:

создание объекта, просмотр/изменение, удаление, смена прав доступа и печать.
Все остальные можно свести
к предыдущим трем. тогда прежде чем выполнить операцию мы проверим:
не отключена ли она, есть ли права у пользователя на нее, есть ли
права у пользователя на выполнение заданной операции над текущей записью.

в таблице гд_оператион мы заводим ветку GDC.
для всех объектов отводим интервал: 7000000-7999999
для каждого объекта заводится подветка с определенным идентификатором.
ИД. у этой ветки пять подветвей, соответственно с кодами
ИД + 2, + 4 и т.п.
эти подветки -- команды на доступ, создание, изменение, удаление, смену прав,
печать.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~
при копировании записи-накладной мы должны скопировать все записи-позиции.
получается, что объект-накладная должен знать класс объекта позиции.
тогда при копировании он сможет создать соответствующий объект,
и сделать копию всех, входящих в него записей.

для того, чтобы создав объект-детаил сделать его копию необходимо знать
какие поля в этом объекте отвечают за связь с мастер объектом.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

управление транзакциями. мы хотели бы сделать свое. для того чтобы каждый программист
не изобретал велосипед.

1. каждый бизнес объект получает свою транзакцию.
2. связанные через мастер-детайл объекты имеют общую транзакцию.
3. транзакция открывается автоматически при открытии датасета.
4. при закрытии датасета транзакция не закрывается сразу, а через некоторое время.
5. не связанные связью мастер-дитэйл объекты имеют разные транзакции.
   Например, если для редактирования записи вызывается диалоговое окно, а
   в нем есть лукапы, связанные с бизнес объектами, то для редактирования
   тех объектов открываются свои транзакции. Т.е. мы зашли в диалог, открыли
   лукап, выделили в нем объект. Затем решили этот объект немного подправить.
   Внесли изменение. А из диалогового окна решили выйти по Отмене. В этом случае
   в нашем бизнес-объекте изменения не сохранятся, а в том, что был в лукапе --
   сохранятся. Они на разных транзакциях.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Интересную штуку мы хотим добавить в базовый класс -- это размер датасета,
количество записей. Зачем это надо? Например, в лукапе выбора товара в прайс листе
стоит упорядочение по наименованию. Для большинства организаций это вполне приемлемо,
однако для компаний, у которых в справочнике товаров полмиллиона позиций
припопытке выбрать лукап и вывести список в выпадающем окне он просто подвиснет.
Надо, чтобы в этом случае сортировка не применялась. Т.е. лукап должен опросить
бизнес-объект и если тот сообщает ему, что справочник большой, то сортировку не применять.

Теперь, как БА будет знать, что справочник большой? Выполнять для этого запрос
нерационально и неэффективно. Объект должен, при случае, узнавать об этом и
запоминать. Переодически эта информация должна обновляться.

             01-11-2001  sai     1. Добавлены два класса для поиска и выбоки объектов
                                 TgdcFindObject, TgdcFindObjectList
                                 2. Переделаны методы Find, Choose, ChooseElement
                                 3. Перделана форма поиска gdc_dlgFind
             17-11-2001 Michael  Добавлено событие OnAfterInitSQL - для возможности перекрыть
                                 запрос, который стандартно создан.
             18-06-2002 Julie    1. Удалены два класса для поиска и выборки объектов
                                 TgdcFindObject, TgdcFindObjectList
                                 2. Удалены методы Find, Choose, ChooseElement
                                 3. Удалена форма поиска gdc_dlgFind
             25-06-2002 DAlex    Окончательныя версия перекрытия методов

*)

unit gdcBase;

{ TODO : из таблицы evt_object надо убрать дескрипторы безопасности! }
{ TODO :
проверить чтобы в объектах gdcDelphiObject, gdcFunction, gdcEvent
не было дескрипторов безопасности. }

interface

uses
  Classes,              Windows,               Controls,         DB,
  IB,                   IBHeader,              IBDatabase,       IBCustomDataSet,
  IBSQL,                SysUtils,              DBGrids,          Forms,
  gdcBaseInterface,     Contnrs,               Clipbrd,          MSScriptControl_TLB,
  menus,                flt_QueryFilterGDC,    at_sql_setup,     gd_createable_form,
  ActnList,             gsStorage,             gd_KeyAssoc,      ExtCtrls,
  Graphics,             mtd_i_Base,            evt_i_Base,       zlib;

resourcestring
  strHaventRights = 'Осутсвуют права доступа на выполнение операции: %s';
  strCreate = 'Создание объекта';
  strView = 'Просмотр';
  strEdit = 'Редактирование объекта';
  strPrint = 'Печать объекта';
  strDelete = 'Удаление объекта';
  strChangeRights = 'Изменение прав';

const
  ////////////////////////////////////////////////////////////
  // константы смещения операций, относительно главной ветви
  GDC_OP_ACCESS          =  2;
  GDC_OP_CREATE          =  4;
  GDC_OP_CHANGE          =  6;
  GDC_OP_DELETE          =  8;
  GDC_OP_PRINT           = 10;
  GDC_OP_CHANGERIGHT     = 12;

  //
  CST_REPORTCAPTION      = 'Печать';
  CST_REPORTGROUPID      = -1;
  CST_REPORTREGISTRYLIST = 'Редактор скрипт-объектов';

  CST_MACROSMENU         = 'Редактор скрипт-объектов';

  // Название формы на которой добавляются глобальные макросы
  GDC_SC_MACROSMODULE    = 'frmExplorer';
  GDC_SC_TYPEEVENT       = 'E';
  GDC_SC_TYPEMACROS      = 'M';
  CST_ALL                = 'All';

  // Имена методов, для которых реализуется перекрытия макросами
  GDC_CUSTOMINSERT       = 'CUSTOMINSERT';
  GDC_CUSTOMMODIFY       = 'CUSTOMMODIFY';
  GDC_CUSTOMDELETE       = 'CUSTOMDELETE';
  GDC_DOAFTERDELETE      = 'DOAFTERDELETE';
  GDC_DOAFTERINSERT      = 'DOAFTERINSERT';
  GDC_DOAFTEROPEN        = 'DOAFTEROPEN';
  GDC_DOAFTERPOST        = 'DOAFTERPOST';
  GDC_DOBEFORECLOSE      = 'DOBEFORECLOSE';
  GDC_DOBEFOREDELETE     = 'DOBEFOREDELETE';
  GDC_DOBEFOREEDIT       = 'DOBEFOREEDIT';
  GDC_DOBEFOREINSERT     = 'DOBEFOREINSERT';
  GDC_DOBEFOREPOST       = 'DOBEFOREPOST';
  GDC_DOAFTERTRANSACTIONEND = 'DOAFTERTRANSACTIONEND';
  GDC_GETNOTCOPYFIELD    = 'GETNOTCOPYFIELD';
  GDC_VALIDATEFIELD      = 'VALIDATEFIELD';
  

  // Имена классов, в которых перекрываюся методы макросами
  GDC_BASE               = 'TGDCBASE';

  cCut                     = True;
  cCopy                    = False;

  //Версия сохранения в потоке б-о
  cst_StreamVersion = 2;
  cst_WithVersion   = 'SAVE_TO_STREAM_WITH_VERSION';

  //
  DefQueryFiltered = False;


type
  /////////////////////////////////////////////////////////////
  // типы событий, поддерживаемые бизнес объектом
  TgdcEventTypes = (etAfterCancel, etAfterClose, etAfterDelete, etAfterEdit,
                 etAfterInsert, etAfterOpen, etAfterPost, etAfterRefresh,
                 etAfterScroll, etBeforeCancel, etBeforeClose, etBeforeDelete,
                 etBeforeEdit, etBeforeInsert, etBeforeOpen, etBeforePost,
                 etBeforeRefresh, etBeforeScroll, etOnCalcFields, etOnNewRecord,
                 etOnFieldChange);
const
  /////////////////////////////////////////////////////////////
  // наименования типов событий
  gdcEventTypesString: array[TgdcEventTypes] of String =
                ('AfterCancel', 'AfterClose', 'AfterDelete', 'AfterEdit',
                 'AfterInsert', 'AfterOpen', 'AfterPost', 'AfterRefresh',
                 'AfterScroll', 'BeforeCancel', 'BeforeClose', 'BeforeDelete',
                 'BeforeEdit', 'BeforeInsert', 'BeforeOpen', 'BeforePost',
                 'BeforeRefresh', 'BeforeScroll', 'OnCalcFields', 'OnNewRecord',
                 'OnFieldChange');

// Тип для создания события которое вызывается после выполнения InitSQL
// SQLText - Текст запроса
// isReplaceSQL - Заменить созданный InitSQL запрос на SQLText или нет

type
  TgdcAfterInitSQL = procedure (Sender: TObject;
    var SQLText: String; var isReplaceSQL: Boolean) of object;

  // запускается перед появлением дилогового окна ввода нового
  // объекта или редактирования старого
  TgdcDoBeforeShowDialog = procedure (Sender: TObject;
    DlgForm: TCustomForm) of object;

  // запускается после закрытия дилогового окна ввода нового
  // объекта или редактирования старого
  TgdcDoAfterShowDialog = procedure (Sender: TObject;
    DlgForm: TCustomForm; IsOk: Boolean) of object;

  TgdcOnGetSQLClause = procedure(Sender: TObject; var Clause: String) of Object;

type
  /////////////////////////////////////////////////////////////
  //  Состояние объекта
  TgdcState = (
    sNone,
    sView,        // объект подключен к форме
    sDialog,      // объект подключен к диалоговому окну
    sSubDialog,
    sSyncControls,
    sLoadFromStream,
    sMultiple     // идет обработка одновременно несколькиз записей
  );
  TgdcStates = set of TgdcState;

  TgdcBase = class;
  CgdcBase = class of TgdcBase;

  //Тип для хранения записи счиьываемой из потока
  TgsStreamRecord = record
    StreamVersion: Integer;
    StreamDBID: Integer;
  end;

  //////////////////////////////////////////////////////////
  // Поскольку полное задание класса бизнес объекта
  // подразумевает указание собственно класса объекта и
  // подтипа, введем запись, которая будет использоваться
  // для передачи/хранения такой информации
  TgdcFullClass = record
    gdClass: CgdcBase;
    SubType: TgdcSubType;
  end;

  //
  TgdcObjectSet = class
  private
    FgdClass: CgdcBase;
    FSubType: TgdcSubType;
    //ID должны хранится в том же порядке, в котором они были занесены
    FArray: array of TID;
    FgdClassList: TStringList;
    FCount: Integer;

    function Get_gdClass: CgdcBase;
    function Get_gdClassName: String;
    function GetCount: Integer;
    function GetItems(Index: Integer): TID;
    procedure Set_gdClass(const Value: CgdcBase);
    function GetSize: Integer;
    function GetSubType: TgdcSubType;
    procedure SetSubType(const Value: TgdcSubType);

    function FormClassSubTypeString(const gdClassName, SubType: String): String;
    function GetgdInfo(Index: Integer): String;

  public
    constructor Create(AgdClass: CgdcBase; const ASubType: TgdcSubType; const ASize: Integer = 32);
    destructor Destroy; override;

    function Add(const AnID: TID; const AgdClassName: String;
       const ASubType: String ): Integer;
    procedure AddgdClass(const Index: Integer; const AgdClassName: String;
      const ASubType: String);

    function Find(const AnID: TID): Integer;
    function FindgdClass(const Index: Integer; const AgdClassName: String;
      const ASubType: String ): Boolean;
    function FindgdClassByID(const AnID: TID; const AgdClassName: String;
      const ASubType: String ): Boolean;

    procedure Remove(const AnID: TID);
    procedure Delete(const Index: Integer);

    procedure LoadFromStream(S: TStream);
    procedure SaveToStream(S: TStream);

    property gdClass: CgdcBase read Get_gdClass write Set_gdClass;
    property gdClassName: String read Get_gdClassName;
    property SubType: TgdcSubType read GetSubType write SetSubType;
    property Items[Index: Integer]: TID read GetItems; default;
    property gdInfo[Index: Integer]: String read GetgdInfo;
    property Count: Integer read GetCount;
    property Size: Integer read GetSize;
  end;

  TgdcObjectSets = class(TObjectList)
  public
    constructor Create;

    function Find(C: TgdcFullClass): TgdcObjectSet;

    procedure SaveToStream(S: TStream);
    procedure LoadFromStream(S: TStream);
  end;

  //////////////////////////////////////////////////////////
  // каб не прап_сваць паўсюль датабэйз завядзем свой мэнэджэр,
  // адз_н на праект _ будзем праз яго вытаск_ваць датабэйз
  TgdcBaseManager = class(TComponent, IgdcBaseManager)
  private
    FIBBase: TIBBase;
    FReadTransaction: TIBTransaction;
    FExplorer: TgdcBase;
    FNextIDSQL: TIBSQL;

    function GetDatabase: TIBDatabase;
    procedure SetDatabase(const Value: TIBDatabase);
    function GetExplorer: IgdcBase;
    procedure SetExplorer(const Value: IgdcBase);

    function GetReadTransaction: TIBTransaction;

  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;

  public
    constructor Create(AnOwner: TComponent); override;
    destructor Destroy; override;
    //  TZCompressionLevel = (zcNone, zcFastest, zcDefault, zcMax);
    procedure PackStream(SourceStream, DestStream: TStream; CompressionLevel: TZCompressionLevel);
    procedure UnPackStream(SourceStream, DestStream: TStream);

    function GetIDByRUID(const XID, DBID: TID): TID;
    function GetIDByRUIDString(const RUID: TRUIDString): TID;
    //Возвращает поля xid, dbid из таблицы gd_ruid по id
    //Если запись по id не найдена вернет -1, -1
    procedure GetRUIDByID(const ID: TID; out XID, DBID: TID);
    function  GetRUIDStringByID(const ID: TID): TRUIDString;
    //Возвращает поля xid, dbid из таблицы gd_ruid по id
    //Если запись по id не найдена вернет xid = id, dbid = IBLogin.DBID
    procedure GetFullRUIDByID(const ID: TID; out XID, DBID: TID);
    function ProcessSQL(const S: String): String;
    function AdjustMetaName(const S: String): String;

    //
    function GetNextID: TID;

    //
    function GenerateNewDBID: Integer;

    property ReadTransaction: TIBTransaction read GetReadTransaction;

  published
    property Database: TIBDatabase read GetDatabase write SetDatabase;
  end;

  EgdcBaseManager = class(Exception);

  //////////////////////////////////////////////////////////
  // механ_зм, закладзены ў Т_БДатаСет не задавальняе нас
  // бо _ ў масцер _ ў дета_л датасеце могуць _снаваць
  // пал_ з аднолькавам_ назвам_ (_Д -- часцей за ўсе)
  // мы ўводз_м свой механ_зм сувяз_ масцер-дз_тэйл
  TgdcDataLink = class(TDataLink)
  private
    FMasterField: TStringList;
    FDetailField: TStringList;
    FTimer: TTimer;
    FDetailObject: TgdcBase;

    procedure DoOnTimer(Sender: TObject);
    function GetDetailField: String;
    function GetMasterField: String;
    procedure SetDetailField(const Value: String);
    procedure SetMasterField(const Value: String);

  protected
    FLinkEstablished: Boolean;

    procedure ActiveChanged; override;
    procedure EditingChanged; override;
    procedure RecordChanged(F: TField); override;
    //procedure RefreshParams(const AnyWay: Boolean);

  public
    constructor Create(ADetailObject: TgdcBase);
    destructor Destroy; override;

    procedure CheckBrowseMode; override;

    property MasterField: String read GetMasterField write SetMasterField;
    property DetailField: String read GetDetailField write SetDetailField;
  end;

  //////////////////////////////////////////////////////////
  // for transferring gdc objects via clipboard
  // we register our own clipboard format
  TObjectData = record
    ID: TID;
    ObjectName: array[0..63] of Char;
    ClassName: array[0..63] of Char;
    SubType: array[0..63] of Char;
  end;
  TObjectArr = array[0..0] of TObjectData;
  PgdcClipboardData = ^TgdcClipboardData;
  TgdcClipboardData = record
    Signature: Longint;
    Version: Longint;
    ClassName: array[0..63] of Char;
    SubType: array[0..63] of Char;
    Obj: TgdcBase;
    Cut: Boolean;
    ObjectCount: Integer;
    ObjectArr: TObjectArr;
  end;

  /////////////////////////////////////////////////////////
  // если данные объекта хранятся в нескольких таблицах,
  // то мы должны перекрывать борландовские методы и
  // выполнять вставку, изменение, удаление по-свойму

  { TODO : 
фактически в КастомИнсерт и КастомМодифай нет никакого толку.
Только КастомДелете сейчас используется в удалении нескольких
одновременно. }
  TgsCustomProcess = (cpInsert, cpModify, cpDelete);
  TgsCustomProcesses = set of TgsCustomProcess;

  // используется для сохранения значений полей до редактирования
  // для того чтобы в последствии можно было отменить исправления
  TFieldValue = class(TObject)
  public
    FieldName: String;
    Value: String;
    IsNull: Boolean;
  end;

  TgdcPropertySet = class
  private
    FRUIDSt: String;
    FPropertyList: TStrings;
    FValueArray: Variant;
    FgdClass: CgdcBase;
    FSubType: TgdcSubType;
    function GetCount: Integer;
    function GetValue(APropertyName: String): Variant;
    function GetName(Index: Integer): String;

  public
    constructor Create(const ARUIDSt: String; AgdClass: CgdcBase; ASubType: TgdcSubType);
    destructor Destroy; override;

    property RUIDSt: String read FRUIDSt;
    property gdClass: CgdcBase read FgdClass;
    property SubType: TgdcSubType read FSubType;

    property Value[APropertyName: String]: Variant read GetValue;
    property Name[Index: Integer]: String read GetName;
    property Count: Integer read GetCount;

    function Find(APropertyName: String): Integer;
    function GetIndexValue(APropertyName: String): Integer;

    procedure Add(APropertyName: String; Value: Variant);
    procedure SetValue(APropertyName: String; Value: Variant);

    procedure SaveToStream(S: TStream);
    procedure LoadFromStream(S: TStream);

    procedure Clear;
  end;

  TgdcPropertySets = class(TStringList)
  private
    FOwnsObjects: Boolean;
    function GetObject(Index: Integer): TgdcPropertySet; reintroduce; overload;
    procedure PutObject(Index: Integer; const Value: TgdcPropertySet); reintroduce; overload;

  public
    constructor Create;
    destructor Destroy; override;

    function Add(const ARUIDSt: String; AgdClassName: String;
      ASubType: TgdcSubType): Integer; reintroduce; overload;

    function AddObject(const S: string; AObject: TgdcPropertySet): Integer; reintroduce; overload;

    property OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
    property Objects[Index: Integer]: TgdcPropertySet read GetObject write PutObject;

    procedure SaveToStream(S: TStream); override;
    procedure LoadFromStream(S: TStream); override;

    procedure Clear; override;
  end;

  /////////////////////////////////////////////////////////
  // базавы клас для б_знэс аб'ектаў
  TgdcBase = class(TIBCustomDataSet, IgdcBase)
  private
    FParentForm: TWinControl;
    FDetailLinks: TObjectList;
    FSubSets: TStringList;
    FgdcTableInfos: TgdcTableInfos;
    FNameInScript: String;
    FEventList: TStringList;
    FBaseState: TgdcStates;
    FpmReport: TPopupMenu;
    FFilter: TQueryFilterGDC;
    FOnFilterChanged: TNotifyEvent;
    FOldValues: TObjectList;
    FSubType: String;
    FCustomProcess: TgsCustomProcesses;
    FExecQuery: TIBSQL;
    FUpdateableFields: String;
    FExtraConditions: TStringList;
    FSelectedID: TgdKeyArray;
    FDlgStack: TObjectStack;
    FSavedParams: TObjectList;
    FSetMasterField, FSetItemField: String;

    FBeforeShowDialog: TgdcDoBeforeShowDialog;
    FAfterShowDialog: TgdcDoAfterShowDialog;

    FAfterInitSQL: TgdcAfterInitSQL;

    FGetDialogDefaultsFieldsCached: Boolean;
    FGetDialogDefaultsFieldsCache: String;
    FRefreshMaster: Boolean;

    // поля для перекрытия методов макросами
    FClassMethodAssoc: TgdKeyIntAndStrAssoc;
    FVarParam: TVarParamEvent;
    FReturnVarParam: TVarParamEvent;

    FSetTable: String;

    FUseScriptMethod: Boolean;

    FSyncList: TList;
    FOnGetSelectClause: TgdcOnGetSQLClause;
    FOnGetWhereClause: TgdcOnGetSQLClause;
    FOnGetOrderClause: TgdcOnGetSQLClause;
    FOnGetFromClause: TgdcOnGetSQLClause;
    FOnGetGroupClause: TgdcOnGetSQLClause;
    FQueryFiltered: Boolean;

    FStreamSQLInitialised: Boolean;

    FIsNewRecord: Boolean;

    FibSQL_InsertToRUID: TibSQL;
    FibSQL_SelectRUID: TibSQL;
    FibSQL_UpdateRUID: TibSQL;
    FFieldsCallDoChange: TStringList;
    FModifyFromStream: Boolean;

    FVariables: TgdVariables;
    FObjects: TgdObjects;

    FSetRefreshSQLOn: Boolean;

    procedure StreamSQLInitialize;

    function GetMethodControl: IMethodControl;

    function GetDetailField: String;
    function GetMasterField: String;
    function GetMasterSource: TDataSource;

    procedure SetDetailField(const Value: String);
    procedure SetMasterField(const Value: String);

    function GetID: Integer;
    procedure SetID(const Value: Integer);

    // Запуск на выполнение
    function GetNameInScript: String;

    // выводит список таблиц, и записей в этих таблицах, которые содержат
    // поля-ссылки, ссылающиеся на текущую запись. Выводит в диалоговом окне
    procedure IsUse;

    //
    function GetObject: TObject;

    // Печать отчета по заданному ИД
    procedure PrintReport(const ID: Integer);
    function GetHasWhereClause: Boolean;

    // для заданного поля возвращает: подлегает это поле
    // копированию или нет
    function TestCopyField(const FieldName: String): Boolean;

    // формирование выпадающего меню со списком отчетов
    // доступных для данного объекта
    procedure MakeReportMenu;

    //
    procedure DoOnFilterChanged(Sender: TObject; const AnCurrentFilter: Integer);

    function GetDetailLinks(Index: Integer): TgdcBase;
    function GetDetailLinksCount: Integer;
    function GetObjectName: String;
    procedure SetObjectName(const Value: String);
    function GetCreationDate: TDateTime;
    function GetCreatorKey: TID;
    function GetCreatorName: String;
    function GetEditionDate: TDateTime;
    function GetEditorKey: TID;
    function GetEditorName: String;
    function GetExtraConditions: TStrings;

    procedure DoAfterExtraChanged(Sender: TObject);
    function GetDSModified: Boolean;
    function GetSelectedID: TgdKeyArray;
    function GetSubSet: TgdcSubSet;
    function GetSubSetCount: Integer;
    function GetSubSets(Index: Integer): TgdcSubSet;
    procedure SetSubSets(Index: Integer; const Value: TgdcSubSet);

    // Процедура для регистрации методов TgdcBase для перекрытия их из макросов
    class procedure RegisterMethod;

    function IsSubSetStored: Boolean;
    function IsNameInScriptStored: Boolean;
    function IsReadTransactionStored: Boolean;
    function IsTransactionStored: Boolean;
    procedure SetSelectedID(const Value: TgdKeyArray);
    procedure SetSetTable(const Value: String);
    procedure SetUseScriptMethod(const Value: Boolean);

    //Функция проверки необходимости модификации записи данными из SourceDS
    //при наличии полей editiondate, editorkey
    function CheckNeedModify(SourceDS: TDataSet; IDMapping: TgdKeyIntAssoc;
      var AnAnswer: Word): Boolean;

    //Дополняет фром-часть таблицей-множеством
    function GetSetTableJoin: String;
    //Дополняет селект-часть полями таблицы-множества
    function GetSetTableSelect: String;
    procedure SetExtraConditions(const Value: TStrings);
    procedure SetOnGetSelectClause(const Value: TgdcOnGetSQLClause);
    procedure SetOnGetFromClause(const Value: TgdcOnGetSQLClause);
    procedure SetOnGetGroupClause(const Value: TgdcOnGetSQLClause);
    procedure SetOnGetOrderClause(const Value: TgdcOnGetSQLClause);
    procedure SetOnGetWhereClause(const Value: TgdcOnGetSQLClause);
    procedure SetQueryFiltered(const Value: Boolean);
    function GetObjects(Name: String): IDispatch;
    function GetVariables(Name: String): OleVariant;
    procedure SetObjects(Name: String; const Value: IDispatch);
    procedure SetVariables(Name: String; const Value: OleVariant);

  protected
    FgdcDataLink: TgdcDataLink;
    FInternalTransaction: TIBTransaction;
    FID: TID;
    FObjectName: String;
    FSQLSetup: TatSQLSetup;
    FDSModified: Boolean;
    FSQLInitialized: Boolean;
    FIgnoreDataSet: TObjectList;

    // Используется для передачи в отчеты текущей формы
    // присваивается в TgdcCreateableForm при активизации формы
    FCurrentForm: TObject;

    // Вызов списка отчетов
    procedure DoOnReportListClick(Sender: TObject);

    //
    procedure CopyEventHandlers(Dest, Source: TgdcBase);
    procedure ResetEventHandlers(Obj: TgdcBase);

    // Методы для перегрузки методов макросами
    // Метод вызывается по Inherited в макросе
    // В методе осуществляется передача параметров из макроса и
    // вызов  метода Делфи. Дальнейшая обработка идет в перекрытом методе Делфи
    // Name - имя перекрываемого метода, AnParams - вариантный массив параметров метода
    function OnInvoker(const Name: WideString; AnParams: OleVariant): OleVariant; virtual;
    // Метод очищает стек классов вызова перекрытого метода
    // AClass, AMethod - имя класса и метода, из которого вызывается процедура
    procedure ClearMacrosStack2(const AClass, AMethod: String;
      const AMethodKey: Byte);
    // Метод устанавливает класс, из которого впервые вызван перекрытый метод
    // установка делается для того, чтобы знать, где очищатьстек
    procedure SetFirstMethodAssoc(const AClass: String;
      const AMethodKey: Byte);
    // заполнение списка ключей для перекрытия методов макросами
    procedure CreateKeyList;

    //
{    function GetRecord(Buffer: PChar; GetMode: TGetMode;
                       DoCheck: Boolean): TGetResult; override;}

    //
    procedure SetSubSet(const Value: TgdcSubSet); virtual;

    // Печать отчета. OnClick - в PopupMenu
    procedure DoOnReportClick(Sender: TObject); virtual;

    // проверяет, является ли переданный класс потомком текущего класса
    // если нет -- вызывает исключение
    class procedure CheckClass(C: TClass);

    // Устанавливает DataBase и Transaction для FIBSQL
    //procedure SetIBSQL;

    // выполняет заданный СКЛ запрос
    // коммит не делает
    procedure ExecSingleQuery(const S: String); overload;
    procedure ExecSingleQuery(const S: String; Param: Variant); overload;

    // функция пытается удалить запись. Если ей это удается, то возвращает
    // Истину, если нет, то вызывает окно со списком ссылающихся таблиц
    // из-за которых не удается произвести удаление
    { TODO :
Сейчас не производится проверка на тип возникшей ошибки.
Так, если запись нельзя удалить из-за отсутствия прав
(на уровне ИБ), то все равно ситуация будет представлена так
будто идет нарушение ссылочной целостности. }
    function DeleteRecord: Boolean; virtual;

    procedure SetMasterSource(Value: TDataSource); virtual;

    // в зависимости от установленного СабСета программист
    // добавляет в этом методе в параметр С условия отбора записей.
    // каждое отдельное условие задается одной строкой и будет
    // связано в итоговом запросе через AND.
    // можно в одной строке указать несколько условий самостоятельно
    // связав их Эндами.
    // если надо несколько условий связать через логическое ИЛИ, то
    // их НАДО указать в одноу строке, связав ИЛИ.
    // концевые и лидирующие пробелы не требуются.
    // WHERE добавлять не надо!
    procedure GetWhereClauseConditions(S: TStrings); virtual;

    // запыт мы канстру_руем "на лету", складаючы яго з
    // частак, як_я вяртаюцца праз гэтыя функцы_
    function GetSelectClause: String; virtual;
    // некоторые ограничения, накладываемые, например, СабСетом
    // указываются не в секции WHERE а в секции FROM
    // при формировании запроса для рефреша записи мы
    // должны избавиться от этих ограничений
    // так как нам достаточно всего одно условия, сравнения на ИД
    function GetFromClause(const ARefresh: Boolean = False): String; virtual;

    function GetWhereClause: String; virtual;
    function GetGroupClause: String; virtual;
    function GetOrderClause: String; virtual;

    // наступныя функцы_ вяртаюць тэксты СКЛ запытаў
    // для адпаведных аб'ектаў _Б Датасета
    function GetSelectSQLText: String; virtual;
    function GetModifySQLText: String; virtual;
    function GetInsertSQLText: String; virtual;
    function GetDeleteSQLText: String; virtual;
    function GetRefreshSQLText: String; virtual;

    // _н_цыял_зуе СКЛ кампанэнты
    procedure InitSQL;

    // напрыклад аб'ект рэпрэзентуюць у базе зап_сы ў некальк_х
    // табл_цах, тады па _нсэрту мы мус_м зраб_ць некальк_
    // _нсэртаў у базу дадзеных
    //
    // асобную ўвагу трэба звярнуць на вяртаньне базы
    // у першапачатковы стан, кал_ цягам складанага _нсэрту
    // ц_ апдэйту ўзн_кае памылка. Н_жэй аб'яуленыя метады
    // мусяць, альбо цалкам выканаць аперацыю, альбо, кал_
    // ўзн_кае памылка, вернуць базу ў зыходны стан, як_
    // яна мела да таго як пачалася аперацыя кастам _нсэрт,
    // альбо кастам мод_фай _ завершыцца з генерацыяй выключнай
    // с_туацы_.
    //
    // Трэ ведаць: хто стартаваў транзакцыю.
    procedure CustomInsert(Buff: Pointer); virtual;
    procedure CustomModify(Buff: Pointer); virtual;
    procedure CustomDelete(Buff: Pointer); virtual;

    //
    procedure _CustomInsert(Buff: Pointer); virtual;
    procedure _CustomModify(Buff: Pointer); virtual;
    procedure _CustomDelete(Buff: Pointer); virtual;

    // Метод вызывается после окончания одного из процессов по
    // добавлению, редактированию, удалению
    procedure DoAfterCustomProcess(Buff: Pointer; Process: TgsCustomProcess); virtual;

    // дапаможная функцыя, выкарыстоўваецца ў CustomInsert & CustomModify
    procedure CustomExecQuery(const ASQL: String; Buff: Pointer);

    //
    procedure RefreshParams;

    //
    function GetDialogDefaultsFields: String; virtual;
    procedure LoadDialogDefaults(F: TgsStorageFolder; Dlg: TForm); overload; virtual;
    procedure LoadDialogDefaults; overload; virtual;
    procedure SaveDialogDefaults(F: TgsStorageFolder; Dlg: TForm); overload; virtual;
    procedure SaveDialogDefaults; overload; virtual;

    // перекрываем метод для выполнения следующих действий:
    // 1. проверка прав на создания записи. Вообще, интерфейс должен быть
    //    построен таким образом, чтобы у пользователя не было возможности
    //    создать новую запись, если у него нет прав. Но если
    //    все-таки мы дошли до этого метода, то надо выкинуть Исключение.
    // 2. инициализация уникального идентификатора.
    // 3. инициализация прав доступа к записи.
    // 4. инициализация прочих полей значениями по-умолчанию.
    // 5. вызов макроса обработчика события
    // 6. инициализация полей последними введенными значениями,
    //    (если объект используется в диалоговом окне).
    procedure DoOnNewRecord; override;
    procedure _DoOnNewRecord; virtual;

    // для рэдактаваньня аднаго зап_су мы выкарыстоўваем дыялогавае
    // акно. Перад тым як вывесц_ яго на экран яго трэба стварыць _
    // настро_ць, чым _ займаецца гэтая функцыя
    function CreateDialogForm: TCreateableForm; virtual;

    // !!!
    // крыху падпраўляем Борланд, каб яны падтрымл_вал_ нашыя аб'екты
    procedure InternalPostRecord(Qry: TIBSQL; Buff: Pointer); override;
    procedure InternalDeleteRecord(Qry: TIBSQL; Buff: Pointer); override;

    // на наш аб'ект звал_лася нешта з драг-энд-дропу, ц_ кл_пбоарду
    // мус_м праверыць ц_ пасуе гэта нам, тады вернем _сц_на
    // кал_ не -- _лжа
    function AcceptClipboard(CD: PgdcClipboardData): Boolean; virtual;

    //
    function GetDetailClasses(Index: Integer): CgdcBase; virtual;
    function GetDetailClassesCount: Integer; virtual;

    // копирует для заданной главной таблицы все ссылающиеся записи в детальных
    // таблицах. AnOldID -- идентификатор исходной главной записи
    // ANewID -- идентификатор записи-копии в главной таблице
    procedure CopyDetailTable(const AMasterTableName: String;
      const AnOldID, ANewID: Integer);

    //
    procedure Loaded; override;

    //
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;

    //
    procedure InternalOpen; override;
    procedure InternalSetParamsFromCursor; override;

    //
    procedure DoBeforeOpen; override;

    // перехватывая данный метод мы решаем следующие задачи:
    // 1. заполняем внутреннюю переменную информацией о структуре
    //    датасета (есть ли лескрипторы безопасности и пр.)
    // 2. локализуем назавания полей, присваиваем DisplayLabel
    procedure CreateFields; override;

    //наследованные события для запуска скриптов
    procedure DoAfterDelete; override;
    procedure DoAfterInsert; override;
    procedure DoAfterOpen; override;
    procedure DoAfterPost; override;
    procedure DoBeforeClose; override;
    procedure DoBeforeDelete; override;
    procedure DoBeforeEdit; override;
    procedure DoBeforeInsert; override;
//    procedure DoBeforeOpen; override;
    procedure DoBeforePost; override;
//    procedure DoOnNewRecord; override;
    procedure DoFieldChange(Field: TField); virtual;

    procedure DoAfterTransactionEnd(Sender: TObject); override;

    procedure LoadEventList; virtual;
    function GetGroupID: Integer; virtual;

    // Для Copy и Past
    {function GetCopyFieldName: String; virtual;
    function GetCopyValue: Variant; virtual;}

    // Список полей, которые не надо копировать
    // при копировании объекта
    // наименования полей разделены запятой
    // строка запятой не заканчивается!
    function GetNotCopyField: String; virtual;

    // две функции для добавления и удаления из списка
    // детальных объектов
    procedure AddDetailLink(AnObject: TgdcBase);
    procedure RemoveDetailLink(AnObject: TgdcBase);

    //
    procedure ValidateField(Sender: TField); virtual;

    // возвращает список классов, являющихся потомками
    // для данного класса. Используется в диалоге выбора
    // класса при создании потомка
    function GetChildrenClass(CL: TClassList): Boolean; virtual;

    // при вызове диалогового окна на редактирование из другого
    // диалогового окна мы должны запомнить какие поля были изменены
    // в этом диалоговом окне, для того, чтобы при нажатии на кнопку Ок
    // вернуть их в исходное состояние
    // использовать Cancel мы не можем, так как объект у нас один на
    // два окна
    procedure InternalSetFieldData(Field: TField; Buffer: Pointer); override;

    //
    procedure SetSubType(const Value: String); virtual;
    function GetSubType: String; virtual;

    // если бизнес-объект представляет собой объединение данных из
    // нескольких таблиц, то может возникнуть следующая ситуация:
    // для примера, возьмем объект Товар, который объединяет данные
    // из таблицы Товары и Единицы измерения. Бизнес объект
    // выводит следующие данные: Наименование товара, наименование ед.
    // измерения, Коэффициент пересчета этой единицы измерения в базовую.
    // Для редактирования данных объекта создано диалоговое окно
    // в котором используется Эдит для вывода/редактирования наименования
    // товара, выпадающий список для просмотра/выбора единицы измерения
    // Метку для вывода коэффициента пересчета. Если в выпадающем списке
    // выбрать другую единицу измерения, то надо обновить поле
    // коэффициент пересчета. Рефреш записи тут невозможен так как
    // объект (датасет) находится в состоянии редактирования.
    // Для решения данной проблемы используется метод SyncField
    // он вызывается сразу после изменения данных поля. Если
    // при изменении некоторого поля (в нашем примере это будет поле,
    // хранящее ссылку на запись в таблице единиц измерения) необходимо
    // обновить значение другого поля бизнес-объекта, физически
    // являющегося полем таблицы, на которую идет ссылка, то
    // этот метод должен быть перекрыт и в нем должен быть создан
    // и выполнен запрос, который бы вытаскивал данные из связанной
    // таблицы.
    //
    // ...кроме этого вызывается SyncControls у диалогового окна.
    procedure SyncField(Field: TField); virtual;

    // возвращает истина, если значение поля было изменено
    // в процессе редактирования текущей записи
    function FieldChanged(const AFieldName: String): Boolean;

    //
    procedure SetCustomProcess(const Value: TgsCustomProcesses);
    function GetCustomProcess: TgsCustomProcesses; virtual;

    // вспомогательная функция. в СКЛ запросе, в секции ФРОМ или ВЕРЕ
    // могут встречаться сравнения вида: имя_поля = :параметр
    // данная функция возвращает имя поля по заданному имени параметра
    // если такой параметр в запросе не фигурирует -- возвращается пустая строка
    function GetFieldNameComparedToParam(const AParamName: String): String;

    // проблема:
    // при сохранении объекта в потоке мы пробегаемся по всем
    // полям ссылкам и сохраняем объекты, на которые они
    // ссылаются. Причем сохранение осуществляется перед сохранением
    // главного объекта.
    // Однако существуют случаи, когда сохранение должно быть выполнено
    // в обратном порядке, т.е. сначала главный объект, потом
    // объект на который идет ссылка и в таком же
    // порядке должно произойти восстановление.
    // пример:
    // у компании может быть ноль, один или несколько рассчетных счетов
    // для их хранения создана таблица gd_companyaccount. Каждый
    // счет имеет свой уникальный идентификатор. Каждый счет связан
    // с компанией, которой он принадлежит через поле ссылку.
    // Ссылка должна быть обязательно заполнена.
    // Один из счетов компании является главным. Для его хранения
    // в таблицу gd_company добавлено поле companyaccountkey
    // которое содержит ссылку на главный счет. Поле может быть
    // и не заполнено.
    // Если при сохранении объекта компании следовать стандартной
    // последовательности, т.е. сначала сохранить объект счет, на который
    // идет ссылка, потом объект компанию, то при загрузке в базу
    // возникнут проблемы. Первым будет восстанавливаться объект счет
    // но он содержит обязательную ссылку на объект компанию, которая
    // еще не загружена и следовательно Пост не пройдет.
    // Решением проблемы является сохранение объектов в обратном
    // порядке: сначала объект компания, потом счет.
    // В функцию передается имя поля ссылки. Она возвращает False
    // если необходим ПРЯМОЙ порядок сохранения и ИСТИНА, если обратный.
    function IsReverseOrder(const AFieldName: String): Boolean; virtual;

    // создали новую запись (Insert). пытаемся ее сохранить (Post).
    // возникает ошибка.
    // возможно, такая запись уже существует в базе.
    // данная функция попытается найти подходящую запись
    // и, если она есть, установит курсор на нее и вернет
    // Истина. Если записи нет -- вернет Ложь.
    // При этом датасет будет выведен из состояния вставки через Cancel.
    function CheckTheSame(var AnAnswer: Word; Modify: Boolean = False): Boolean;
    //Удаляет запись по идентификатору и ее руид
    //Используется только при загрузке данных из потока
    function DeleteTheSame(AnID: Integer; AName: String): Boolean;

    // Функция использует следующую функцию, которая должна
    // вернуть сформированный запрос, который поможет отыскивать
    // такую же запись.
    function CheckTheSameStatement: String; virtual;

    //
    procedure InternalPrepare; override;
    procedure InternalUnPrepare; override;

    // создает компонент ИБСКЛ инициализируя его
    // свойства Датабэйз и Транзакция
    function CreateReadIBSQL: TIBSQL; overload;
    function CreateReadIBSQL(out DidActivate: Boolean): TIBSQL; overload;

    //
    procedure SetTransaction(Value: TIBTransaction); override;
    procedure SetReadTransaction(const Value: TIBTransaction); override;

    // переопределяя метод GetCustomProcess можно добиться того, что
    // в зависимости от состояния объекта будет применяться сложный
    // или обычный апдейт данных
    // например, если БА представляет собой объединение данных из
    // нескольких таблиц, то динамически можно возвращать кастом процесс
    // следующим образом: если изменялись только поля основной таблицы
    // то особой обработки не надо и можно передать управление обычному
    // датасетовскому обработчику, если же произошло изменение полей
    // и в основной и в присоединенных таблицах, то необходимо выполнить
    // сложный апдейт
    property CustomProcess: TgsCustomProcesses read GetCustomProcess write SetCustomProcess;

    //Дополнительные условия при слиянии записей
    function GetReductionCondition: String; virtual;
    function GetReductionTable: String; virtual;

    // для перекрытия методов макросами
    function GetGdcInterface(Source: TObject): IDispatch;
    function GetInterfaceToObject(Source: IDispatch): TObject;
    // методы для реализации Var-параметров
    function GetVarInterface(const AnValue: Variant): OleVariant;
    function GetVarParam(const AnValue: Variant): OleVariant;


    // Свойства для перекрытия методов макросами
    // свойство определяет необходимость выполнениея Inherited
    // для метода Делфи
    // для перекрытия методов, чтобы не добавлять в каждом юните ссылку на
    property gdcBaseMethodControl: IMethodControl read GetMethodControl;
    // Для храниния Класс.Метод первого Делфи класса, из которого вызвана функция
    // используется, чтобы знать, когда обнулить стек LastCallClass
    property ClassMethodAssoc: TgdKeyIntAndStrAssoc read FClassMethodAssoc;

    //
    function TestUserRights(const SS: TgdcTableInfos): Boolean;

    function GetCanChangeRights: Boolean; virtual;
    function GetCanCreate: Boolean; virtual;
    function GetCanDelete: Boolean; virtual;
    function GetCanEdit: Boolean; virtual;
    function GetCanPrint: Boolean; virtual;
    function GetCanView: Boolean; virtual;

    //
    procedure SetBaseState(const ABaseState: TgdcStates);

    //
    procedure DoBeforeInternalPostRecord; virtual;
    procedure DoAfterInternalPostRecord; virtual;

    //
    function GetFieldByNameValue(const AField: String): Variant;

    //Перечень свойств, которые необходимо сохранять в поток
    //Разделять запятыми
    function GetPropertiesForStream(const ASubType: TgdcSubType): String; virtual;

  public

    constructor Create(AnOwner: TComponent); override;

    //
    constructor CreateSubType(AnOwner: TComponent; const ASubType: TgdcSubType;
      const ASubSet: TgdcSubSet = 'All'); virtual;

    //
    constructor CreateWithParams(AnOwner: TComponent;
      ADatabase: TIBDatabase;
      ATransaction: TIBTransaction;
      const ASubType: TgdcSubType = '';
      const ASubSet: TgdcSubSet = 'All';
      const AnID: Integer = -1); virtual;

    //
    constructor CreateWithID(AnOwner: TComponent;
      ADatabase: TIBDatabase;
      ATransaction: TIBTransaction;
      const AnID: Integer;
      const ASubType: String = ''); virtual;

    destructor Destroy; override;

    procedure BeforeDestruction; override;

    procedure DataEvent(Event: TDataEvent; Info: Longint); override;

    // инициализируем СКЛ после полного окончания конструирования
    procedure AfterConstruction; override;

    //
    procedure Prepare;
    procedure UnPrepare;

    // если датасет был переведен в состояние редактирования
    // а потом вызван Пост, но никаких изменений произведено не было
    // вызываем Отмену, вместо продолжения Поста.
    // делаем это для того, чтобы избежать конфликта на не ждущей
    // транзакции, когда пользователь зашел в диалоговое окно
    // только посмотрел данные и вышел по Ок
    procedure Post; override;

    // функция проверки сабсета на допустимое значение
    // на уровне базового класса мы определяем два
    // допустимых подмножества, которые должны поддерживать
    // все наследники: All и ByIDz
    function CheckSubSet(const ASubSet: String): Boolean; virtual;

    //
    function CreateBlobStream(Field: TField; Mode: TBlobStreamMode): TStream; override;

{
    Для TgdcBase добавлены  методы
    1)    procedure ChooseItems(DoProcess: Boolean = True); overload;
        осуществялет выбор из объекта того же типа, что и объект вызвавший метод
    2)    procedure ChooseItems(Cl: CgdcBase; out KeyArray: TgdKeyArray;
        DoProcess: Boolean = True); overload;
        осуществялет выбор из объекта типа Cl
    для выбора записей из объектов. Флаг DoProcess указывает нужно ли автоматически
    "обрабатывать" выбранные записи (для этого служит метод ProcessChooseItems).
    Ключи выбранных записи в первом случае заносятся в свойство SelectedID объекта,
    вызвавшего ChooseItems, во втором случае они возвращаюся параметром KeyArray.

    Для работы Choose необходимо перекрыть в gdc-объекте слудующие методы:
    // Возращает имя формы
        class function GetViewFormClassName(const ASubType: TgdcSubType): String; virtual;
    а также перекрыть  методы для gdc_creatable_form
    //Производит настройку формы для режима Choose
          procedure SetChoose(AnObject: TgdcBase); virtual; AnObject - объект вызвавший ChooseItems
    в FormCreate указать, какой объект будет использоваться для Choose (для форм мастер-дитейл). По умолчанию берется главный объект. (Например, FgdcLinkChoose := gdcDetailObject)

}
    function ChooseItems(DoProcess: Boolean = True;
      const ChooseComponentName: String = '';
      const ChooseSubSet: String = ''): Boolean; overload;
    function ChooseItems(Cl: CgdcBase;
      KeyArray: TgdKeyArray;
      DoProcess: Boolean = True;
      const ChooseComponentName: String = '';
      const ChooseSubSet: String = '';
      const ChooseSubType: TgdcSubType = ''): Boolean; overload;

    // мы используем эту функцию для передачи хэндла
    // в месадже бокс, чтобы каждый раз не проверять
    // задан родительский управляющий элемент или нет
    // если объект находится на форме, то возвращается
    // хэндл формы. если для объекта открыто диалоговое окно
    // то возвращается хэндл диалогового окна
    function ParentHandle: Integer;

    // выводит на экран меню со списком доступных для объекта отчетов
    procedure PopupReportMenu(const X, Y: Integer);

    //
    procedure PopupFilterMenu(const X, Y: Integer);

    // функции производят поиск объекта (ов)
    // возвращают ИД (или список ИД)
//    procedure Find;

    // мы вымушаныя перавызначыць гэтую функцыю, бо
    // яе няма ў TIBCustomDataSet
    function ParamByName(Idx : String) : TIBXSQLVAR;

    // стварае новы зап_с _ адкрывае дыялог для яго рэдактаваньня
    function CreateDialog(const ADlgClassName: String = ''): Boolean; overload; virtual;
    function CreateDialog(C: CgdcBase): Boolean; overload; virtual;
    function CreateDialog(C: TgdcFullClass): Boolean; overload; virtual;

    // делает новую запись, с предварительным выбором потомков
    function CreateDescendant: Boolean; virtual;

    // стварае коп_ю бягучага зап_су _ адкрывае дыялог для яго рэдактаваньня
    function CopyDialog: Boolean; virtual;

    // запускается перед появлением дилогового окна ввода нового
    // объекта или редактирования старого
    procedure DoBeforeShowDialog(DlgForm: TCreateableForm); virtual;

    // запускается после закрытия дилогового окна ввода нового
    // объекта или редактирования старого
    procedure DoAfterShowDialog(DlgForm: TCreateableForm; IsOk: Boolean); virtual;

    // выдаляе адразу некальк_ зап_саў, дазеных праз букмаркл_ст
    function DeleteMultiple(BL: TBookmarkList): Boolean;

    // рэдактаваньне бягучага зап_су
    // у дыялоге, вяртае _сц_на, кал_ карыстальн_к
    // выйшаў па Ок _ Хлусня ў адваротным выпадку
    function EditDialog(const ADlgClassName: String = ''): Boolean; virtual; { Не убирать нужно для проводок }

    // функцыя адкрывае бягучы зап_с на рэдактаваньне
    // потым прабягае па сьп_су зап_саў _ рэдактуе _х
    // прысва_ваючы тыя паля, як_я был_ зьмененыя пад
    // час рэдактаваньня
    function EditMultiple(BL: TBookmarkList; const ADlgClassName: String = ''): Boolean;

    // функцыя кап_раваньня бягучага зап_су
    // в заданных полях, в копии, будут установлены заданные
    // значения. Возможно копирование также записей в
    // дитэйл таблицах, ссылающихся на исходную запись
    function Copy(const AFields: String; AValues: Variant; const ACopyDetail: Boolean = False;
      const APost: Boolean = True; const AnAppend: Boolean = False): Boolean; virtual;

    // захоўвае бягучы зап_с (кал_ ён рэдактаваўся)
    // _ ўстаўляе наступны. Функцыя прызначана для выкарыстаньня
    // ў дыялогавых вокнах (кнопка Наступны)
    procedure CreateNext;

    // поддержка работы с клипбоардом
    // копирует в клипбоард текущую запись (BL = nil) или список записей
    procedure CopyToClipboard(BL: TBookmarkList; const ACut: Boolean = cCopy);
    function PasteFromClipboard(const ATestKeyboard: Boolean = False): Boolean;

    // возвращает Истина, если в клипбоарде есть значение
    // которое может быть вставлено
    function CanPasteFromClipboard: Boolean; virtual;

    // позволяет присвоить значение заданному полю в заданной записи
    // для этого выполняется отдельный СКЛ
    procedure AssignField(const AnID: Integer; const AFieldName: String; AValue: Variant);

    // некоторые поля никогда не должны появляться в гриде
    // данная функция позволяет указать гриду что поле не стоит
    // отображать. Функция должна вернуть список имен полей, разделенных точкой
    // с запятой.
    // список должен оканчиваться точкой с запятой.
    function HideFieldsList: String; virtual;
    function ShowFieldInGrid(AField: TField): Boolean;

    // обновляет содержимое ДатаСета с сохранением
    // текущей позиции
    procedure CloseOpen;

    // не перемещая положение текущей записи "подсмотрим"
    // в кэше идентификатор записи, указанный закладкой
    function GetIDForBookmark(const Bm: TBookmarkStr): TID;

    // возвращает значение заданного поля для записи, заданной
    // идентификатором
    function GetFieldValueForID(const AnID: TID; const AFieldName: String): Variant;
    function GetFieldValueForBookmark(const ABookmark: TBookmarkStr; const AFieldName: String): Variant;
    procedure SetValueForBookmark(const ABookmark: TBookmarkStr; const AFieldName: String; const AValue: Variant);

    // нам патрэбны метады каб захоўваць дадзеныя датасета ў
    // плын_ _ счытваць _х адтуль
    procedure _SaveToStream(Stream: TStream; ObjectSet: TgdcObjectSet;
      PropertyList: TgdcPropertySets; BindedList: TgdcObjectSet;
      const SaveDetailObjects: Boolean = True); virtual;
    procedure _LoadFromStream(Stream: TStream; IDMapping: TgdKeyIntAssoc;
      ObjectSet: TgdcObjectSet; UpdateList: TObjectList);

    //Загрузка данных из потока в текущий обхект
    procedure _LoadFromStreamInternal(Stream: TStream;
      IDMapping: TgdKeyIntAssoc; ObjectSet: TgdcObjectSet;
      UpdateList: TObjectList; StreamRecord: TgsStreamRecord; var AnAnswer: Word;
      const SelectRuid, DeleteRuid, UpdateRuid, TempSQL: TIBSQL);


    procedure SaveToStream(Stream: TStream; DetailDS: TgdcBase;
      const BL: TBookmarkList = nil; const OnlyCurrent: Boolean = True); virtual;
    procedure LoadFromStream(Stream: TStream); 

    function QuerySaveFileName(const AFileName: String = ''): String;
    function QueryLoadFileName(const AFileName: String = ''): String;

    procedure SaveToFile(const AFileName: String = ''; const ADetail: TgdcBase = nil;
      const BL: TBookmarkList = nil; const OnlyCurrent: Boolean = True);
    procedure LoadFromFile(const AFileName: String = '');

    // Слияние двух записей
    function Reduction(BL: TBookmarkList): Boolean; virtual;

    // метод проверяет находится ли Датасет в активном
    // состоянии, в режиме просмотра и не пустой ли он
    // в противном случае генерируется исключение.
    // метод применяется в других методах которые выполняют
    // некоторое действие на основании данных полей из
    // текущей записи. т.е. когда надо быть уверенным, что
    // текущая запись доступна.
    procedure CheckCurrentRecord;

    //
    function GetCurrRecordClass: TgdcFullClass; virtual;

    // Возвращает значение дисплейного поля по ключу
    class function GetListNameByID(const AnID: TID;
      const ASubType: TgdcSubType = ''): String;

    //
    class function Class_TestUserRights(const SS: TgdcTableInfos;
      const ST: String): Boolean;

    // метод создает копию переданного объекта, при этом копируются
    // следующие свойства:
    // 1. транзакция
    // 2. подмножество
    // 3. DialogActions
    //
    procedure Assign(Source: TPersistent); override;

    // предоставляет пользователю возможность выбрать один из классов
    // наследников для данного класса
    function QueryDescendant: TgdcFullClass;

    // отменяет изменения в полях, используется совместно с sSubDialog
    procedure RevertRecord;

    //Изменение RefreshSQL
    procedure SetRefreshSQLOn(SetOn: Boolean);

    // процедура заполняет переданный список уникальными значениями
    // из заданной колонки. Значения преобразуются в строку.
    // опционально можно задать: сортировать список уникальных значений
    // или нет.
    procedure GetDistinctColumnValues(const AFieldName: String; S: TStrings; const DoSort: Boolean = True);

    // функция возвращает следующее уникальное значение идентификатора
    // объекта. Если параметр установлен в Истина, то генераторы
    // увеличиваются. Функция должна быть переопределена для тех
    // объектов, которые используют свои генераторы для идентификации.
    function GetNextID(const Increment: Boolean = True): Integer; virtual;

    //
    function HasAttribute: Boolean;

    //
    function GetRUID: TRUID;

    // создает форму для просмотра датасета, для заданного БА
    // поскольку форм может быть предусмотрено несколько, то возможна
    // передача имени класса при вызове функции
    class function CreateViewForm(AnOwner: TComponent; const AClassName: String = '';
      const ASubType: String = ''; const ANewInstance: Boolean = False): TForm; 

    class function GetViewFormClassName(const ASubType: TgdcSubType): String; virtual;

    // фукнция обновляет статистику объекта и сохраняет ее в хранилище
    class procedure RefreshStats;

    // возвращает большая это таблица или нет. Необходимо нам для
    // корректной обработки больших списков в лукапе.
    class function IsBigTable: Boolean;

    //

    class function IsAbstractClass: Boolean; virtual;

    // стварае аб'ект _ адкрывае зап_с з дадзеным _Д
    // кал_ такога няма ў базе -- к_даецца выключная с_туацыя
    class function CreateSingularByID(AnOwner: TComponent; ADatabase: TIBDatabase;
      ATransaction: TIBTransaction; const AnID: TID; const ASubType: String = ''): TgdcBase; overload; virtual;
    class function CreateSingularByID(AnOwner: TComponent;
      const AnID: TID; const ASubType: String = ''): TgdcBase; overload; virtual;

    // асноўная табл_ца аб'екту
    // кал_ дадзеныя аб'екту захоўваюцца ў адной табл_цы,
    // тады гэта яе _мя. Кал_ ў некальк_х, звязаных сувязьзю
    // адз_н-да-аднаго, альбо адз_н-да-шматл_к_х, альбо шмат-да-шматл_к_х
    // тады гэтая функцыя вяртае _мя галоўнай табл_цы
    // галоўная табл_ца, гэта тая табл_ца, кожны зап_с якой рэпрэзентуе
    // адз_н _ тольк_ адз_н аб'ект дадзенага тыпу _ якая ўтрымл_вае першасны
    // ключ
    class function GetListTable(const ASubType: TgdcSubType): String; virtual;
    // поле з назвай аб'екту
    class function GetListField(const ASubType: TgdcSubType): String; virtual;
    // поля для расширенного отображения в лукапе (через ,)
    class function GetListFieldExtended(const ASubType: TgdcSubType): String; virtual;
    // алiас для аб'екта
    class function GetListTableAlias: String;
    // поле з _дэнтыф_катарам аб'екту
    class function GetKeyField(const ASubType: TgdcSubType): String; virtual;

    // умова выдзяленьня падмноства аб'ектаў з усяго
    // мноства зап_саў у табл_цы
    class function GetRestrictCondition(const ATableName, ASubType: String): String; virtual;

    // кал_ трэба будзе вывесц_ назву аб'екта, рэпрэзентуемага
    // дадзеным клясам карыстальн_ку
    // па-ўмалчаньню, выводз_ць лакал_заваны назоў галоўнай табл_цы
    class function GetDisplayName(const ASubType: TgdcSubType): String; virtual;

    // функция, возвращает список возможных подтипов в SubTypeList в формате
    // Локализованное имя подтипа=Подтип
    // функция возвращает True, если подтипы есть, иначе - False
    class function GetSubTypeList(SubTypeList: TStrings): Boolean; virtual;

    // вяртае _нфармацыю аб структуры галоўнай табл_цы БА, выкарыстоўваючы
    // атДатабэйз. Так_м чынам гэты метад можа быць выкл_каны ў любы момант
    // адразу пасля таго як створаны _ _н_цыял_заваны аб'ект атДатабэйз.
    class function GetTableInfos(const ASubType: String): TgdcTableInfos; virtual;

    // вяртае сьп_с дапушчальных сабсэтаў для дадзенага кляса
    // сабсеты раздзяляюцца кропкай з коскай. Апошн_ сабсэт у сьп_се
    // таксама закрываецца кропкай з коскай.
    // Прыклад:
    //   All;ByID;ByName;OnlySelected;
    class function GetSubSetList: String; virtual;

    // некоторые бизнес объекты требуют обязательного комита для
    // полного сохранения данных. Например, в объектах представляющих
    // метаданные реальное создание/изменение метаданных в базе
    // происходит по комиту. При загрузке таких объектов из потока
    // после поста каждой записи обязательно надо сделать комит.
    class function CommitRequired: Boolean; virtual;

    // функция возвращает картинку класса для отображения,
    // например, в дереве
    class procedure GetClassImage(const ASizeX, ASizeY: Integer; AGraphic: TGraphic); virtual;

    // для заданного алиаса поля (TField.FieldName) возвращает
    // имя таблицы
    function RelationByAliasName(const AnAliasName: String): String;

    // для заданного алиаса поля (TField.FieldName) возвращает
    // физическое имя поля в таблице
    function FieldNameByAliasName(const AnAliasName: String): String;

    // находит поле по имени таблицы и имени этого поля в таблице
    // (не алиасу, который может быть указан для поля в запросе!)
    // имя поля и имя таблицы передаются без кавычек
    // регистр не различается
    function FindField(ARelationName, AFieldName: String): TField; overload;
    function FieldByName(const ARelationName, AFieldName: String): TField; overload;

    //
    procedure AddToSelectedID(const AnID: Integer = -1); overload;
    procedure AddToSelectedID(ASelectedID: TgdKeyArray); overload;
    procedure AddToSelectedID(BL: TBookmarkList); overload;
    procedure RemoveFromSelectedID(const AnID: Integer = -1); overload;
    procedure RemoveFromSelectedID(BL: TBookmarkList); overload;
    procedure SaveSelectedToStream(S: TStream);
    procedure LoadSelectedFromStream(S: TStream);

    //
    class function SelectObject(const AMessage: String = '';
      const ATitle: String = '';
      const AHelpCtxt: Integer = 0): TID; virtual;

    // функцы_ вяртаюць _мя аб'екту для дадзенага _Д,
    // друг_ варыянт падтрымл_вае падтыпы
    class function QGetNameForID(const AnID: TID; const ASubType: String = ''): String;
    class function QGetNameForID2(const AnID: TID; const ASubType: TgdcSubType): String;


    function  ObjectExists(const Name: String): Boolean;
    function  VariableExists(Name: String): Boolean;
    // Процедуры только для использования в скрипт-функциях
    // Добавляют итем для хранения Variables
    procedure AddVariableItem(const Name: String);
    // Добавляют итем для хранения Objects
    procedure AddObjectItem(const Name: String);

    // Свойства только для использования в скрипт-функциях
    // В СФ являются аналогами свойств формы
    // Список переменных привязанных к форме
    property Variables[Name: String]: OleVariant read GetVariables write SetVariables;
    // Список объектов привязанных к форме
    property Objects[Name: String]: IDispatch read GetObjects write SetObjects;

    // для вываду _мя классу на экран
    //  property DisplayName: String read GetDisplayName;

    // пры вывадзе на экран дыялогаў _ акон трэба ўказаць
    // бацькоўск_ контрал (форму)
    // як прав_ла, ParentForm -- форма, на якой знаходз_цца
    // БА, вял_кая форма для прагладу дадзеных БА
    property ParentForm: TWinControl read FParentForm;

    // заўважым што канцэпцыя _Д яшчэ да канца не распрацаваная...
    property ID: Integer read GetID write SetID;

    //
    property ObjectName: String read GetObjectName write SetObjectName;

    // количество детальных таблиц (детальных классов)
    // в связи мастер-детаил с данным классом
    property DetailClassesCount: Integer read GetDetailClassesCount;
    // список классов детальных классов
    property DetailClasses[Index: Integer]: CgdcBase read GetDetailClasses;

    // Количество детальных объектов, связанных с данным через
    // master-detail
    property DetailLinksCount: Integer read GetDetailLinksCount;
    // Указатель на один из списка детальных объектов
    property DetailLinks[Index: Integer]: TgdcBase read GetDetailLinks;

    //
    property EventList: TStringList read FEventList;

    property Params;
    property gdcTableInfos: TgdcTableInfos read FgdcTableInfos;

    // Состояние объекта на данный момент
    property BaseState: TgdcStates read FBaseState write SetBaseState;

    property SelectSQL;
    property GroupID: Integer read GetGroupID;

    // понадобилось Антону для обработки в окне поиска
    property HasWhereClause: Boolean read GetHasWhereClause;

    //
    property Filter: TQueryFilterGDC read FFilter;

    // Событие, которое вызывается после INITSQL и дает возможность изменить созданный запрос
    // пока находится в паблик части, если кому необходимо, в своем классе вынести в паблишед.
    property OnAfterInitSQL: TgdcAfterInitSQL read FAfterInitSQL write FAfterInitSQL;

    // на ўзроўн_ базавага класа падтрымл_ваецца _нфармацыя аб стваральн_ку
    // даце _ часу стварэньня аб'екту, рэдактары _ даце _ часу рэдактаваньня
    //
    // для гэтага галоўная табл_ца мус_ць мець пал_:
    //   creationdate dcreationdate
    //   creatorkey   dforeignkey
    // и/или
    //   editiondate  deditiondate
    //   editorkey    dforeignkey
    // запаўненьне гэтых палёў бярэ на сябе б_знэс-аб'ект
    // атрымаць доступ да _х можна праз адпаведныя ўласц_васц_ (гл. н_жэй)
    // альбо непасрэдна звяртаючыся да палёў аб'екта
    // ў апошн_м выпадку папярждне трэба праверыць у gdcTableInfos
    // ц_ ёсць так_я пал_ ў табл_цы. Заўважым, што карыстацца FindField
    // недарэчна, бо яна можа выцягнуць поле не з галоўнай табл_цы, а
    // з дапасаванай.
    // Асобная заўвага наконта _ндэксаў па гэтых палёх:
    // ствараць _х не рэкамендуецца, бо гэта замедл_ць аперацы_
    // устаўк_ _ абнаўленьня зап_су. Гэта ж тычыцца знешняга ключа
    // па палям спасылкам.
    // Прагладзець _нфармацыю можна ў стандартным акне Ўласц_васц_ аб'екту.
    property CreationDate: TDateTime read GetCreationDate;
    property CreatorKey: TID read GetCreatorKey;
    property CreatorName: String read GetCreatorName;
    property EditionDate: TDateTime read GetEditionDate;
    property EditorKey: TID read GetEditorKey;
    property EditorName: String read GetEditorName;

    // если установлено в Истину то после Поста или удаления записи
    // рефрешит мастер запись в мастер датасете (если такой есть)
    // по умолчанию отключено
    property RefreshMaster: Boolean read FRefreshMaster write FRefreshMaster;

    //
    property DSModified: Boolean read GetDSModified;

    //
    property SelectedID: TgdKeyArray read GetSelectedID write SetSelectedID;

    property SubSetCount: Integer read GetSubSetCount;
    property SubSets[Index: Integer]: TgdcSubSet read GetSubSets write SetSubSets;

    function HasSubSet(const ASubSet: TgdcSubSet): Boolean;
    procedure DeleteSubSet(const Index: Integer);
    procedure RemoveSubSet(const ASubSet: TgdcSubSet);
    procedure AddSubSet(const ASubSet: TgdcSubSet);
    procedure ClearSubSets;

    //
    procedure SetInclude(const AnID: TID); virtual;
    //исключает текущую запись
    procedure SetExclude(const Reopen: Boolean); virtual;

    function GetClassName: String;

    // Добавлено для разграничения прав доступа
    property CanCreate: Boolean read GetCanCreate;
    property CanEdit: Boolean read GetCanEdit;
    property CanView: Boolean read GetCanView;
    property CanDelete: Boolean read GetCanDelete;
    property CanPrint: Boolean read GetCanPrint;
    property CanChangeRights: Boolean read GetCanChangeRights;

    //
    //property QSelect;

    //Функция используется при загрузке данных из потока
    //Мы ищем запись по CheckTheSameStatement, и если находим ее,
    //то пытаемся обновить данными из потока
    //Если NeedModifyFromStream будет возвращать Ложь, обновления не будет (например, в контактах)
    class function NeedModifyFromStream(const SubType: String): Boolean; virtual;

    //Функция используется при загрузке данных из потока
    //Мы ищем запись по CheckTheSameStatement, и если находим ее,
    //то пытаемся удалить
    //Необходимо при загрузке некоторых мастер-дитейл объектов
    //Например, при загрузке настройки, если мы уже нашли подобную, мы ее сначала удалим
    //Если NeedDeleteTheSame будет возвращать Ложь, удаления не будет
    class function NeedDeleteTheSame(const SubType: String): Boolean; virtual;

    property UseScriptMethod: Boolean read FUseScriptMethod write SetUseScriptMethod;

    //добавлена часть write чтобы можно было заполнять сразу на форме
    //возвращено в паблик, т.к. на форме сохраняет абы-что
    property ExtraConditions: TStrings read GetExtraConditions write SetExtraConditions;

    //
    property QueryFiltered: Boolean read FQueryFiltered write SetQueryFiltered default DefQueryFiltered;

    // Список полей, для которых вызывается событие DoFieldChange
    // Если список пуст, то событие вызывается для всех полей.
    property FieldsCallDoChange: TStringList read FFieldsCallDoChange;

  published
    //У нас есть класс-функция, которая по умолчанию возвращает для класса
    //модифицировать ли его при загрузке из потока
    //Однако для данных может понадобится свойство, указывающее
    //модифицировать ли нам объект и которое можно будет изменять в процессе работы
    //Это свойство используется только для загрузки из потока, а потому оно будет сохранено в поток!!!
    property ModifyFromStream: Boolean read FModifyFromStream write FModifyFromStream
      stored False;

    //
    property SubType: String read GetSubType write SetSubType;

    // наш механ_зм сувяз_ мастер-дз_тэйл
    property MasterSource: TDataSource read GetMasterSource write SetMasterSource;
    property MasterField: String read GetMasterField write SetMasterField;
    property DetailField: String read GetDetailField write SetDetailField;

    // падмноства аб'ектаў з усёй сукупнасц_ аб'ектаў дадзенага тыпу
    // задаецца праз падмноства -- строкавы парамэтр
    // пры прысвайваньн_ датасэт заўсёды зачыняецца
    property SubSet: TgdcSubSet read GetSubSet write SetSubSet
      stored IsSubSetStored;

    // падмноства для вакна пошуку. Яно можа адрозн_вацца ад падмноства ў
    // аб'екце
//    property SearchSubSet: TgdcSubSet read FSearchSubSet write SetSearchSubSet;

    //
    property SetTable: String read FSetTable write SetSetTable;

    // имя компоненты для использования в макросах
    property NameInScript: String read GetNameInScript write FNameInScript
      stored IsNameInScriptStored;

    // вызывается когда изменяется фильтр, ивент необходим, чтобы
    // можно было отобразить изменение фильтра на экране
    property OnFilterChanged: TNotifyEvent read FOnFilterChanged write FOnFilterChanged;

    // наследаваныя ўласц_васц_
    property Active default False;
    property CachedUpdates;
    property Database stored False;

    //
    property ReadTransaction stored IsReadTransactionStored;
    property Transaction stored IsTransactionStored;

    // Событие вызывается перед открытием диалогового окна
    property BeforeShowDialog: TgdcDoBeforeShowDialog read FBeforeShowDialog write FBeforeShowDialog;
    // Событие вызывается после закрытия диалогового окна
    property AfterShowDialog: TgdcDoAfterShowDialog read FAfterShowDialog write FAfterShowDialog;

    //
    property Filtered;
    property OnFilterRecord;

    property OnGetSelectClause: TgdcOnGetSQLClause read FOnGetSelectClause write SetOnGetSelectClause;
    property OnGetFromClause: TgdcOnGetSQLClause read FOnGetFromClause write SetOnGetFromClause;
    property OnGetWhereClause: TgdcOnGetSQLClause read FOnGetWhereClause write SetOnGetWhereClause;
    property OnGetGroupClause: TgdcOnGetSQLClause read FOnGetGroupClause write SetOnGetGroupClause;
    property OnGetOrderClause: TgdcOnGetSQLClause read FOnGetOrderClause write SetOnGetOrderClause;

  end;

  CIBError = class of EIBError;

  ////////////////////////////////////////////////////////
  // используется для сигнализирования об ошибках
  // пришедших нам из ИБ
  EgdcIBError = class(EIBError)
  private
    FOriginalClass: CIBError;

  public
    constructor CreateObj(E: EIBError; AnObj: TgdcBase);

    property OriginalClass: CIBError read FOriginalClass;
  end;

  EgdcIDNotFound = class(EgdcIBError)
  end;

  ////////////////////////////////////////////////////////
  // используется для сигнализирования об ошибках,
  // произошедших в бизнес-объекте
  EgdcException = class(Exception)
  public
    constructor CreateObj(const AMessage: String; AnObj: TgdcBase); overload;
  end;

  ////////////////////////////////////////////////////////
  // используется для сигнализирования о ситуациях с
  // недостатком прав у пользователя
  EgdcUserHaventRights = class(EgdcException);

  TgdcDragObject = class(TDragObject)
  public
    BL: TBookmarkList;
    SourceControl: TWinControl;

    constructor Create(ASourceControl: TWinControl); reintroduce;
  end;

  TIBCustomDataSetCrack = class(TIBCustomDataSet);

  {
  Вместо кода:

    ...
    var
      DidActivate: Boolean;
    begin
      DidActivate := ActivateTransaction;
      try
        ...
        try
          ...
        except
          if DidActivate and Transaction.InTransaction then
            Transaction.Rollback;
          raise;
        end;
        ...
      finally
        if DidActivate and Transaction.InTransaction then
          Transaction.Commit;
      end;
    end

  Можно писать:

    ...
    var
      I: IgdcTransactionGuard;
    begin
      I := TgdcTransactionGuard.Create(Transaction);
      ...
      try
        ...
      except
        I.Action := taRollback;
        raise;
      end;
    end
  }

  IgdcTransactionGuard = interface
    function GetTransaction: TIBTransaction;
    function GetAction: TTransactionAction;
    procedure SetAction(AnAction: TTransactionAction);

    property Action: TTransactionAction read GetAction write SetAction;
    property Transaction: TIBTransaction read GetTransaction;
  end;

  {
  TgdcTransactionGuard = class(TInterfacedObject, IgdcTransactionGuard)
  private
    FTransaction: TIBTransaction;
    FDidActivate: Boolean;
    FAction: TTransactionAction;

    function GetAction: TTransactionAction;
    procedure SetAction(AnAction: TTransactionAction);
    function GetTransaction: TIBTransaction;

  public
    constructor Create(ATransaction: TIBTransaction);
    destructor Destroy; override;

    property Action: TTransactionAction read GetAction write SetAction;
    property Transaction: TIBTransaction read GetTransaction;
  end;
  }

  {
  Вместо кода:

    ...
    var
      DidActivate: Boolean;
      q: TIBSQL;
    begin
      q := TIBSQL.Create(nil);
      DidActivate := ActivateTransaction;
      try
        q.Transaction := Transaction;
        ...
        try
          ...
        except
          if DidActivate and Transaction.InTransaction then
            Transaction.Rollback;
          raise;
        end;
        ...
      finally
        q.Free;
        if DidActivate and Transaction.InTransaction then
          Transaction.Commit;
      end;
    end

  Можно писать:

    ...
    var
      I: IgdcQTransactionGuard;
    begin
      I := TgdcQTransactionGuard.Create(Transaction);
      ...
      try
        ...
      except
        I.Action := taRollback;
        raise;
      end;
    end

    к IBSQL мы обращаемся как I.q
  }

  {
  IgdcQTransactionGuard = interface(IgdcTransactionGuard)
    function GetQ: TIBSQL;

    property q: TIBSQL read GetQ;
  end;
  }

  {
  TgdcQTransactionGuard = class(TgdcTransactionGuard, IgdcQTransactionGuard)
  private
    Fq: TIBSQL;

    function GetQ: TIBSQL;

  public
    constructor Create(ATransaction: TIBTransaction);
    destructor Destroy; override;

    property q: TIBSQL read GetQ;
  end;
  }

var
  // мы регистрируем свой формат для передачи объектов через
  // клипбоард
  gdcClipboardFormat: Word;

const
  gdcClipboardFormatName: array[0..12] of Char = 'AndreiKireev'#00;
  gdcCurrentClipboardSignature = $56889103;
  gdcCurrentClipboardVersion = $00000001;

// возвращает наиболее абстрактный базовый класс для
// указанной таблицы, т.е. для GD_CONTACT вернет TgdcBaseContact,
// а не TgdcContact или TgdcContactList
// если для таблицы нет базового класса. например, это кросс таблица,
// то возвращает пустую запись: класс=нил и подтип=пустой строке
function GetBaseClassForRelation(const ARelationName: String): TgdcFullClass;

// в функцию передается класс, она заполняет список классами, которые
// наследуются от заданного и возвращает Истину или Ложь, если
// наследников нет. Третий параметр определяет будут учитываться
// только непосредственные наследники или далекие родственники тоже.
function GetDescendants(AnAncestor: CgdcBase; AClassList: TClassList; const OnlyDirect: Boolean = True): Boolean;

//
function GetClassForObjectByID(ADatabase: TIBDatabase; ATransaction: TIBTransaction;
  AClass: CgdcBase; const ASubType: TgdcSubType; const AnID: Integer): CgdcBase;

//
procedure Register;

// helper function
function IndexOfStr(const S: String; const A: array of String): Integer;

//
function MakeFullClass(C: CgdcBase; const ASubType: TgdcSubType): TgdcFullClass;

//
function RUIDToStr(const ARUID: TRUID): String;
function StrToRUID(const AString: String): TRUID;
function RUID(const XID, DBID: TID): TRUID;


//
function gdcFullClass(const AgdClass: CgdcBase;
  const ASubType: TgdcSubType): TgdcFullClass;
function gdcFullClassName(const AgdClassName: TgdcClassName;
  const ASubType: TgdcSubType): TgdcFullClassName;

implementation

{$R gdcClasses.dcr}

uses
  IBTable,              DBClient,           gd_security,
  at_classes,           dialogs,            jclSelected,
  gdc_frmG_unit,        ActiveX,            IBUtils,
  rp_BaseReport_Unit,   IBQuery,            rp_dlgEnterParam_unit,
  Gedemin_TLB,          jclStrings,         gdcMetaData,
  IBErrorCodes,         gd_strings,         gdc_createable_form,
  TypInfo,              dmImages_unit,      gd_ClassList,

  comctrls,             gsDBDelete_dlgTableValues,
  rp_ReportClient,      gdc_dlgQueryDescendant_unit,
  gdc_dlgObjectProperties_unit,             gsDBReduction,
  gdc_dlgCantCreateObject_unit,             flt_sql_parser,
  gdcClasses,           gdc_dlgG_unit,      gdc_dlgSelectObject_unit,
  mtd_i_Inherited,      gdcOLEClassList,    prp_methods,
  gs_Exception,         gd_directories_const,Storages,
  at_sql_parser,        scrReportGroup,    at_frmSQLProcess;

var
  CacheDBID: TID;
  CacheList: TStringList;
  CacheBaseClassForRel: TStringList;

type
  TgdcReferenceUpdate = class(TObject)
  public
    C: CgdcBase;
    TableName: String;
    FieldName: String;
    KeyFieldName: String;
    ID: TID;
    RefID: TID;
  end;

procedure Register;
begin
  RegisterComponents('gdc', [TgdcBaseManager]);
end;

function gdcFullClass(const AgdClass: CgdcBase;
  const ASubType: TgdcSubType): TgdcFullClass;
begin
  Result.gdClass := AgdClass;
  Result.SubType := ASubType;
end;

function gdcFullClassName(const AgdClassName: TgdcClassName;
  const ASubType: TgdcSubType): TgdcFullClassName;
begin
  Result.gdClassName := AgdClassName;
  Result.SubType := ASubType;
end;

function RUIDToStr(const ARUID: TRUID): String;
begin
  with ARUID do
    if (XID = -1) or (DBID = -1) then
      Result := ''
    else
      Result := IntToStr(XID) + '_' + IntToStr(DBID);
end;

function StrToRUID(const AString: String): TRUID;
var
  P: Integer;
begin
  with Result do
    if AString = '' then
    begin
      XID := -1;
      DBID := -1;
    end else begin
      P := Pos('_', AString);
      if P = 0 then
        raise Exception.Create('Invalid RUID string')
      else begin
        XID := StrToInt(Copy(AString, 1, P - 1));
        DBID := StrToInt(Copy(AString, P + 1, 255));
      end;
    end;
end;

function RUID(const XID, DBID: TID): TRUID;
begin
  Result.XID := XID;
  Result.DBID := DBID;
end;

function IndexOfStr(const S: String; const A: array of String): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to High(A) do
    if S = A[I] then Result := I;
end;

function MakeFullClass(C: CgdcBase; const ASubType: TgdcSubType): TgdcFullClass;
begin
  Result.gdClass := C;
  Result.SubType := ASubType;
end;

function GetClassForObjectByID(ADatabase: TIBDatabase; ATransaction: TIBTransaction;
  AClass: CgdcBase; const ASubType: TgdcSubType; const AnID: Integer): CgdcBase;
var
  Obj: TgdcBase;
begin
  Result := nil;
  Obj := nil;

  try
    while (Obj = nil) and (AClass <> nil) and (AClass <> TgdcBase) do
    begin
      try
        Obj := AClass.CreateSingularByID(nil,
          ADatabase, ATransaction,
          AnID, ASubType);
      except
        on EgdcIDNotFound do
        begin
          AClass := CgdcBase(AClass.ClassParent);
        end else
          raise;
      end;
    end;

    if Obj <> nil then
    begin
      { TODO : а сабтайп?? }
      Result := Obj.GetCurrRecordClass.gdClass;
    end;
  finally
    Obj.Free;
  end;
end;

function GetBaseClassForRelation(const ARelationName: String): TgdcFullClass;
var
  I: Integer;
  C: CgdcBase;
  R: TatRelation;
  L: TObjectList;
  ibsql: TIBSQL;
  S: String;
  Ind: Integer;
  BaseClassName, BaseSubType: String;
  DidActivate: Boolean;
begin
  Assert(ARelationName > '');
  Assert(atDatabase <> nil);

  if not Assigned(gdcClassList) then
    raise Exception.Create(cgdClassListIsNotAssigned);

  if not Assigned(CacheBaseClassForRel) then
  begin
    CacheBaseClassForRel := TStringList.Create;
    CacheBaseClassForRel.Sorted := True;
  end;

  Ind := CacheBaseClassForRel.IndexOfName(UpperCase(ARelationName));
  if Ind > -1 then
  begin
    S := CacheBaseClassForRel.Values[ARelationName];
    BaseClassName := Copy(S, 1, AnsiPos('(', S) - 1);
    BaseSubType := Copy(S, AnsiPos('(', S) + 1, Length(S) - AnsiPos('(', S) - 1);
    Result.gdClass := CgdcBase(GetClass(BaseClassName));
    Result.SubType := BaseSubType;
  end
  else
  begin
    if StrIPos(UserPrefix, ARelationName) = 1 then
    begin
      R := atDatabase.Relations.ByRelationName(ARelationName);
      if (R <> nil)
        and (R.PrimaryKey <> nil)
        and (R.PrimaryKey.ConstraintFields.Count = 1)
        and (AnsiCompareText(R.PrimaryKey.ConstraintFields[0].FieldName, 'DOCUMENTKEY') = 0) then
      begin
        Result.gdClass := CgdcBase(GetClass('TgdcUserDocument'));
        Result.SubType := '';

        ibsql := TIBSQL.Create(nil);
        DidActivate := not gdcBaseManager.ReadTransaction.InTransaction;
        try
          if DidActivate then
            gdcBaseManager.ReadTransaction.StartTransaction;

          ibsql.Transaction := gdcBaseManager.ReadTransaction;
          ibsql.SQL.Text := ' SELECT dt.ruid, dt1.classname, dt.headerrelkey  ' +
          ' FROM gd_documenttype dt LEFT JOIN gd_documenttype dt1 ON dt.lb >= dt1.lb AND ' +
          ' dt.rb <= dt1.rb WHERE (dt.headerrelkey = :id or dt.linerelkey = :id) AND dt1.classname is NOT NULL ' ;
          ibsql.ParamByName('id').AsInteger := atDatabase.Relations.ByRelationName(ARelationName).ID;
          ibsql.ExecQuery;
          if ibsql.RecordCount > 0 then
          begin
            S := '';
            if AnsiCompareText(ibsql.FieldByName('classname').AsString, 'TgdcInvDocumentType') = 0 then
            begin
              if ibsql.FieldByName('headerrelkey').AsInteger =
                ibsql.ParamByName('id').AsInteger then
                S := 'TgdcInvDocument'
              else
                S := 'TgdcInvDocumentLine';
            end
            else
              if AnsiCompareText(ibsql.FieldByName('classname').AsString, 'TgdcInvPriceListType') = 0 then
              begin
                if ibsql.FieldByName('headerrelkey').AsInteger =
                  ibsql.ParamByName('id').AsInteger then
                  S := 'TgdcInvPriceList'
                else
                  S := 'TgdcInvPriceListLine';
              end
              else
                if AnsiCompareText(ibsql.FieldByName('classname').AsString, 'TgdcUserDocumentType') = 0 then
                begin
                  if ibsql.FieldByName('headerrelkey').AsInteger =
                    ibsql.ParamByName('id').AsInteger then
                    S := 'TgdcUserDocument'
                  else
                    S := 'TgdcUserDocumentLine';
                end;

            Result.SubType := ibsql.FieldByName('ruid').AsString;
            Result.gdClass := CgdcBase(GetClass(S));
          end;
        finally
          ibsql.Free;
          if DidActivate and gdcBaseManager.ReadTransaction.InTransaction then
            gdcBaseManager.ReadTransaction.Commit;
        end;
      end else
      begin
        if StrIPos('USR$CROSS', ARelationName) <> 1 then
        begin
          Result.gdClass := CgdcBase(GetClass('TgdcAttrUserDefined'));
          Result.SubType := ARelationName;
        end else
        begin
          Result.gdClass := nil;
          Result.SubType := '';
        end;
      end;
    end else
    begin
      Result.gdClass := nil;
      Result.SubType := '';

      with gdcClassList do
        for I := 0 to Count - 1 do
        begin
          if Items[I].InheritsFrom(TgdcBase) then
          begin
            C := CgdcBase(Items[I]);

            { TODO 1 -oденис -cсделать : Сделать обработку подтипа }
            if (AnsiCompareText(C.GetListTable(''), ARelationName) = 0) then
            begin
              if (Result.gdClass = nil) or Result.gdClass.InheritsFrom(C) then
                Result.gdClass := C;
            end;
          end;
        end;

      if Result.gdClass = nil then
      begin
        R := atDatabase.Relations.ByRelationName(ARelationName);
        if (R <> nil)
          and Assigned(R.PrimaryKey)
          and (R.PrimaryKey.ConstraintFields.Count = 1) then
        begin
          L := TObjectList.Create(False);
          try
            atDatabase.ForeignKeys.ConstraintsByRelation(ARelationName, L);
            for I := 0 to L.Count - 1 do
              with (L[I] as TatForeignKey) do
              begin
                if IsSimpleKey
                  and (ConstraintField = R.PrimaryKey.ConstraintFields[0]) then
                begin
                  Result := GetBaseClassForRelation(ReferencesRelation.RelationName);
                  if Result.gdClass <> nil then
                    break;
                end;
              end;
          finally
            L.Free;
          end;
        end;
      end;
    end;

    if Result.gdClass <> nil then
    begin
      CacheBaseClassForRel.Add(AnsiUpperCase(ARelationName + '=' + Result.gdClass.ClassName + '(' +
        Result.SubType + ')'));
    end;
  end;

end;

function GetDescendants(AnAncestor: CgdcBase; AClassList: TClassList; const OnlyDirect: Boolean = True): Boolean;
var
  I: Integer;
begin
  AClassList.Clear;
  if Assigned(gdcClassList) then
    for I := 0 to gdcClassList.Count - 1 do
      if (OnlyDirect and (gdcClassList[I].ClassParent = AnAncestor)) or
        ((not OnlyDirect) and (gdcClassList[I].InheritsFrom(AnAncestor))) then
        AClassList.Add(gdcClassList[I]);
  Result := AClassList.Count > 0;
end;

{ TODO :
код этой функции очень не оптимален
переписать! }
procedure MakeFieldList(Fields: String; List: TStrings);
{var
  Z: Integer;}
begin
  List.CommaText := StringReplace(Fields, ';', ',', [rfReplaceAll]);
{  List.Clear;

  repeat
    Z := Pos(';', Fields);

    if Z > 0 then
    begin
      List.Add(Copy(Fields, 1, Z - 1));
      Fields := Copy(Fields, Z + 1, Length(Fields));
    end else

    if Fields > '' then
      List.Add(Fields);
  until Z = 0;}
end;

function gdcFullClassToString(const AgdcFullClass: TgdcFullClass): String;
begin
  Result := '^' + AgdcFullClass.gdClass.ClassName + '^' + AgdcFullClass.SubType;
end;

function StringTogdcFullClass(const AString: String): TgdcFullClass;
var
  I: Integer;
begin
  Assert(AString > '');
  Assert(AString[1] = '^');

  I := Pos('^', Copy(AString, 2, 1024));
  Result.gdClass := CgdcBase(FindClass(Copy(AString, 2, I - 1)));
  Result.SubType := Copy(AString, I + 1, 1024);
end;

{ TgdcBase }
// Events

procedure TgdcBase.DoAfterDelete;
  //q: TIBSQL;
  //DidActivate: Boolean;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOAFTERDELETE', KEYDOAFTERDELETE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOAFTERDELETE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOAFTERDELETE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOAFTERDELETE', KEYDOAFTERDELETE, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  FDSModified := True;

  if FRefreshMaster and Assigned(FgdcDataLink) and Assigned(FgdcDataLink.DataSet)
    and (FgdcDataLink.DataSet.State = dsBrowse) then
  begin
    FgdcDataLink.DataSet.Refresh;
  end;  

  inherited;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTERDELETE', KEYDOAFTERDELETE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOAFTERDELETE', KEYDOAFTERDELETE);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoAfterInsert;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOAFTERINSERT', KEYDOAFTERINSERT)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOAFTERINSERT);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOAFTERINSERT]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOAFTERINSERT', KEYDOAFTERINSERT, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if not FDataTransfer then
    inherited;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTERINSERT', KEYDOAFTERINSERT)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOAFTERINSERT', KEYDOAFTERINSERT);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoAfterOpen;
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  I: Integer;
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOAFTEROPEN', KEYDOAFTEROPEN)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOAFTEROPEN);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOAFTEROPEN]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOAFTEROPEN', KEYDOAFTEROPEN, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  FID := -1;
  FObjectName := '';

  inherited DoAfterOpen;

  //Назначаем обработчики событий для полей-
  if Assigned(EventControl) then
    EventControl.SetChildEvents(Self);

  if not (csDesigning in ComponentState) then
    SetDefaultFields(False);

  //
  FAggregatesObsolete := True;

  //Если у нас есть таблица-множество,
  //то оставим возможными для редактирования только поля таблицы-множества
  if FSetTable > '' then
  begin
    for I := 0 to Fields.Count - 1 do
      if AnsiPos(cstSetPrefix, Fields[I].FieldName) = 1 then
        Fields[I].ReadOnly := False
      else
        Fields[I].ReadOnly := True;
    FieldByName(GetListField(SubType)).ReadOnly := False;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTEROPEN', KEYDOAFTEROPEN)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOAFTEROPEN', KEYDOAFTEROPEN);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoAfterPost;
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  FM, FD: TField;
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOAFTERPOST', KEYDOAFTERPOST)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOAFTERPOST);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOAFTERPOST]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOAFTERPOST', KEYDOAFTERPOST, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if FDataTransfer then
    exit;

  inherited;

  // проблема:
  // если открывается пустой датасет, для которого
  // устанавливается подмножество ПоИдентификатору
  // и в него добавляется запись, то, после закрытия-открытия,
  // эта запись не будет видна, поскольку не инициализируется
  // параметр ИД (селект СКЛ имеет вид: SELECT * FROM ... WHERE id=:ID).
  // мы добавили инициализацию этого параметра в АфтерПост
  if HasSubSet('ByID') then
  begin
    ParamByName(GetKeyField(SubType)).AsInteger := ID;
  end else
  if HasSubSet('ByName') then
  begin
    ParamByName(GetListField(SubType)).AsString := ObjectName;
  end;

  //
  if FRefreshMaster and Assigned(FgdcDataLink) and Assigned(FgdcDataLink.DataSet)
    and (FgdcDataLink.DataSet.State = dsBrowse) then
  begin
    FgdcDataLink.DataSet.Refresh;
  end;  

  //
  if Assigned(MasterSource) and (MasterSource.DataSet is TgdcBase)
    and ((sDialog in TgdcBase(MasterSource.DataSet).BaseState)
      or (sDialog in FBaseState)) then
  begin
    FM := TgdcBase(MasterSource.DataSet).FindField(MasterField);
    FD := FindField(DetailField);
    if (FM <> nil) and (FD <> nil) then
    begin
      if FM.AsString <> FD.AsString then
      begin
        MessageBox(ParentHandle,
          PChar(Format('Введенный объект "%s"'#13#10'не соответствует главному объекту "%s"'#13#10#13#10,
            [ObjectName, TgdcBase(MasterSource.DataSet).ObjectName]) +
          'После обновления данных он может быть не виден в списке.'),
          'Внимание',
          MB_OK or MB_ICONINFORMATION);
      end;
    end;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTERPOST', KEYDOAFTERPOST)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOAFTERPOST', KEYDOAFTERPOST);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoBeforeClose;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFORECLOSE', KEYDOBEFORECLOSE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOBEFORECLOSE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOBEFORECLOSE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOBEFORECLOSE', KEYDOBEFORECLOSE, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  inherited;

  if Assigned(EventControl) then
    EventControl.ResetChildEvents(Self);

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFORECLOSE', KEYDOBEFORECLOSE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOBEFORECLOSE', KEYDOBEFORECLOSE);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoBeforeDelete;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFOREDELETE', KEYDOBEFOREDELETE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOBEFOREDELETE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOBEFOREDELETE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOBEFOREDELETE', KEYDOBEFOREDELETE, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if (not CanDelete) and (not IBLogin.IsUserAdmin) then
    raise EgdcUserHaventRights.CreateFmt(strHaventRights, [strDelete]);

  inherited;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFOREDELETE', KEYDOBEFOREDELETE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOBEFOREDELETE', KEYDOBEFOREDELETE);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoBeforeEdit;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFOREEDIT', KEYDOBEFOREEDIT)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOBEFOREEDIT);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOBEFOREEDIT]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOBEFOREEDIT', KEYDOBEFOREEDIT, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  inherited;
  FOldValues.Clear;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFOREEDIT', KEYDOBEFOREEDIT)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOBEFOREEDIT', KEYDOBEFOREEDIT);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoBeforeInsert;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFOREINSERT', KEYDOBEFOREINSERT)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOBEFOREINSERT);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOBEFOREINSERT]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOBEFOREINSERT', KEYDOBEFOREINSERT, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if not FDataTransfer then
  begin
    if FSetTable > '' then
      Abort;

    if (not CanCreate) and (not IBLogin.IsIBUserAdmin) then
      raise EgdcUserHaventRights.CreateFmt(strHaventRights, [strCreate]);

    inherited;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFOREINSERT', KEYDOBEFOREINSERT)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOBEFOREINSERT', KEYDOBEFOREINSERT);
  {M}  end;
  {END MACRO}
end;

(*

  Перед сохранением записи синхронизируем значения дескрипторов
  безопасности. Распространим более сильные права на менее сильные.

*)
procedure TgdcBase.DoBeforePost;
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  F: TField;
  AFull, AChag, AView: Integer;
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFOREPOST', KEYDOBEFOREPOST)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOBEFOREPOST);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOBEFOREPOST]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOBEFOREPOST', KEYDOBEFOREPOST, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if FDataTransfer then
    exit;

  if (not CanEdit) and (not IBLogin.IsUserAdmin) then
    raise EgdcUserHaventRights.CreateFmt(strHaventRights, [strEdit]);

  if tiEditionInfo in gdcTableInfos then
  begin
    FieldByName('EDITORKEY').AsInteger := IBLogin.ContactKey;
    if not (sLoadFromStream in BaseState) then
      FieldByName('EDITIONDATE').AsDateTime := Now;
  end;

  // смысл использования sMultiple
  // в методе доБефореПост программист может
  // поставить присваивание значений нескольких полей в
  // зависимости от значений других полей
  // для одной, конкретной записи это имеет смысл
  // но, когда идет редактирование нескольких одновременно
  // это нонсенс
  // возьмем к примеру редактирование поля таблицы:
  // в ДоБефореПост проверяется, если краткое наименование
  // пустое, то оно инициализируется полным наименованием
  // если у меня несколько записей которые я открыл
  // одновременно для редактирования (например, хочу их все скрыть)
  // то при сохранении вызовется доБефореПост (для первой записи!)
  // если мне не повезло и краткое наименование в этой записи
  // отсутствует, то оно заполнится полным наименованием из
  // этой же записи. Но! бизнес-объект запомнит эту операцию
  // (присваивание поля краткого наименования) и применит ко всем
  // остальным выбранным записям. Что приведет к тому, что поле краткое
  // наименование у них, в не зависимости от того: было оно заполнено
  // или нет, будет инициализировано кратким наименованием из первой записи
  //
  // боремся с этим мы следующим: при редактировании одновременно нескольких
  // записей в состоянии бизнес объекта (BaseState) устанавливается флаг
  // sMultiple. Разработчик, если у него в доБефореПосте сложилась
  // такая ситуация (идет присваивание одних полей в зависимости от
  // значений других) должен проверять на этот флаг и выполнять
  // присваивание только если флаг не установлен.

{ TODO : а если у главной таблицы нет дескрипторов, а у присоединенной есть? }
  if not (sMultiple in BaseState) then
  begin
    F := FindField('afull');

    if (F <> nil) then
    begin
      AFull := F.AsInteger or 1;
      if AFull <> F.AsInteger then
        F.AsInteger := AFull;
    end;

    if (F <> nil) and (FindField('achag') <> nil) then
    begin
      AChag := FieldByName('achag').AsInteger or F.AsInteger;
      if AChag <> FieldByName('achag').AsInteger then
        FieldByName('achag').AsInteger := AChag;
    end;

    if FindField('AChag') <> nil then
      F := FindField('AChag');

    if (F <> nil) and (FindField('AView') <> nil) then
    begin
      AView := FieldByName('AView').AsInteger or F.AsInteger;
      if AView <> FieldByName('AView').AsInteger then
        FieldByName('AView').AsInteger := AView;
    end;
  end;

  inherited DoBeforePost;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFOREPOST', KEYDOBEFOREPOST)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOBEFOREPOST', KEYDOBEFOREPOST);
  {M}  end;
  {END MACRO}
end;
(*
var
  F: TField;
  AFull, AChag, AView, I: Integer;
begin
  if FDataTransfer then
    exit;

  if tiEditionInfo in gdcTableInfos then
  begin
    FieldByName('EDITORKEY').AsInteger := IBLogin.ContactKey;
    FieldByName('EDITIONDATE').AsDateTime := Now;
  end;

{ TODO : а если у главной таблицы нет дескрипторов, а у присоединенной есть? }
  F := FindField('afull');

  if (F <> nil) then
  begin
    AFull := F.AsInteger or 1;
    if AFull <> F.AsInteger then
      F.AsInteger := AFull;
  end;

  if (F <> nil) and (FindField('achag') <> nil) then
  begin
    AChag := FieldByName('achag').AsInteger or F.AsInteger;
    if AChag <> FieldByName('achag').AsInteger then
      FieldByName('achag').AsInteger := AChag;
  end;

  if FindField('AChag') <> nil then
    F := FindField('AChag');

  if (F <> nil) and (FindField('AView') <> nil) then
  begin
    AView := FieldByName('AView').AsInteger or F.AsInteger;
    if AView <> FieldByName('AView').AsInteger then
      FieldByName('AView').AsInteger := AView;
  end;

  for I := 0 to FieldCount - 1 do
    ValidateField(Fields[I]);

  inherited DoBeforePost;
end;
*)
// End Event

function TgdcBase.AcceptClipboard(CD: PgdcClipboardData): Boolean;
var
  Bm: String;
  Obj: TgdcBase;
begin
  Result := False;

  if (CD.ClassName = Self.ClassName) and (CD.SubType = Self.SubType)
    and (CD.ObjectCount > 0) and (not CD.Cut) then
  begin
    Bm := Bookmark;
    if Locate('ID', CD.ObjectArr[0].ID, []) then
    begin
      Result := CopyDialog;
      if not Result then
        Bookmark := Bm;
    end else
    begin
      Obj := CgdcBase(FindClass(CD.ClassName)).CreateWithParams(Owner,
        Database,
        Transaction,
        SubType,
        'ByID',
        CD.ObjectArr[0].ID);
      try
        Obj.Open;
        if not Obj.EOF then
        begin
          Result := Obj.CopyDialog;
          if Result then
          begin
            Close;
            Open;
            Locate('ID', Obj.ID, []);
          end;
        end;
      finally
        Obj.Free;
      end;
    end;
  end;
end;

procedure TgdcBase.AfterConstruction;
begin
  inherited AfterConstruction;

  if gdcBaseManager <> nil then
  begin
    if Transaction = nil then
    begin
      FInternalTransaction := TIBTransaction.Create(Self);
      FInternalTransaction.Params.Text := 'read_committed'#13#10'rec_version'#13#10'nowait'#13#10;
      FInternalTransaction.Name := 'Internal';
      FInternalTransaction.AutoStopAction := saNone;
      Transaction := FInternalTransaction;
    end;

    if gdcBaseManager.ReadTransaction <> nil then
    begin
      ReadTransaction := gdcBaseManager.ReadTransaction;

// Проверка на то что Owner is TgdcBase добавлена потому, что
// когда идет FreeNotification, то он проверяет саму компоненту и все, которые
// к ней относятся и если там есть, кто-то кто отвечает условию, он  для него то же делает
// FreeNotification, однако он освобождается из списка, но начальная проверка его не знает,
// после чего происходит ошибка.

      if not (Owner is TgdcBase) then
        ReadTransaction.FreeNotification(Self);
    end;

    if Database = nil then
      Database := gdcBaseManager.Database;

    if Transaction.DefaultDatabase <> Database then
      Transaction.DefaultDatabase := Database;

    FFilter := TQueryFilterGDC.Create(Self);
    FFilter.OnFilterChanged := DoOnFilterChanged;
    FFilter.Name := 'flt_' + RemoveProhibitedSymbols(System.copy(ClassName, 2, 255));
    FFilter.Database := Database;
//    FFilter.IBDataSet := Self;
    QueryFiltered := False;
  end;
end;

procedure TgdcBase.AssignField(const AnID: Integer;
  const AFieldName: String; AValue: Variant);
var
  Q: TIBSQL;
  Obj: TgdcBase;
  C: TClass;
  DidActivate: Boolean;
begin
  if Active then
  begin
    C := GetCurrRecordClass.gdClass;
    Obj := CgdcBase(C).CreateWithID(Owner, Database, Transaction, AnID);
    try
      Obj.Assign(Self);
      Obj.Open;
      if Obj.RecordCount > 0 then
      begin
        Obj.Edit;
        if VarIsNull(AValue) then
          Obj.FieldByName(AFieldName).Clear
        else
          Obj.FieldByName(AFieldName).AsVariant := AValue;
        Obj.Post;
        { TODO : то есть мы не уверены активна тр или нет?? }
        if Transaction.InTransaction then
          Transaction.CommitRetaining;
      end;
    finally
      Obj.Free;
    end;
  end else
  begin
    DidActivate := False;
    Q := TIBSQL.Create(nil);
    try
      Q.Database := Database;
      Q.Transaction := Transaction;
      DidActivate := ActivateTransaction;
      Q.SQL.Text := Format('UPDATE %s SET %s=:V WHERE %s=%d', [GetListTable(SubType), AFieldName, GetKeyField(SubType), AnID]);
      Q.Prepare;
      if VarIsNull(AValue) then
        Q.ParamByName('V').Clear
      else
        Q.ParamByName('V').AsVariant := AValue;

      Q.ExecQuery;
    finally
      if DidActivate then
        Transaction.Commit;
      Q.Free;
    end;
  end;
end;

function TgdcBase.CanPasteFromClipboard: Boolean;
begin
  Result := Active
    and Clipboard.HasFormat(gdcClipboardFormat)
    and CanEdit;
end;

procedure TgdcBase.CloseOpen;
var
  OldID: TID;
begin
  { TODO : 
если делать дизэйбл контролс, то в гриде остается выделение
записей, если там был мульти селект }
  //DisableControls;
  try
    if Active and not IsEmpty then
      OldID := ID
    else
      OldID := -1;
    Close;
    Open;
    if OldID <> -1 then
      Locate(GetKeyField(SubType), OldID, []);
  finally
    //EnableControls;
  end;
end;

function TgdcBase.GetNotCopyField: String;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_GETNOTCOPYFIELD('TGDCBASE', 'GETNOTCOPYFIELD', KEYGETNOTCOPYFIELD)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYGETNOTCOPYFIELD);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYGETNOTCOPYFIELD]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'GETNOTCOPYFIELD', KEYGETNOTCOPYFIELD, Params, LResult) then
  {M}          begin
  {M}            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
  {M}              Result := String(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'GETNOTCOPYFIELD' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не строковый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}//          Result := Inherited GetNotCopyField;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  Result := GetKeyField(SubType);
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'GETNOTCOPYFIELD', KEYGETNOTCOPYFIELD)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'GETNOTCOPYFIELD', KEYGETNOTCOPYFIELD);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.TestCopyField(const FieldName: String): Boolean;
begin
  Result := StrIPos(FieldName + ',', GetNotCopyField + ',') = 0;
end;

function TgdcBase.Copy(const AFields: String; AValues: Variant;
  const ACopyDetail: Boolean = False; const APost: Boolean = True;
  const AnAppend: Boolean = False): Boolean;
var
  V: array of Variant;
  I: Integer;
  L: TList;
  C: TgdcFullClass;
  Obj: TgdcBase;
  F: TField;
begin
  CheckBrowseMode;

  C := GetCurrRecordClass;

  if (C.gdClass = Self.ClassType) and (C.SubType = Self.SubType) then
  begin

    // список значений полей должен быть обязательно массивом
    if (AFields > '') and (not VarIsArray(AValues)) then
      AValues := VarArrayOf([AValues]);

    // сохраним значения текущей записи
    SetLength(V, FieldCount);
    for I := 0 to FieldCount - 1 do
      V[I] := Fields[I].AsString;
      //V[I] := Fields[I].AsVariant;

    // добавим новую и скопируем в нее значения полей
    // исходной записи, кроме первичного ключа
    // и полей, для которых заданы другие значения
    L := TList.Create;
    try
      GetFieldList(L, AFields);
      if AnAppend then
        Append
      else
        Insert;
      try
        for I := 0 to FieldCount - 1 do
          if L.IndexOf(Fields[I]) >= 0 then
            Fields[I].AsVariant := AValues[L.IndexOf(Fields[I])]
          else
            if TestCopyField(Fields[I].FieldName) and (not Fields[I].ReadOnly) then
              Fields[I].AsString := V[I];
              //Fields[I].AsVariant := V[I];
        if APost then
          Post;
      except
        Cancel;
        raise;
      end;
    finally
      L.Free;
    end;

    Result := True;
  end else
  begin
    Obj := C.gdClass.CreateWithParams(Owner,
      Database,
      Transaction,
      C.SubType,
      'ByID',
      ID);
    try
      CopyEventHandlers(Obj, Self);
      try
        Obj.Open;
        Result := Obj.Copy(AFields, AValues, ACopyDetail, True);
        if Result and Active and Obj.Active then
        begin
          FDataTransfer := True;
          ResetEventHandlers(Self);
          try
            if AnAppend then
              Append
            else
              Insert;
            for I := 0 to FieldCount - 1 do
            begin
              F := Obj.FindField(Fields[I].FieldName);
              if Assigned(F) then
                Fields[I].Assign(F);
            end;
            Post;
          finally
            FDataTransfer := False;
          end;
        end;
      finally
        CopyEventHandlers(Self, Obj);
      end;
    finally
      Obj.Free;
    end;
  end;
end;

procedure TgdcBase.CopyDetailTable(const AMasterTableName: String;
  const AnOldID, ANewID: Integer);
var
  q: TIBSQL;
  ibtS: TIBQuery;
  ibtD: TIBTable;
  I: Integer;
  DidActivate: Boolean;
begin
  DidActivate := False;
  q := TIBSQL.Create(Self);
  ibtS := TIBQuery.Create(Self);
  ibtD := TIBTable.Create(Self);
  try
    q.Database := Database;
    q.Transaction := Transaction;

    ibtS.Database := Database;
    ibtS.Transaction := Transaction;
    ibtS.Unidirectional := True;

    ibtD.Database := Database;
    ibtD.Transaction := Transaction;
    ibtD.Unidirectional := True;

    DidActivate := ActivateTransaction;

    // обрабатываем только случай с целочисленным ключем
    // получаем список ссылающихся таблиц, имя поля
    // фореин кея (поля-ссылки на главную таблицу), имя
    // поля первичного ключа в главной таблице
    q.SQL.Text :=
      'SELECT rc2.rdb$relation_name, is1.rdb$field_name, is2.rdb$field_name ' +
      'FROM ' +
      '  rdb$relation_constraints rc ' +
      '  JOIN rdb$ref_constraints rf ' +
      '    ON rc.rdb$constraint_name = rf.rdb$const_name_uq ' +
      '    AND rc.rdb$relation_name = :RN AND rc.rdb$constraint_type = ''PRIMARY KEY'' ' +
      '  JOIN rdb$relation_constraints rc2 ' +
      '    ON rc2.rdb$constraint_name = rf.rdb$constraint_name ' +
      '    AND rc2.rdb$constraint_type = ''FOREIGN KEY'' ' +
      '  JOIN rdb$indices ri ' +
      '    ON ri.rdb$index_name = rc2.rdb$index_name ' +
      '  JOIN rdb$index_segments is1 ' +
      '    ON is1.rdb$index_name = ri.rdb$index_name ' +
      '  JOIN rdb$indices ri2 ' +
      '    ON ri2.rdb$index_name = rc.rdb$index_name ' +
      '  JOIN rdb$index_segments is2 ' +
      '    ON is2.rdb$index_name = ri2.rdb$index_name ' +
      ' ';
    q.Prepare;
    q.ParamByName('RN').AsString := GetListTable(SubType);
    q.ExecQuery;

    while not q.EOF do
    begin
{      ibtS.TableName := q.Fields[0].AsString;
      ibtS.Filter := Format('%s=%d', [q.Fields[1].AsString, AnOldID]);
      ibtS.Open;
      ibtS.Filtered := True;}
      ibtS.SQL.Text := Format('SELECT * FROM %s WHERE %s=%d',
        [q.Fields[0].AsString, q.Fields[1].AsString, AnOldID]);
      ibtS.Open;

      ibtD.TableName := q.Fields[0].AsString;
      ibtD.Open;

      ibtS.First;
      while not ibtS.EOF do
      begin
        ibtD.Insert;

        for I := 0 to ibtS.FieldCount - 1 do
          if AnsiCompareText(ibtS.Fields[I].FieldName, Trim(q.Fields[1].AsString)) = 0 then
            ibtD.FieldByName(ibtS.Fields[I].FieldName).AsInteger := ANewID
          else if AnsiCompareText(ibtS.Fields[I].FieldName, Trim(q.Fields[2].AsString)) = 0 then
            ibtD.FieldByName(ibtS.Fields[I].FieldName).Clear
          else if (not ((db.faReadOnly in ibtD.FieldDefList[I].Attributes) and (ibtD.FieldDefList[I].InternalCalcField = True))) then
            ibtD.FieldByName(ibtS.Fields[I].FieldName).Assign(ibtS.Fields[I]);

        ibtD.Post;
        ibtS.Next;
      end;
      ibtS.Close;
      ibtD.Close;

      q.Next;
    end;

    q.Close;
  finally
    if DidActivate then
      Transaction.Commit;

    q.Free;
    ibtS.Free;
    ibtD.Free;
  end;
end;

function TgdcBase.CopyDialog: Boolean;
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  Bm: String;
  C: TgdcFullClass;
  Obj: TgdcBase;
  I: Integer;
  F: TField;
begin
  {@UNFOLD MACRO INH_ORIG_COPYDIALOG('TGDCBASE', 'COPYDIALOG', KEYCOPYDIALOG)}
  {M}//  Result := False;
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYCOPYDIALOG);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYCOPYDIALOG]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'COPYDIALOG', KEYCOPYDIALOG, Params, LResult) then
  {M}          begin
  {M}            Result := False;
  {M}            if VarType(LResult) = varBoolean then
  {M}              Result := Boolean(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'COPYDIALOG' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не булевый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Result := False;//Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  C := GetCurrRecordClass;
  if (C.gdClass = Self.ClassType) and (C.SubType = Self.SubType) then
  begin
    Bm := Bookmark;
    Result := Copy('', Null, True, False) and EditDialog;
    if not Result then
      if BookmarkValid(Pointer(Bm)) and (Bookmark <> Bm) then
        Bookmark := Bm;
  end else
  begin
    Obj := C.gdClass.CreateWithParams(Owner,
      Database,
      Transaction,
      C.SubType,
      'ByID',
      Self.ID);
    try
      CopyEventHandlers(Obj, Self);
      try
        Obj.Open;
        Result := Obj.CopyDialog;
        if Result and Active and Obj.Active then
        begin
          FDataTransfer := True;
          ResetEventHandlers(Self);
          try
            Insert;
            try
              for I := 0 to FieldCount - 1 do
              begin
                F := Obj.FindField(Fields[I].FieldName);
                if Assigned(F) then
                  Fields[I].Assign(F);
              end;
              Post;
            except
              Cancel;
              raise;
            end;
          finally
            FDataTransfer := False;
          end;
        end;

      finally
        CopyEventHandlers(Self, Obj);
      end;
    finally
      Obj.Free;
    end;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'COPYDIALOG', KEYCOPYDIALOG)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'COPYDIALOG', KEYCOPYDIALOG);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.CopyToClipboard(BL: TBookmarkList; const ACut: Boolean = False);
var
  H: THandle;
  P: PgdcClipboardData;
  I, IC: Integer;
  Accept: Boolean;
  S: String;
  //PCh: PChar;
  C: TgdcFullClass;
begin
  if (not Active) or IsEmpty then
    raise EgdcException.Create('Dataset is not active or empty');

  S := '';

  if BL <> nil then
    BL.Refresh;
    
  if (BL = nil) or (BL.Count = 0) then IC := 1 else
    IC := BL.Count;
  H := GlobalAlloc(GMEM_MOVEABLE or GMEM_DDESHARE,
    SizeOf(TgdcClipboardData) -
    SizeOf(TObjectArr) + IC * SizeOf(TObjectData));
  if H <> 0 then
  begin
    P := GlobalLock(H);
    if P <> nil then
    begin
      P^.Signature := gdcCurrentClipboardSignature;
      P^.Version := gdcCurrentClipboardVersion;
      StrPCopy(P^.ClassName, System.Copy(Self.ClassName, 1, 63));
      StrPCopy(P^.SubType, System.Copy(Self.SubType, 1, 63));
      P^.Obj := Self;
      P^.Cut := ACut;
      P^.ObjectCount := IC;
      if (BL = nil) or (BL.Count = 0) then
      begin
        P^.ObjectArr[0].ID := Self.ID;
        StrPLCopy(P^.ObjectArr[0].ObjectName, Self.ObjectName, 63);
        C := GetCurrRecordClass;
        StrPLCopy(P^.ObjectArr[0].ClassName, C.gdClass.ClassName, 63);
        StrPLCopy(P^.ObjectArr[0].SubType, C.SubType, 63);

        S := Self.ObjectName;
      end else
      begin
        try
          for I := 0 to BL.Count - 1 do
          begin
            FPeekBuffer := FBufferCache + PInteger(BL[I])^ * _RecordBufferSize;

            if PRecordData(FPeekBuffer)^.rdUpdateStatus = usDeleted then
              continue;

            if Filtered and Assigned(OnFilterRecord) then
            begin
              Accept := True;
              OnFilterRecord(Self, Accept);
              if not Accept then
                continue;
            end;

            P^.ObjectArr[I].ID := FieldByName(GetKeyField(SubType)).AsInteger;
            StrPLCopy(P^.ObjectArr[I].ObjectName, Self.ObjectName, 63);
            C := GetCurrRecordClass;
            StrPLCopy(P^.ObjectArr[I].ClassName, C.gdClass.ClassName, 63);
            StrPLCopy(P^.ObjectArr[I].SubType, C.SubType, 63);

            S := S + Self.ObjectName + #13#10;
          end;
        finally
          FPeekBuffer := nil;
        end;
      end;
      GlobalUnlock(H);
      Clipboard.SetAsHandle(gdcClipboardFormat, H);

      {H := GlobalAlloc(GMEM_MOVEABLE or GMEM_DDESHARE, Length(S) + 1);
      if H <> 0 then
      begin
        PCh := GlobalLock(H);
        if PCh <> nil then
        begin
          S := S + #0;
          OemToChar(@S[1], PCh);
        end;
        GlobalUnlock(H);
        Clipboard.SetAsHandle(CF_TEXT, H);
      end;}
    end;
  end;
end;

constructor TgdcBase.Create(AnOwner: TComponent);
begin
  inherited Create(AnOwner);

  FVariables := nil;//TgdVariables.Create;
  FObjects := nil;//TgdObjects.Create;

  FIgnoreDataSet := TObjectList.Create(False);

  FUseScriptMethod := True;
  FIsNewRecord := False;
  FQueryFiltered := DefQueryFiltered;

  FAfterInitSQL := nil;
  FSQLInitialized := False;
  FGetDialogDefaultsFieldsCached := False;
  FSavedParams := TObjectList.Create(True);
  FRefreshMaster := False;
  FStreamSQLInitialised := False;

  FSubSets := TStringList.Create;
  FSubSets.Sorted := False;
  FSubSets.Duplicates := dupError;
  FSubSets.Add('All');

  FBaseState := [];
  FID := -1;
  FObjectName := '';
  FSQLSetup := nil;
  FExtraConditions := TStringList.Create;
  FExtraConditions.OnChange := DoAfterExtraChanged;
  FDSModified := False;
  FDlgStack := TObjectStack.Create;

  FFilter := nil;

  FBeforeShowDialog := nil;
  FAfterShowDialog := nil;

{ TODO :
этого не должно быть! кастом процесс динамическое значение
и не должно нигде хранится!

очевидно, схему придется изменить. Должны быть три переменных
процедурного типа. которые должны хранить адреса процедур для
кастом процессов. Тогда кастом процесса не понадобится.
}
  FCustomProcess := [];
  FgdcDataLink := TgdcDataLink.Create(Self);
  FDetailLinks := TObjectList.Create(False);

  if AnOwner is TWinControl then
  begin
    FParentForm := AnOwner as TWinControl;

    if FParentForm is Tgdc_frmG then
      Include(FBaseState, sView);
  end else
    FParentForm := nil;

  FSubType := '';

  gdcObjectList.Add(Self);

  FNameInScript := '';
  FEventList := TStringList.Create;
  LoadEventList;

  FSelectedID := TgdKeyArray.Create;

  FOldValues := TObjectList.Create(True);

  FgdcTableInfos := GetTableInfos(FSubType);

  FClassMethodAssoc := TgdKeyIntAndStrAssoc.Create;

  if Assigned(InheritedMethodInvoker) and (not UnMethodMacro) then
      InheritedMethodInvoker.RegisterMethodInvoker(Self, OnInvoker);

  FFieldsCallDoChange := TStringList.Create;
  FFieldsCallDoChange.Sorted := True;
  FFieldsCallDoChange.Duplicates := dupIgnore;

  CreateKeyList;
  FModifyFromStream := NeedModifyFromStream(SubType);

  FSetRefreshSQLOn := True;
end;

procedure TgdcBase.Prepare;
begin
  InternalPrepare;
end;

function TgdcBase.CreateDialog(const ADlgClassName: String = ''): Boolean;
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  DlgForm: TCreateableForm;
  InTransaction: Boolean;
  C: TClass;
  FormClass: String;
begin
  {@UNFOLD MACRO INH_ORIG_CREATEDIALOG('TGDCBASE', 'CREATEDIALOG', KEYCREATEDIALOG)}
  {M}  Result := False;
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYCREATEDIALOG);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYCREATEDIALOG]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), ADlgClassName]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'CREATEDIALOG', KEYCREATEDIALOG, Params, LResult) then
  {M}          begin
  {M}            Result := False;
  {M}            if VarType(LResult) = varBoolean then
  {M}              Result := Boolean(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'CREATEDIALOG' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не булевый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Result := False;//Inherited CreateDialog(ADlgClassName);
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if (not CanCreate) and (not IBLogin.IsUserAdmin) then
    raise EgdcUserHaventRights.CreateFmt(strHaventRights, [strCreate]);

  DlgForm := nil;

  if ADlgClassName <> '' then
  begin
    if Assigned(GlobalStorage) then
    begin
      FormClass := GlobalStorage.ReadString(st_ds_NewFormPath + '\' + ADlgClassName, st_ds_FormClass);
      if FormClass <> '' then
      begin
        C := GetClass(FormClass);
        if Assigned(C) then
        begin
          DlgForm := CCreateableForm(C).CreateUser(FParentForm, ADlgClassName)
        end;
      end;
    end;
  end;

  if DlgForm = nil then
    DlgForm := CreateDialogForm;

  if not Assigned(DlgForm) then
  begin
    Result := False;
    exit;
  end;

  { TODO : так может тут эксепшен кидать? }
  if not (DlgForm is Tgdc_dlgG) then
  begin
    DlgForm.Free;
    Result := False;
    exit;
  end;

  with DlgForm as Tgdc_dlgG do
  try
    InTransaction := Transaction.InTransaction;
    try
      FDlgStack.Push(DlgForm);

      if not Self.Active then
        Open;

      if Self.State <> dsInsert then
        Self.Insert;

      if sDialog in FBaseState then
      begin
        Include(FBaseState, sSubDialog);
      end else
        Include(FBaseState, sDialog);

      LoadDialogDefaults;

      Setup(Self);

      DoBeforeShowDialog(DlgForm);
      Result := (ShowModal = mrOk) or MultipleCreated;
      if IBLogin.Database.Connected then
      begin
        DoAfterShowDialog(DlgForm, Result);

        if ModalResult = mrOk then
          SaveDialogDefaults;

        if not (sSubDialog in FBaseState) then
        begin
          if Self.State in dsEditModes then
            if ModalResult = mrOk then
              Self.Post
            else
              Self.Cancel;

          if (not InTransaction) and Transaction.InTransaction then
          begin
            if Result then
              Transaction.Commit
            else
              Transaction.Rollback;

            {$IFDEF DEBUG}
            OutputDebugString('Окно не закрыло транзакцию');
            {$ENDIF}
          end;

          if ModalResult <> mrOk then
            if (CustomProcess * [cpInsert, cpModify]) <> [] then
              Self.Refresh;
        end;
      end;
    except
      if Self.State in dsEditModes then
        Self.Cancel;

      if Transaction.InTransaction then
      begin
        if InTransaction then
          Transaction.RollbackRetaining
        else
          Transaction.Rollback;
      end;

      raise;
    end;
  finally
    if sSubDialog in FBaseState then
    begin
      Exclude(FBaseState, sSubDialog);
    end else
      Exclude(FBaseState, sDialog);

    FDlgStack.Pop;

    Free;

    if not IBLogin.Database.Connected then
      IBLogin.ConnectionLostMessage;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'CREATEDIALOG', KEYCREATEDIALOG)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'CREATEDIALOG', KEYCREATEDIALOG);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.CreateDialogForm: TCreateableForm;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_FUNCCREATEDIALOGFORM('TGDCBASE', 'CREATEDIALOGFORM', KEYCREATEDIALOGFORM)}
  {M}  try
  {M}    Result := nil;
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYCREATEDIALOGFORM);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYCREATEDIALOGFORM]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'CREATEDIALOGFORM', KEYCREATEDIALOGFORM, Params, LResult) then
  {M}          begin
  {M}            Result := nil;
  {M}            if VarType(LResult) <> varDispatch then
  {M}              raise Exception.Create('Скрипт-функция: ' + Self.ClassName +
  {M}                TgdcBase(Self).SubType + 'CREATEDIALOGFORM' + #13#10 + 'Для метода ''' +
  {M}                'CREATEDIALOGFORM' + ' ''' + 'класса ' + Self.ClassName +
  {M}                TgdcBase(Self).SubType + #10#13 + 'Из макроса возвращен не объект.')
  {M}            else
  {M}              if IDispatch(LResult) = nil then
  {M}                raise Exception.Create('Скрипт-функция: ' + Self.ClassName +
  {M}                  TgdcBase(Self).SubType + 'CREATEDIALOGFORM' + #13#10 + 'Для метода ''' +
  {M}                  'CREATEDIALOGFORM' + ' ''' + 'класса ' + Self.ClassName +
  {M}                  TgdcBase(Self).SubType + #10#13 + 'Из макроса возвращен пустой (null) объект.');
  {M}            Result := GetInterfaceToObject(LResult) as TCreateableForm;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Result := nil;//Inherited CreateDialogForm;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  Result := CCreateableForm(FindClass('Tgdc_dlgObjectProperties')).Create(FParentForm);

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'CREATEDIALOGFORM', KEYCREATEDIALOGFORM)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'CREATEDIALOGFORM', KEYCREATEDIALOGFORM);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.CreateNext;
begin
  CheckActive;
  if State in dsEditModes then
    Post;
  if [sDialog, sSubDialog] * BaseState = [sDialog] then
  begin
    SaveDialogDefaults;
    Insert;
    LoadDialogDefaults;
  end else
    Insert;
end;

class function TgdcBase.CreateSingularByID(AnOwner: TComponent;
  ADatabase: TIBDatabase; ATransaction: TIBTransaction;
  const AnID: TID; const ASubType: String = ''): TgdcBase;
begin
  Result := Self.CreateWithID(AnOwner, ADatabase, ATransaction, AnID, ASubType);
  Result.Open;
  Result.Next;
  if Result.RecordCount <> 1 then
  begin
    Result.Free;
    raise EgdcIDNotFound.Create(Self.ClassName + ': ID not found (' + IntToStr(AnID) + ')');
  end else
    Result.First;
end;

constructor TgdcBase.CreateWithID;
begin
  CreateWithParams(AnOwner,
    ADatabase,
    ATransaction,
    ASubType,
    'ByID',
    AnID);
end;

constructor TgdcBase.CreateWithParams(AnOwner: TComponent;
  ADatabase: TIBDatabase;
  ATransaction: TIBTransaction;
  const ASubType: TgdcSubType = '';
  const ASubSet: TgdcSubSet = 'All';
  const AnID: Integer = -1);
begin
  CreateSubType(AnOwner, ASubType, ASubSet);
  inherited Database := ADatabase;
  inherited Transaction := ATransaction;
  if (SubSet = 'ByID') and (AnID <> -1) then
  begin
    UniDirectional := True;
    FID := AnID;
  end;
end;

procedure TgdcBase.CustomExecQuery(const ASQL: String; Buff: Pointer);
var
  S: String;
  DidActivate: Boolean;
  FN: String;
  F: TField;
  Parser: TsqlParser;
  I: Integer;
begin
  if not Assigned(FExecQuery) then
    FExecQuery := TIBSQL.Create(nil);

  if FExecQuery.Transaction <> Transaction then
    FExecQuery.Transaction := Transaction;

  if FExecQuery.Database <> Database then
    FExecQuery.Database := Database;

  with TatSQLSetup.Create(nil) do
  try
    S := PrepareSQL(ASQL, Self.ClassName + '(' + Self.SubType + ')');
    if FExecQuery.SQL.Text <> S then
      FExecQuery.SQL.Text := S;
  finally
    Free;
  end;

  DidActivate := False;
  try
    DidActivate := ActivateTransaction;

    FExecQuery.Prepare;
    SetInternalSQLParams(FExecQuery, Buff);
    try
      FExecQuery.ExecQuery;
    except
      on E: EIBInterbaseError do
      begin
        if (E.IBErrorCode = 335544347) and (sDialog in FBaseState) then
        begin
          Parser := TsqlParser.Create(FExecQuery.SQL.Text);
          try
            Parser.Parse;
            if (Parser.Statements.Count = 1) and (Parser.Statements[0] is TsqlInsert) then
            begin
              with TsqlInsert(Parser.Statements[0]) do
              begin
                FN := '';
                for I := 0 to Fields.Count - 1 do
                begin
                  if StrIPos(TsqlField(Fields[I]).FieldName, E.Message) > 0 then
                  begin
                    if Length(TsqlField(Fields[I]).FieldName) > Length(FN) then
                      FN := TsqlField(Fields[I]).FieldName;
                  end;
                end;
                if FN > '' then
                begin
                  F := FindField(Table.TableName, FN);
                  if F <> nil then
                  begin
                    F.FocusControl;
                    raise EIBInterbaseError.Create(E.SQLCode, E.IBErrorCode,
                      'Необходимо заполнить поле "' + F.DisplayName + '"');
                  end;
                end;
              end;
            end;
          finally
            Parser.Free;
          end;
          raise;
        end else
          raise;
      end;
    end;
  finally
    if DidActivate then
      Transaction.Commit;
  end;
end;

function TgdcBase.DeleteMultiple(BL: TBookmarkList): Boolean;
var
  I: Integer;
begin
  Result := False;

  if Assigned(BL) then
    BL.Refresh;

  if (BL = nil) or (BL.Count <= 1) then
  begin
    if (RecordCount > 0) and
       (
         (not (sView in BaseState)) or
         (MessageBox(ParentHandle, PChar(Format('Удалить выделенную запись "%s"?', [ObjectName])), 'Внимание!', MB_YESNO + MB_ICONQUESTION) = IDYES)
       ) then
    begin
      Result := DeleteRecord;
    end;
  end
  else
    if (not (sView in BaseState)) or (MessageBox(ParentHandle,
          PChar(Format('Выделено записей: %d'#13#10'Удалить?', [BL.Count])),
          'Внимание!',
          MB_YESNO + MB_ICONQUESTION) = IDYES) then
    begin
      DisableControls;
      try
        for I := BL.Count - 1 downto 0 do
        begin
          if BookmarkValid(Pointer(BL[I])) then
          begin
            Bookmark := BL[I];
            if DeleteRecord then
              Result := True;
          end;
        end;
      finally
        EnableControls;
      end;
    end;
end;

destructor TgdcBase.Destroy;
var
  Index: Integer;
begin
  FFieldsCallDoChange.Free;
  if Assigned(FInternalTransaction) then
    FreeAndNil(FInternalTransaction);
  if Assigned(FDetailLinks) then
    FreeAndNil(FDetailLinks);
  if (FgdcDataLink <> nil) and (FgdcDataLink.DataSet is TgdcBase) then
    (FgdcDataLink.DataSet as TgdcBase).RemoveDetailLink(Self);
  if Assigned(FgdcDataLink) then
    FreeAndNil(FgdcDataLink);
  gdcObjectList.Extract(Self);
  FEventList.Free;
//  FpmReport.Free;
  if Assigned(FFilter) then
    FreeAndNil(FFilter);
  //FIBSQL.Free;
  FOldValues.Free;
  FExecQuery.Free;
  FExtraConditions.Free;
  FSelectedID.Free;
  FSavedParams.Free;
  FreeAndNil(FSubSets);
  FIgnoreDataSet.Free;

  FreeAndNil(FSQLSetup);
  FDlgStack.Free;
  FSyncList.Free;

  if Assigned(InheritedMethodInvoker) then
      InheritedMethodInvoker.UnRegisterMethodInvoker(Self);

  for Index := 0 to FClassMethodAssoc.Count - 1 do
    if FClassMethodAssoc.IntByIndex[Index] <> 0 then
      TObject(FClassMethodAssoc.IntByIndex[Index]).Free;
  FClassMethodAssoc.Free;

  FVariables.Free;
  FObjects.Free;

  inherited Destroy;
end;

procedure TgdcBase.MakeReportMenu;
var
  MenuItem: TMenuItem;
  DidActivate: Boolean;
  ReportGroup: TscrReportGroup;
  SQL: TIBSQL;

  procedure FillMenu(const Parent: TObject);
  var
    I: Integer;
    M: TMenuItem;
    Index: Integer;
    AddCount: Integer;
  begin
    Assert((Parent is TMenuItem) or (Parent is TPopUpMenu));

    if (Parent is TMenuItem) then
    begin
      Index := (Parent as TMenuItem).Tag;
      (Parent as TMenuItem).Clear;
    end else
      Index := 0;

    AddCount := 0;
    if (ReportGroup.Count > 0) and (Index < ReportGroup.Count) then
    begin
      for I := Index to ReportGroup.Count - 1 do
      begin
        if ReportGroup.GroupItems[Index].Id = ReportGroup.GroupItems[I].Parent then
        begin
          M := TMenuItem.Create(Self);
          M.Tag := I;
//          M.Name := 'G' + IntToStr(ReportGroup.GroupItems[I].Id);
          M.Caption := ReportGroup.GroupItems[I].Name;
          if (Parent is TMenuItem) then
            (Parent as TMenuItem).Add(M)
          else
            (Parent as TPopUpMenu).Items.Add(M);
          FillMenu(M);
          Inc(AddCount);
        end;
      end;
      for I := 0 to ReportGroup.GroupItems[Index].ReportList.Count - 1 do
      begin
        M := TMenuItem.Create(Self);
        M.Tag := ReportGroup.GroupItems[Index].ReportList.Report[I].Id;
//        M.Name := 'M' + IntToStr(ReportGroup.GroupItems[Index].ReportList.Report[I].Id);
        M.Caption := ReportGroup.GroupItems[Index].ReportList.Report[I].Name;
        M.OnClick := DoOnReportClick;
        if (Parent is TMenuItem) then
          (Parent as TMenuItem).Add(M)
        else
          (Parent as TPopUpMenu).Items.Add(M);
        Inc(AddCount);
      end;
    end;
    if AddCount = 0 then
    begin
      M := TMenuItem.Create(Self);
      M.Name := 'N' + IntToStr(Index);
      M.Caption := 'Пусто';
      M.Enabled := False;
      if (Parent is TMenuItem) then
        (Parent as TMenuItem).Add(M)
      else
        (Parent as TPopUpMenu).Items.Add(M);
    end;
  end;

begin
//  if FpmReport <> nil then exit;
//При изменении отчетов, добавлении или удалении необходимо перечитывать меню
  if FpmReport <> nil then
  begin
    FpmReport.Free;
    FpmReport := nil;
  end;

  if not Assigned(FpmReport) then
    FpmReport := TPopupMenu.Create(Self);
  FpmReport.AutoLineReduction := Menus.maAutomatic;

  DidActivate := False;
//  IBSQL := TIBSQL.Create(Self);
  try
{    IBSQL.Database := DataBase;
    IBSQL.Transaction := ReadTransaction;
    DidActivate := ActivateReadTransaction;}

    {$IFDEF DEPARTMENT}
    if IBLogin.IsUserAdmin then
    begin
    {$ENDIF}
      MenuItem := TMenuItem.Create(FpmReport);
      MenuItem.Caption := cst_Reportregistrylist;
      MenuItem.OnClick := DoOnReportListClick;
      FpmReport.Items.Add(MenuItem);

    {$IFDEF DEPARTMENT}
    end;
    {$ENDIF}

    ReportGroup := TscrReportGroup.Create(FUseScriptMethod);
    try
      ReportGroup.Transaction := ReadTransaction;
      DidActivate := ActivateReadTransaction;

      SQL := TIBSQL.Create(nil);
      try
        SQL.Transaction := ReadTransaction;
        SQL.SQL.Text := 'SELECT * FROM evt_object WHERE Upper(objectname) = :objectname';
        if Owner is TCreateableForm then
          SQL.Params[0].AsString := UpperCase(TCreateableForm(Owner).InitialName)
        else
          SQL.Params[0].AsString := UpperCase(Owner.Name);
        SQL.ExecQuery;
        if not SQl.Eof then
          ReportGroup.Load(SQl.FieldByName('reportgroupkey').AsInteger);
      finally
        SQL.Free;
      end;

      if (ReportGroup.Count > 1) or ((ReportGroup.Count = 1) and (ReportGroup[0].ReportList.Count > 0)) then
      begin
        MenuItem := TMenuItem.Create(FpmReport);
        MenuItem.Caption := '-';
        FpmReport.Items.Add(MenuItem);

        FillMenu(FpmReport);
      end;

      ReportGroup.Load(GroupID);
      if (ReportGroup.Count > 1) or ((ReportGroup.Count = 1) and (ReportGroup[0].ReportList.Count > 0)) then
      begin
        MenuItem := TMenuItem.Create(FpmReport);
        MenuItem.Caption := '-';
        FpmReport.Items.Add(MenuItem);

        FillMenu(FpmReport);
      end;
    finally
      ReportGroup.Free;
    end;

  finally
    if DidActivate then
      DeactivateReadTransaction;
  end;
end;

procedure TgdcBase.DoBeforeOpen;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFOREOPEN', KEYDOBEFOREOPEN)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOBEFOREOPEN);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOBEFOREOPEN]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOBEFOREOPEN', KEYDOBEFOREOPEN, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if (not CanView) and (not IBLogin.IsUserAdmin) then
     raise EgdcUserHaventRights.CreateFmt(strHaventRights, [strView]);

  if not FSQLInitialized then
    InitSQL;

  if HasSubSet('ByID') and (FID > -1) then
    ParamByName(GetKeyField(SubType)).AsInteger := FID
  else if HasSubSet('ByName') and (FObjectName > '') then
    ParamByName(GetListField(SubType)).AsString := FObjectName;

  inherited DoBeforeOpen;

  {$IFDEF DEBUG}
  //OutputDebugString(PChar(Name + '.BeforeOpen: ' + FormatDateTime('hh:nn:ss.z', Now)));
  {$ENDIF}
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFOREOPEN', KEYDOBEFOREOPEN)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOBEFOREOPEN', KEYDOBEFOREOPEN);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoOnNewRecord;
begin

  if FDataTransfer then
    exit;
  FIsNewRecord := True;
  try
    _DoOnNewRecord;
  finally
    FIsNewRecord := False;
  end;

  inherited DoOnNewRecord;
end;

function TgdcBase.EditDialog(const ADlgClassName: String = ''): Boolean;
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  C: TClass;
  CFull: TgdcFullClass;
  Obj: TgdcBase;
  DlgForm: TCreateableForm;
  I: Integer;
  F: TField;
  InTransaction: Boolean;
  FormClass: String;
  //Buff: PChar;
  //BuffSize: Integer;
begin
  {@UNFOLD MACRO INH_ORIG_EDITDIALOG('TGDCBASE', 'EDITDIALOG', KEYEDITDIALOG)}
  {M}  Result := False;
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYEDITDIALOG);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYEDITDIALOG]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), ADlgClassName]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'EDITDIALOG', KEYEDITDIALOG, Params, LResult) then
  {M}          begin
  {M}            Result := False;
  {M}            if VarType(LResult) = varBoolean then
  {M}              Result := Boolean(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'EDITDIALOG' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не булевый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}          Exit;
  {M}    end;
  {END MACRO}

  if not Active then
    raise EgdcException.CreateObj('Dataset is not active.', Self);

  DlgForm := nil;

  CFull := GetCurrRecordClass;

  if (UpperCase(ADlgClassName) = 'TGDC_DLGOBJECTPROPERTIES')
    or (CFull.gdClass = Self.ClassType) then
  begin
    C := GetClass(ADlgClassName);

    if (C <> nil) and (C.InheritsFrom(TCreateableForm)) then
      DlgForm := CCreateableForm(C).Create(FParentForm)
//      DlgForm := CgdcCreateableForm(C).Create(FParentForm)
    else
    begin
      if (ADlgClassName > '') and Assigned(GlobalStorage) and (GlobalStorage.ValueExists(st_ds_NewFormPath + '\' + ADlgClassName, st_ds_FormClass)) then
      begin
        FormClass := GlobalStorage.ReadString(st_ds_NewFormPath + '\' + ADlgClassName, st_ds_FormClass);
        if FormClass <> '' then
        begin
          C := GetClass(FormClass);
          if Assigned(C) then
          begin
            DlgForm := CCreateableForm(C).CreateUser(FParentForm, ADlgClassName)
//            DlgForm := CgdcCreateableForm(C).CreateUser(FParentForm, ADlgClassName)
          end;
        end;
      end;
    end;

    if DlgForm = nil then
      DlgForm := CreateDialogForm;

    if Assigned(DlgForm) then
      with DlgForm do
    try
      InTransaction := Transaction.Active;
      try
        FDlgStack.Push(DlgForm);

        if CanModify then
          Self.Edit;

        if sDialog in FBaseState then
        begin
          Include(FBaseState, sSubDialog);
        end else
          Include(FBaseState, sDialog);

        Setup(Self);

        DoBeforeShowDialog(DlgForm);
        Result := ShowModal = mrOk;
        if IBLogin.Database.Connected then
        begin
          DoAfterShowDialog(DlgForm, Result);

          if not (sSubDialog in FBaseState) then
          begin
            if Self.State in dsEditModes then
              if Result then Self.Post else Self.Cancel;

            if (not InTransaction) and Transaction.InTransaction then
            begin
              if Result then
                Transaction.Commit
              else
                Transaction.Rollback;

              {$IFDEF DEBUG}
              OutputDebugString('Окно не закрыло транзакцию!');
              {$ENDIF}
            end;

          end else
          begin
            if Result then
              FDSModified := True;
          end;
        end;
      except
        if Self.State in dsEditModes then
          Self.Cancel;

        if Transaction.InTransaction then
        begin
          if InTransaction then
            Transaction.RollbackRetaining
          else
            Transaction.Rollback;
        end;

        raise;
      end;
    finally
      if sSubDialog in FBaseState then
      begin
        Exclude(FBaseState, sSubDialog);
      end else
        Exclude(FBaseState, sDialog);

      FDlgStack.Pop;

      Free;

      if not IBLogin.Database.Connected then
        IBLogin.ConnectionLostMessage
      else
      begin
        if (not Result) and (not (sDialog in FBaseState)) then
        begin
          for I := 0 to FDetailLinks.Count - 1 do
            if (FDetailLinks[I] <> nil) and (DetailLinks[I].Transaction <> DetailLinks[I].ReadTransaction)
            then
            begin
              DetailLinks[I].Close;
              DetailLinks[I].Open;
            end;
        end;
      end;
    end else
      Result := False;
  end else begin
    C := CFull.gdClass;

    Assert(Assigned(C), 'GetCurrRecordClass вернул nil класс.');

    Obj := CgdcBase(C).CreateWithID(Owner, Database, Transaction, ID, CFull.SubType);
    try
      Obj.SetBaseState(Self.BaseState);
      CopyEventHandlers(Obj, Self);
      try

        Obj.Open;
        Result := Obj.EditDialog(ADlgClassName);

        if Result and Active and Obj.Active then
        begin

          { TODO :
  тут проблема: запрос в компоненте может быть изменен
  например в фильтре пользователь создал свой запрос
  вытянув туда дополнительную колонку. в Обдж такой колонки
  не будет...

  получается что создавая объект копию надо как-то с ним
  синхронизировать запрос. }
          {Assert(_RecordBufferSize = Obj.RecordBufferSize);

          IBAlloc(Buff, 0, _RecordBufferSize);
          try
            Obj.ReadRecordCache(Obj._CurrentRecord, Buff, False);
            WriteRecordCache(_CurrentRecord, Buff);
            Resync([]);
          finally
            FreeMem(Buff, _RecordBufferSize);
          end;}

          {BuffSize := 0;
          FDataTransfer := True;
          try
            for I := 0 to FieldCount - 1 do
            begin
              F := Obj.FindField(Fields[I].FieldName);
              if Assigned(F) then
              begin
                if F.DataSize > BuffSize then
                begin
                  BuffSize := F.DataSize;
                  ReallocMem(Buff, BuffSize);
                end;
                if Obj.InternalGetFieldData(F, Buff) then
                  InternalSetFieldData(Fields[I], Buff);
              end;
            end;
          finally
            FDataTransfer := False;
            ReallocMem(Buff, 0);
          end;}

          FDataTransfer := True;
          try
            ResetEventHandlers(Self);

            Edit;
            for I := 0 to FieldCount - 1 do
            begin
              F := Obj.FindField(Fields[I].FieldName);
              if Assigned(F) then
                Fields[I].Assign(F);
            end;
            Post;
          finally
            FDataTransfer := False;
          end;
        end;

      finally
        CopyEventHandlers(Self, Obj);
      end;

    finally
      Obj.Free;
    end;
  end;
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'EDITDIALOG', KEYEDITDIALOG)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'EDITDIALOG', KEYEDITDIALOG);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.EditMultiple(BL: TBookmarkList; const ADlgClassName: String = ''): Boolean;
var
  SL, SLChanged: TStringList;
  PS: PString;
  I, K, ErrCount: Integer;
  Bm: String;
  C: TClass;
begin
  if not ((sDialog in BaseState) or (Assigned(MasterSource) and
      (MasterSource.DataSet is TgdcBase) and (sDialog in (MasterSource.DataSet as TgdcBase).BaseState)))
  then
    Assert(not Transaction.Active, 'Transaction must be closed!');

  if Assigned(BL) then
    BL.Refresh;

  if (BL = nil) or (BL.Count <= 1) then
    Result := EditDialog(ADlgClassName)
  else begin
    if Assigned(UserStorage) and UserStorage.ReadBoolean('Options\Confirmations', 'EditMultiple', True) then
    begin
      if MessageBox(ParentHandle,
        PChar(Format('Выделено для редактирования записей: %d. Продолжить?', [BL.Count])),
        'Внимание',
        MB_YESNO or MB_ICONQUESTION) = IDNO then
      begin
        Result := False;
        exit;
      end;
    end;  

    SL := TStringList.Create;
    SLChanged := TStringList.Create;
    try
      Include(FBaseState, sMultiple);
      GetFieldNames(SL);
      for I := 0 to SL.Count - 1 do
      begin
        New(PS);
        PS^ := FieldByName(SL[I]).AsString;
        SL.Objects[I] := TObject(PS);
      end;
      C := GetCurrRecordClass.gdClass;
      Bm := Bookmark;
      Result := EditDialog(ADlgClassName);
      if Result then
      begin
        if Bm <> Bookmark then
        begin
          MessageBox(ParentHandle,
            'Была изменена только одна запись. '#13#10'Проверьте, не установлена ли у Вас автофильтрация. '#13#10'Если да, то отмените ее и повторите редактирование группы записей.',
            'Внимание',
            MB_OK or MB_ICONINFORMATION);
          exit;
        end;

        for I := 0 to SL.Count - 1 do
        begin
          if FieldByName(SL[I]).AsString <> PString(SL.Objects[I])^ then
          begin
            New(PS);
            PS^ := FieldByName(SL[I]).AsString;
            SLChanged.AddObject(SL[I], TObject(PS));
          end;
        end;
        if SLChanged.Count > 0 then
        begin
          DisableControls;
          ErrCount := 0;
          try
            for I := 0 to BL.Count - 1 do
            begin
              if (BL[I] = Bm) or not BookmarkValid(Pointer(BL[I])) then
                continue;
              Bookmark := BL[I];
              if GetCurrRecordClass.gdClass <> C then
                continue;
              try
                Edit;
                for K := 0 to SLChanged.Count - 1 do
                begin
                  FieldByName(SLChanged[K]).AsString := PString(SLChanged.Objects[K])^;
                end;
                Post;
              except
                Inc(ErrCount);
              end;
            end;
            if BookmarkValid(Pointer(Bm)) then
              Bookmark := Bm;
          finally
            EnableControls;
          end;

          if ErrCount > 0 then
          begin
            MessageBox(ParentHandle,
              PChar(Format('В процессе редактирования возникли ошибки в %d записи(ях).',
                [ErrCount])),
              'Внимание',
              MB_OK or MB_ICONHAND);
          end;
        end;
      end;
    finally
      Exclude(FBaseState, sMultiple);

      for I := 0 to SL.Count - 1 do
        if SL.Objects[I] <> nil then
        begin
          PS := PString(SL.Objects[I]);
          Dispose(PS);
        end;
      SL.Free;
      for I := 0 to SLChanged.Count - 1 do
        if SLChanged.Objects[I] <> nil then
        begin
          PS := PString(SLChanged.Objects[I]);
          Dispose(PS);
        end;
      SLChanged.Free;
    end;
  end;
end;

function TgdcBase.GetDeleteSQLText: String;
begin
  Result := Format('DELETE FROM %s WHERE %s=:OLD_%s ',
    [GetListTable(SubType), GetKeyField(SubType), GetKeyField(SubType)]);
end;

function TgdcBase.GetDetailClasses(Index: Integer): CgdcBase;
begin
  Assert((Index >= 0) and (Index < GetDetailClassesCount), 'Invalid index specified');
  Result := nil;
end;

function TgdcBase.GetDetailClassesCount: Integer;
begin
  Result := 0;
end;

function TgdcBase.GetDetailField: String;
begin
  if FgdcDataLink <> nil then
    Result := FgdcDataLink.DetailField
  else
    Result := '';  
end;

class function TgdcBase.GetDisplayName(const ASubType: TgdcSubType): String;
var
  R: TatRelation;
begin
  Result := '';

  if Assigned(atDatabase) then
  begin
    R := atDatabase.Relations.ByRelationName(GetListTable(ASubType));
    { TODO : может предусмотреть два метода: один возвращает длинное имя, второй короткое? }
    if R <> nil then
    begin
      if AnsiCompareText(R.LShortName, GetListTable(ASubType)) = 0 then
        Result := R.LName
      else
        Result := R.LShortName;
    end;
  end;

  //!!!
  if Result = '' then
    Result := ClassName + ASubType;
  //!!!
end;

function TgdcBase.GetGroupClause: String;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_GETGROUPCLAUSE('TGDCBASE', 'GETGROUPCLAUSE', KEYGETGROUPCLAUSE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYGETGROUPCLAUSE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYGETGROUPCLAUSE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'GETGROUPCLAUSE', KEYGETGROUPCLAUSE, Params, LResult) then
  {M}          begin
  {M}            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
  {M}              Result := String(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'GETGROUPCLAUSE' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не строковый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Result := '';//Inherited GetGroupClause;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  Result := ' ';
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'GETGROUPCLAUSE', KEYGETGROUPCLAUSE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'GETGROUPCLAUSE', KEYGETGROUPCLAUSE);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.GetID: Integer;
begin
  if Active then
    Result := FieldByName(GetKeyField(SubType)).AsInteger
  else
    Result := FID;
end;

function TgdcBase.GetInsertSQLText: String;
var
  I: Integer;
  F, V: String;
  SL: TStrings;
  LT, LF: String;
  IsUserTable: Boolean;
begin
  Assert(GetListTable(SubType) > '');

  LT := GetListTable(SubType);
  LF := GetListField(SubType);

  IsUserTable := Pos(UserPrefix, UpperCase(LT)) = 1;

  if Database = nil then
    Result := Format('INSERT INTO %s (%s) VALUES (:NEW_%s) ', [LT, LF, LF])
  else begin
    SL := TStringList.Create;
    try
      Database.GetFieldNames(LT, SL);
      Result := 'INSERT INTO ' + LT + ' (';
      F := '';
      V := '';
      for I := 0 to SL.Count - 1 do
        if (IsUserTable or (Pos(UserPrefix, UpperCase(SL[I])) <> 1)) and //атрибуты вставит наш анализатор кода
          (not Database.Has_Computed_BLR(UpperCase(LT), UpperCase(SL[I]))) and
          (UpperCase(SL[I]) <> 'LB') and
          (UpperCase(SL[I]) <> 'RB') then
        begin
          F := F + SL[I] + ',';
          V := V + ':NEW_' + SL[I] + ',';
        end;
      SetLength(F, Length(F) - 1);
      SetLength(V, Length(V) - 1);
      Result := Result + F + ') VALUES (' + V + ') ';

      FUpdateableFields := F;
    finally
      SL.Free;
    end;
  end;
end;

class function TgdcBase.GetKeyField(const ASubType: TgdcSubType): String;
begin
  Result := 'ID';
end;

function TgdcBase.GetMasterField: String;
begin
  if FgdcDataLink <> nil then
    Result := FgdcDataLink.MasterField
  else
    Result := '';  
end;

function TgdcBase.GetMasterSource: TDataSource;
begin
  if FgdcDataLink <> nil then
    Result := FgdcDataLink.DataSource
  else
    Result := nil;
end;

function TgdcBase.GetModifySQLText: String;
var
  I: Integer;
  SL: TStrings;
  LT, KF, LF: String;
  IsUserTable: Boolean;
begin
  Assert(GetListTable(SubType) > '');

  LT := GetListTable(SubType);
  KF := GetKeyField(SubType);
  LF := GetListField(SubType);

  IsUserTable := Pos(UserPrefix, UpperCase(LT)) = 1;

  if (Database = nil) then
    Result := Format('UPDATE %s SET %s=:NEW_%s WHERE %s=:OLD_%s ',
      [LT, LF, LF, KF, KF])
  else begin
    SL := TStringList.Create;
    try
      Database.GetFieldNames(LT, SL);
      if SL.Count < 2 then
        Result := Format('UPDATE %s SET %s=:NEW_%s WHERE %s=:OLD_%s ',
          [LT, LF, LF, KF, KF])
      else begin
        Result := 'UPDATE ' + LT + ' SET ';
        for I := 0 to SL.Count - 1 do
          if (AnsiCompareText(SL[I], KF) <> 0) and
             (IsUserTable or (Pos(UserPrefix, UpperCase(SL[I])) <> 1)) and
             (not Database.Has_Computed_BLR(UpperCase(LT), UpperCase(SL[I]))) and
             (UpperCase(SL[I]) <> 'LB') and
             (UpperCase(SL[I]) <> 'RB') then
            Result := Result + SL[I] + '=:NEW_' + SL[I] + ',';
        SetLength(Result, Length(Result) - 1);
        Result := Result + ' WHERE ' + KF + '=:OLD_' + KF + ' ';
      end;
    finally
      SL.Free;
    end;
  end;
end;

function TgdcBase.GetOrderClause: String;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_GETORDERCLAUSE('TGDCBASE', 'GETORDERCLAUSE', KEYGETORDERCLAUSE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYGETORDERCLAUSE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYGETORDERCLAUSE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'GETORDERCLAUSE', KEYGETORDERCLAUSE, Params, LResult) then
  {M}          begin
  {M}            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
  {M}              Result := String(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'GETORDERCLAUSE' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не строковый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Result := '';//Inherited GetOrderClause;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  Result := ' ';
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'GETORDERCLAUSE', KEYGETORDERCLAUSE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'GETORDERCLAUSE', KEYGETORDERCLAUSE);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.GetRefreshSQLText: String;
  function GetWhereClauseForSet: String;
  var
    I: Integer;
    KFL: TStringList;
  begin
    Result := '';

    //проверяем есть ли у нас таблица-множество
    if (FSetTable = '') or (atDatabase = nil) then
      Exit;

{    Result := cstSetAlias + '.' + FSetItemField + ' = :NEW_' +
      cstSetPrefix + FSetItemField;}

    { TODO :
если пользоваться кодом приведенным ниже, то
продублируется условие связки множества с мастер
записью. один раз в джоине и второй раз в условии. }
   //А если не пользоваться приведенным ниже кодом, то мы можем не учесть ситуации,
   //когда праймари кей состоит из трех и более полей, например мастер-поле,
   //второе поле ссылка и дата, как в таблице gd_goodtax

    if Assigned(atDatabase.Relations.ByRelationName(FSetTable).PrimaryKey)
    then
    begin
      KFL := TStringList.Create;
      try
        with atDatabase.Relations.ByRelationName(FSetTable).PrimaryKey do
        for I := 0 to ConstraintFields.Count - 1 do
          KFL.Add(AnsiUpperCase(Trim(ConstraintFields[I].FieldName)));

        Result := '';
        for I := 0 to KFL.Count - 1 do
        begin
          if Result > '' then
            Result := Result + ' AND ';
          Result := Result + cstSetAlias + '.' + KFL[I] + ' = :NEW_' + cstSetPrefix + KFL[I];
        end;

      finally
        KFL.Free;
      end;
    end;

  end;
var
  SelectClause, FromClause: String;
begin
  SelectClause := GetSelectClause;
  if Assigned(FOnGetSelectClause) then
    FOnGetSelectClause(Self, SelectClause);

  FromClause := GetFromClause;
  if Assigned(FOnGetFromClause) then
    FOnGetFromClause(Self, FromClause);

  if FSetTable > '' then
  Result :=
    SelectClause + ' ' + GetSetTableSelect +
    FromClause + ' ' + GetSetTableJoin +
    Format('WHERE %s ', [GetWhereClauseForSet])
  else
    Result :=
      SelectClause + ' ' + FromClause + ' ' +
      Format('WHERE %s.%s = :NEW_%s ', [GetListTableAlias,
        GetKeyField(SubType), GetKeyField(SubType)]);
end;

class function TgdcBase.GetRestrictCondition(
  const ATableName, ASubType: String): String;
begin
  Result := '';
end;

function TgdcBase.GetSelectClause: String;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_GETSELECTCLAUSE('TGDCBASE', 'GETSELECTCLAUSE', KEYGETSELECTCLAUSE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYGETSELECTCLAUSE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYGETSELECTCLAUSE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'GETSELECTCLAUSE', KEYGETSELECTCLAUSE, Params, LResult) then
  {M}          begin
  {M}            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
  {M}              Result := String(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'GETSELECTCLAUSE' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не строковый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Result := '';//Inherited GetSelectClause;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  Result := Format('SELECT %s.* ', [GetListTableAlias]);
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'GETSELECTCLAUSE', KEYGETSELECTCLAUSE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'GETSELECTCLAUSE', KEYGETSELECTCLAUSE);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.GetSetTableSelect: String;
begin
  if FSetTable > '' then
    Result := Format(', %s.* ', [cstSetAlias])
  else
    Result := '';
end;

function TgdcBase.GetSetTableJoin: String;
var
  PK: TatPrimaryKey;
  R: TatRelation;
  I: Integer;
  OL: TObjectList;
  LinkTableList: TStrings;

begin
  Result := '';
  if (FSetTable > '') and (atDatabase <> nil) and (atDatabase.Relations <> nil) then
  begin
    R := atDatabase.Relations.ByRelationName(FSetTable);

    if R <> nil then
      PK := R.PrimaryKey
    else
      PK := nil;

    if (PK <> nil) and (PK.ConstraintFields.Count > 1) then
    begin
      FSetItemField := '';
      FSetMasterField := '';

      // теперь найдем все таблицы, первичный ключ которых одновременно
      // является ссылкой на нашу запись, т.е. таблицы связанные
      // жесткой связью один-к-одному с нашей таблицей
      // записи в таких таблицах, в совокупности с записью в главной
      // таблице, представляют данные одного объекта
      // пример: gd_contact -- gd_company -- gd_companycode
      LinkTableList := TStringList.Create;
      try
        OL := TObjectList.Create(False);
        try
          atDatabase.ForeignKeys.ConstraintsByReferencedRelation(
            GetListTable(SubType), OL);
          for I := 0 to OL.Count - 1 do
            with OL[I] as TatForeignKey do
          begin
            if IsSimpleKey
              and (Relation.PrimaryKey <> nil)
              and (Relation.PrimaryKey.ConstraintFields.Count = 1)
              and (ConstraintField = Relation.PrimaryKey.ConstraintFields[0]) then
            begin
              //Сохраним только те таблицы, которые ссылаются на главную таблицу 1:1
              LinkTableList.Add(AnsiUpperCase(Trim(Relation.RelationName)));
            end;
          end;
        finally
          OL.Free;
        end;

        //Добавим в список и главную таблицу объекта
        LinkTableList.Add(AnsiUpperCase(GetListTable(SubType)));
        (LinkTableList as TStringList).Sorted := True;

        for I := 0 to PK.ConstraintFields.Count - 1 do
        begin
          if PK.ConstraintFields[I].References = nil then
            continue;

          if (FSetMasterField = '')
          then
          begin
            FSetMasterField := PK.ConstraintFields[I].FieldName;
          end else

          if (FSetItemField = '') and
           (LinkTableList.IndexOf(AnsiUpperCase(Trim(PK.ConstraintFields[I].References.RelationName))) > -1)
           and (I > 0)
          then
          begin
            FSetItemField := PK.ConstraintFields[I].FieldName
          end;

          if (FSetItemField > '') and
           (FSetMasterField > '')
          then
            Break;
        end;

        if (FSetItemField = '') or (FSetMasterField = '') then
          raise EgdcException.Create('В таблице ' + FSetTable + ' утеряны ссылки!');

        Result :=
          Format('JOIN %0:s %5:s ON %5:s.%1:s = :MASTER_RECORD_ID AND %5:s.%2:s = %3:s.%4:s ',
          [FSetTable, FSetMasterField, FSetItemField, GetListTableAlias, GetKeyField(SubType), cstSetAlias]);
      finally
        LinkTableList.Free;
      end;
    end;
  end;
end;

function TgdcBase.GetSelectSQLText: String;
var
  SelectClause, FromClause, WhereClause, GroupClause, OrderClause: String;
begin
  SelectClause := GetSelectClause;
  if Assigned(FOnGetSelectClause) then
    FOnGetSelectClause(Self, SelectClause);

  FromClause := GetFromClause;
  if Assigned(FOnGetFromClause) then
    FOnGetFromClause(Self, FromClause);

  WhereClause := GetWhereClause;
  if Assigned(FOnGetWhereClause) then
    FOnGetWhereClause(Self, WhereClause);

  GroupClause := GetGroupClause;
  if Assigned(FOnGetGroupClause) then
    FOnGetGroupClause(Self, GroupClause);

  OrderClause := GetOrderClause;
  if Assigned(FOnGetOrderClause) then
    FOnGetOrderClause(Self, OrderClause);

  Result :=
    SelectClause + ' ' + GetSetTableSelect +
    FromClause + ' ' + GetSetTableJoin +
    WhereClause + ' ';
  if not HasSubSet('ByID') then
    Result := Result +
      GroupClause + ' ' +
      OrderClause;
end;

function TgdcBase.GetWhereClause: String;

  function GetSecCondition: String;
  begin
    Result := '';
    if Assigned(IBLogin) then
    begin
      if tiAView in gdcTableInfos then
        Result := Result + Format(' g_sec_test(%s.aview, %d) <> 0 ',
          [GetListTableAlias, IBLogin.InGroup])
      else if tiAChag in gdcTableInfos then
        Result := Result + Format(' g_sec_test(%s.achag, %d) <> 0 ',
          [GetListTableAlias, IBLogin.InGroup])
      else if tiAFull in gdcTableInfos then
        Result := Result + Format(' g_sec_test(%s.afull, %d) <> 0 ',
          [GetListTableAlias, IBLogin.InGroup]);
    end;
  end;

var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  S: TStringList;
  I: Integer;
begin
  {@UNFOLD MACRO INH_ORIG_GETWHERECLAUSE('TGDCBASE', 'GETWHERECLAUSE', KEYGETWHERECLAUSE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYGETWHERECLAUSE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYGETWHERECLAUSE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'GETWHERECLAUSE', KEYGETWHERECLAUSE, Params, LResult) then
  {M}          begin
  {M}            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
  {M}              Result := String(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'GETWHERECLAUSE' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не строковый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Result := '';//Inherited GetWhereClause;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  S := TStringList.Create;
  try
    S.Duplicates := dupIgnore;
    GetWhereClauseConditions(S);
    S.Add(GetSecCondition);
    for I := 0 to FExtraConditions.Count - 1 do
      S.Add(FExtraConditions[I]);
    for I := S.Count - 1 downto 0 do
      if Trim(S[I]) = '' then
        S.Delete(I);
    if S.Count > 0 then
    begin
      Result := 'WHERE ' + S[0];
      for I := 1 to S.Count - 1 do
        Result := Result + ' AND ' + S[I];
    end else
      Result := '';
  finally
    S.Free;
  end;
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'GETWHERECLAUSE', KEYGETWHERECLAUSE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'GETWHERECLAUSE', KEYGETWHERECLAUSE);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.InitSQL;
var
  SQLText, FullClassName: String;
  isReplaceSQL: Boolean;
  {$IFDEF DEBUG}T: TDateTime;{$ENDIF}
begin
  {$IFDEF DEBUG}
  T := Now;
  {$ENDIF}

  if FSQLInitialized then
    exit;

  // пытаемся, чтобы компоненты-поля не удалялись
  // т.к. в случае их удаления колонки в гриде
  // так же удаляется и у нас будут проблемы
  SetDefaultFields(True);
  DestroyFields;

  if not Assigned(FSQLSetup) then
    FSQLSetup := TatSQLSetup.Create(nil);

  if not (csDesigning in ComponentState) then
  begin
    FullClassName := Self.ClassName + '(' + Self.SubType + ')';
    with FSQLSetup do
    begin
      //В Select-запрос вытягиваем только указанные аттрибуты
      SelectSQL.Text := PrepareSQL(GetSelectSQLText, FullClassName);
      ModifySQL.Text := PrepareSQL(GetModifySQLText, FullClassName);
      InsertSQL.Text := PrepareSQL(GetInsertSQLText, FullClassName);
      DeleteSQL.Text := {PrepareSQL(}GetDeleteSQLText{)};
      if FSetRefreshSQLOn then
        RefreshSQL.Text := PrepareSQL(GetRefreshSQLText, FullClassName)
      else
        RefreshSQL.Text := '';
    end;
  end else
  begin
    SelectSQL.Text := GetSelectSQLText;
    ModifySQL.Text := GetModifySQLText;
    InsertSQL.Text := GetInsertSQLText;
    DeleteSQL.Text := GetDeleteSQLText;
    if FSetRefreshSQLOn then
      RefreshSQL.Text := GetRefreshSQLText
    else
      RefreshSQL.Text := '';
  end;

// Событие на создание запроса. Для возможности его корректировки из вне.

  if Assigned(FAfterInitSQL) then
  begin
    isReplaceSQL := False;
    SQLText := SelectSQL.Text;
    FAfterInitSQL(Self, SQLText, isReplaceSQL);
    if isReplaceSQL then
      SelectSQL.Text := SQLText;
  end;

  FSQLInitialized := True;

  {$IFDEF DEBUG}
  //if Now - T > 1 / (24 * 60 * 60) then
    OutputDebugString(PChar(Name + '.InitSQL: ' + FormatDateTime('s.z', Now - T)));
  {$ENDIF}
end;

procedure TgdcBase.InternalPostRecord(Qry: TIBSQL; Buff: Pointer);
var
  i, j, k, CutOff: Integer;
  pbd: PBlobDataArray;
  DidActivate: Boolean;
begin
  pbd := PBlobDataArray(PChar(Buff) + FBlobCacheOffset);
  j := 0;
  for i := 0 to FieldCount - 1 do
    if Fields[i].IsBlob then
    begin
      k := FMappedFieldPosition[Fields[i].FieldNo -1];
      if pbd^[j] <> nil then
      begin
        pbd^[j].Finalize;
        PISC_QUAD(
          PChar(Buff) + PRecordData(Buff)^.rdFields[k].fdDataOfs)^ :=
          pbd^[j].BlobID;
        PRecordData(Buff)^.rdFields[k].fdIsNull := pbd^[j].Size = 0;
      end;
      Inc(j);
    end;

  if not FDataTransfer then
  begin

    for I := 0 to FieldCount - 1 do
      ValidateField(Fields[I]);

    if Assigned(UpdateObject) then
    begin
      if (Qry = QDelete) then
        UpdateObject.Apply(DB.ukDelete)
      else
        if (Qry = QInsert) then
          UpdateObject.Apply(DB.ukInsert)
        else
          UpdateObject.Apply(DB.ukModify);
    end
    else
    begin
      DidActivate := ActivateTransaction;
      try
        DoBeforeInternalPostRecord;

        { TODO :
код обработки конфликтов транзакций.
работает следующим образом:
пытаемся выполнить кастом инсерт или модифай,
если проходит то все нормально. если не прошло
и выдало конфликт на не ждущей транзакции,
и мы открывали эту транзакцию и ее можно закрыть,
то закрываем транзакцию. выжидаем пол секунды.
открываем транзакцию и повторяем все по-новой.
так не более пяти раз. если не помогло то даем
исключение.

внимание! код ошибки верен для транзакции:
read_committed
rec_version
nowait

для транзакций другого типа может дать другой код ошибки.
мы не проверяли эти случаи.}
        CutOff := 5;
        repeat
          try
            { TODO : в случае кастом обработки роузаффектед будет содержать 0 }
            FRowsAffected := 0;
            if (Qry = QInsert) then
              _CustomInsert(Buff)
            else if (Qry = QModify) then
              _CustomModify(Buff);
            CutOff := 0;
          except
            on E: EIBError do
            begin
              if (E.IBErrorCode = isc_lock_conflict)
                and DidActivate
                and AllowCloseTransaction then
              begin
                if (CutOff > 1) then
                begin
                  Transaction.Rollback;
                  Sleep(500);
                  Dec(CutOff);
                  Transaction.StartTransaction;
                end else
                  raise;
              end else
                raise;
            end else
              raise;
          end;
        until CutOff = 0;

        DoAfterInternalPostRecord;

        if DidActivate and AllowCloseTransaction then
          Transaction.Commit;
      except
        if DidActivate and AllowCloseTransaction then
          Transaction.Rollback;
        raise;
      end;
    end;
  end;

  PRecordData(Buff)^.rdUpdateStatus := usUnmodified;
  PRecordData(Buff)^.rdCachedUpdateStatus := cusUnmodified;
  SetModified(False);
  WriteRecordCache(PRecordData(Buff)^.rdRecordNumber, Buff);

  if not FDataTransfer then
  begin
    if (ForcedRefresh or FNeedsRefresh) and CanRefresh then
      InternalRefreshRow;
  end;
end;

procedure TgdcBase.InternalDeleteRecord(Qry: TIBSQL; Buff: Pointer);
var
  DidActivate: Boolean;
  CFull: TgdcFullClass;
  C: CgdcBase;
  Obj: TgdcBase;
  CutOff: Integer;
begin
  if (Assigned(FUpdateObject) and (FUpdateObject.GetSQL(DB.ukDelete).Text > '')) then
    FUpdateObject.Apply(DB.ukDelete)
  else if not FDataTransfer then
  begin
    if GetCurrRecordClass.gdClass = Self.ClassType then
    begin
      //!!!
      DidActivate := ActivateTransaction;
      try
    //!!!
        if Assigned(BeforeInternalDeleteRecord) then
          BeforeInternalDeleteRecord(Self);

        { TODO : см. комментарий к ИнтерналПост }
        CutOff := 5;
        repeat
          try
            FRowsAffected := 0;
            if (Qry = QDelete) then
              _CustomDelete(Buff);
            CutOff := 0;
          except
            on E: EIBError do
            begin
              if (E.IBErrorCode = isc_lock_conflict)
                and DidActivate
                and AllowCloseTransaction
                and (CutOff > 0) then
              begin
                Transaction.Rollback;
                Sleep(500);
                Dec(CutOff);
                Transaction.StartTransaction;
              end else
                raise;
            end else
              raise;
          end;
        until CutOff = 0;

        if Assigned(AfterInternalDeleteRecord) then
          AfterInternalDeleteRecord(Self);
      //!!!
      
        if DidActivate and AllowCloseTransaction then
          Transaction.Commit;
      except
        if DidActivate and AllowCloseTransaction then
          Transaction.Rollback;
        raise;
      end;
      //!!!
    end else
    begin
      CFull := GetCurrRecordClass;
      C := CFull.gdClass;
      Obj := CgdcBase(C).CreateWithID(Owner, Database, Transaction, ID, CFull.SubType);
      try
        Obj.Open;
        Obj.Delete;
      finally
        Obj.Free;
      end;
    end;
  end;
  with PRecordData(Buff)^ do
  begin
    rdUpdateStatus := usDeleted;
    rdCachedUpdateStatus := cusUnmodified;
  end;
  WriteRecordCache(PRecordData(Buff)^.rdRecordNumber, Buff);
end;

class function TgdcBase.IsBigTable: Boolean;
begin
  //...
  Result := False;
end;

procedure TgdcBase.Loaded;
begin
  inherited Loaded;
  QueryFiltered := True;
end;

function TgdcBase.CheckNeedModify(SourceDS: TDataSet; IDMapping: TgdKeyIntAssoc;
  var AnAnswer: Word): Boolean;
const
  PassFieldName = ';EDITIONDATE;CREATIONDATE;CREATORKEY;EDITORKEY;ACHAG;AVIEW;AFULL;LB;RB;';
var
  IsDifferent: Boolean;
  I: Integer;
  R: TatRelation;
  F: TatRelationField;
  Key: Integer;
  SourceSt, CurrentSt: String;
begin
  Result := True;

  //если наш объект - стандартные мета-данные, то перезаписываем по умолчанию
  if Self.InheritsFrom(TgdcMetaBase) and (not (Self as TgdcMetaBase).IsUserDefined) then
    Exit;

  case AnAnswer of
    mrYesToAll: Result := True;
    mrNoToAll: Result := False;
    else
    begin
      if NeedModifyFromStream(SubType) <> ModifyFromStream then
     {Возможно нам выставили флаг "Обновлять из потока" вручную,
      тогда нас не интересует ни дата обновления, ни содержимое уже существующей записи}
      begin
        AnAnswer := MessageDlg('Объект ' + GetDisplayName(SubType) + ' ' +
          FieldByName(GetListField(SubType)).AsString + ' с идентификатором ' +
          FieldByName(GetKeyField(SubType)).AsString + ' уже существует в базе. ' +
          'Заменить объект? ', mtConfirmation,
          [mbYes, mbYesToAll, mbNo, mbNoToAll], 0);
        case AnAnswer of
          mrYes, mrYesToAll: Result := True;
          mrNo, mrNoToAll: Result := False;
        end;
      end else

      if Assigned(SourceDS.FindField('editiondate')) and
        Assigned(FindField('editiondate'))
      then
      begin
        Result := False;
        if (SourceDS.FieldByName('editiondate').AsDateTime <= FieldByName('editiondate').AsDateTime)
        then
        begin
          IsDifferent := False;

          //Проверим на отличие содержимого полей загружаемой записи от существующей
          for I := 0 to SourceDS.Fields.Count - 1 do
          begin
            if Assigned(FindField(SourceDS.Fields[I].FieldName)) and
              //Исключим из проверки поля editiondate, keyfield, editorkey
              (AnsiCompareText(Trim(SourceDS.Fields[I].FieldName), GetKeyField(SubType)) <> 0) and
              (AnsiPos(';' + AnsiUpperCase(Trim(SourceDS.Fields[I].FieldName)) + ';', PassFieldName) = 0)
            then
            begin
              F := nil;
              if Assigned(atDatabase) and (SourceDS.Fields[I].DataType in [ftInteger, ftSmallInt, ftWord]) then
              begin
               //Проверяем не является ли наше поле ссылкой
                R := atDatabase.Relations.ByRelationName(RelationByAliasName(SourceDS.Fields[I].FieldName));
                if Assigned(R) then
                  F := R.RelationFields.ByFieldName(FieldNameByAliasName(SourceDS.Fields[I].FieldName));
                if Assigned(F) and Assigned(F.References) then
                begin
                  //Если нам передан SourceDS из потока (IDMapping <> nil)
                  //то ищем соответсвие нашей ссылке
                  //В обратном случае (т.е. если нам передан обработанный SourceDS)
                  //берем текущее значение
                  if Assigned(IDMapping) then
                  begin
                    Key := IDMapping.IndexOf(SourceDS.Fields[I].AsInteger);
                    if Key <> -1 then
                    begin
                      Key := IDMapping.ValuesByIndex[Key];
                    end;
                    if (Key = -1) and (SourceDS.Fields[I].AsInteger < cstUserIDStart) then
                      Key := SourceDS.Fields[I].AsInteger;
                  end else
                    Key := SourceDS.Fields[I].AsInteger;

                  //Сравниваем наши ссылки
                  if (Key <> FieldByName(SourceDS.Fields[I].FieldName).AsInteger)
                  then
                  begin
                    IsDifferent := True;
                    Break;
                  end;
                  Continue;
                end;
              end;

              if (Trim(SourceDS.Fields[I].AsString) = '') and (SourceDS.Fields[I].AsString > '') then
              //Если строка у нас содержит только пробелы
              //То оставляем ее такую как есть
                SourceSt := SourceDS.Fields[I].AsString
              else
              //В обратном случае убираем ведущие и закрывающие пробелы
                SourceSt := Trim(SourceDS.Fields[I].AsString);

              if (Trim(FieldByName(SourceDS.Fields[I].FieldName).AsString) = '') and
                (FieldByName(SourceDS.Fields[I].FieldName).AsString > '')
              then
                CurrentSt := FieldByName(SourceDS.Fields[I].FieldName).AsString
              else
                CurrentSt := Trim(FieldByName(SourceDS.Fields[I].FieldName).AsString);

              if (CurrentSt <> SourceSt) then
              begin
                IsDifferent := True;
                Break;
              end;
            end;
          end;

          if IsDifferent then
          begin
            //Если загружаемая запись отличается от существующей уточним, нужно ли ее считывать
            AnAnswer := MessageDlg('Объект ' + GetDisplayName(SubType) + ' ' +
              FieldByName(GetListField(SubType)).AsString + ' с идентификатором ' +
              FieldByName(GetKeyField(SubType)).AsString + ' имеет более позднюю модификацию, ' +
              'чем загружаемый из потока. Заменить объект? ', mtConfirmation,
              [mbYes, mbYesToAll, mbNo, mbNoToAll], 0);
            case AnAnswer of
              mrYes, mrYesToAll: Result := True;
              mrNo, mrNoToAll: Result := False;
            end;
          end;
        end else if (SourceDS.FieldByName('editiondate').AsDateTime > FieldByName('editiondate').AsDateTime)
        then
        begin
          Result := True;
        end;
      end;
    end;
  end;
end;

procedure TgdcBase._LoadFromStreamInternal(Stream: TStream; IDMapping: TgdKeyIntAssoc;
  ObjectSet: TgdcObjectSet; UpdateList: TObjectList; StreamRecord: TgsStreamRecord;
  var AnAnswer: Word; const SelectRuid, DeleteRuid, UpdateRuid, TempSQL: TIBSQL);

  function StreamReadString(St: TStream): String;
  var
    L: Integer;
  begin
    St.Read(L, SizeOf(L));
    SetLength(Result, L);
    if L > 0 then
      St.Read(Result[1], L);
  end;

  procedure InsertRecord(SourceDS: TDataSet; TargetDS: TgdcBase; UL: TObjectList); forward;

  function CopyRecord(SourceDS: TDataSet; TargetDS: TgdcBase; UL: TObjectList): Boolean;
  const
    rightsfield = ';ACHAG;AVIEW;AFULL;';
    editorfield = ';EDITORKEY;CREATORKEY;';
  var
    I, Key: Integer;
    R: TatRelation;
    F: TatRelationField;
    IsNull: Boolean;
    SourceField, TargetField: TField;
    RU: TgdcReferenceUpdate;
    ErrorSt: String;
    NeedAddToIDMapping: Boolean;
  begin
    NeedAddToIDMapping := True;
    Result := False;
    RU := nil;

    for I := 0 to SourceDS.FieldCount - 1 do
    begin
      SourceField := SourceDS.Fields[I];
      TargetField := TargetDS.FindField(SourceField.FieldName);

      if (TargetField <> nil) then
      begin
        R := atDatabase.Relations.ByRelationName(TargetDS.RelationByAliasName(TargetField.FieldName));

        // системных таблиц нет в нашей структуре атДатабэйз
        if R = nil then
        begin
          //Если это ключевое поле, то переходим к следующему полю
          if (AnsiCompareText(SourceField.FieldName, TargetDS.GetKeyField(TargetDS.SubType)) = 0) then
            Continue;

          if (TargetField.DataType = ftString) and (SourceField.AsString = '') then
            TargetField.AsString := ''
          else
            TargetField.Assign(SourceField);
          Continue;
        end;

        //Если это поле для установки прав и оно пришло к нам из другой базы
        //то устанавливаем права "для всех"
        if (AnsiPos(';' + AnsiUpperCase(TargetField.FieldName) + ';', rightsfield) > 0) and
          (StreamRecord.StreamDBID > -1) and (StreamRecord.StreamDBID <> IBLogin.DBID)
        then
        begin
          TargetField.AsInteger := -1;
          Continue;
        end;

        //Если это поле для указания "Кто редактировал", то считываем текущего пользователя
        if (AnsiPos(';' + AnsiUpperCase(TargetField.FieldName) + ';', editorfield) > 0)
        then
        begin
          TargetField.AsInteger := IBLogin.ContactKey;
          Continue;
        end;

        if (TargetDS is TgdcDocument) and (TargetField.FieldName = 'DOCUMENTKEY')
          and (TargetField.Value > 0)
        then
          continue;

        F := R.RelationFields.ByFieldName(TargetDS.FieldNameByAliasName(TargetField.FieldName));

        RU := nil;
        IsNull := False;
        Key := -1;

        if (F <> nil) and (F.References <> nil) and
          (AnsiCompareText(SourceField.FieldName, TargetDS.GetKeyField(TargetDS.SubType)) = 0) then
        begin
          //Если это ключевое поле и оно является ссылкой, то поищем его в карте идентификаторов
          Key := IDMapping.IndexOf(SourceField.AsInteger);
          if Key <> -1 then
          begin
            Key := IDMapping.ValuesByIndex[Key];
          end;
          if Key > -1 then
          begin
            TargetField.AsInteger := Key;
            NeedAddToIDMapping := False;
          end;
          Continue;
        end
       //Если это ключевое поле, то переходим к следующему полю
        else if (AnsiCompareText(SourceField.FieldName, TargetDS.GetKeyField(TargetDS.SubType)) = 0) then
          Continue;


        if (F <> nil) and (F.References <> nil) then
        begin
          Key := IDMapping.IndexOf(SourceField.AsInteger);
          if Key <> -1 then
          begin
            Key := IDMapping.ValuesByIndex[Key];
            IsNull := Key = -1;
          end;

          if (ObjectSet.Find(SourceField.AsInteger) <> -1) and
            (SourceField.AsInteger = SourceDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsInteger) and
            (TargetDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsInteger > 0)
          then
            Key := TargetDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsInteger;

          if (Key = -1) and (ObjectSet.Find(SourceField.AsInteger) <> -1) and
            (SourceField.AsInteger <> SourceDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsInteger) then
          begin
            RU := TgdcReferenceUpdate.Create;
            RU.C := GetBaseClassForRelation(F.References.RelationName).gdClass;
            RU.TableName := R.RelationName;
            RU.FieldName := F.FieldName;
            RU.KeyFieldName := R.PrimaryKey.ConstraintFields[0].FieldName;
            RU.ID := -1;
            RU.RefID := SourceField.AsInteger;
            UL.Add(RU);
            IsNull := True;
          end else if (Key = -1) and (SourceField.AsInteger >= cstUserIDStart) then
          begin
            //если мы не нашли нашу ссылку и она не является "стандартной" записью
            //очистим это поле, иначе кинет ошибку ссылочной целостности
            //такие записи могут специально не сохранятся в поток по разным причинам
            //например, в поток не сохраняются системные мета-данные
            IsNull := True;
          end;
        end;

        if Key = -1 then
        begin
          if IsNull then
            TargetField.Clear
          else
          begin
            if SourceField.IsNull then
              TargetField.Clear
            else
            begin
              if (TargetField.DataType = ftString) and (SourceField.AsString = '') then
                TargetField.AsString := ''
              else
                TargetField.Assign(SourceField);
            end;
          end
        end else
        begin
          if IsNull then
            TargetField.Clear
          else
            TargetField.AsInteger := Key;
        end;
      end;
    end;

    //Стандартные id не должны меняться
    if SourceDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsInteger < cstUserIDStart then
      TargetDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsInteger :=
        SourceDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsInteger;
    try
      if TargetDS.State = dsEdit then
      begin
        try
          TargetDS.Post;
          AddText('Объект обновлен данными из потока!', clBlack);
          Space;
        except
          on E: EIBError do
          begin
            if (E.IBErrorCode = isc_no_dup) or (E.IBErrorCode = isc_except) then
            begin
              //мы нашли запись по РУИДУ и попытались обновить ее
              //кинуло ошибку - нельзя сохранить два дублирующихся объекта
              //=> РУИД указывает нам не тот объект
              //=> Делаем Cancel объекту, удаляем некорректный РУИД
              //=> Пытаемся добавить новую запись.
              TargetDS.Cancel;
              TargetDS.SubSet := 'All';
              TargetDS.Open;
              AddText('РУИД некорректен. Попытка найти объект по уникальному ключу.', clBlack);
              ExecSingleQuery(Format('DELETE FROM gd_ruid WHERE xid=%0:s AND dbid=%1:s',
                [SourceDS.FieldByName('_XID').AsString, SourceDS.FieldByName('_DBID').AsString]));
              InsertRecord(SourceDS, TargetDS, UL);
              NeedAddToIDMapping := False;
            end else
              raise;
          end;
        end;
      end

      else if not TargetDS.CheckTheSame(AnAnswer, True) then
      begin
        TargetDS.Post;
        AddText('Объект добавлен из потока!', clBlack);
        Space;
      end;

      if NeedAddToIDMapping then
        IDMapping.ValuesByIndex[
          IDMapping.Add(SourceDS.FieldByName(TargetDS.GetKeyField(SubType)).AsInteger)] := TargetDS.ID;

      if RU <> nil then
      begin
        RU.ID := TargetDS.ID;
      end;

      for I := UL.Count - 1 downto 0 do
      begin
        if (UL[I] as TgdcReferenceUpdate).RefID = SourceDS.FieldByName(TargetDS.GetKeyField(SubType)).AsInteger then
        begin
          ExecSingleQuery(Format('UPDATE %s SET %s=%d WHERE %s=%d',
            [(UL[I] as TgdcReferenceUpdate).TableName,
             (UL[I] as TgdcReferenceUpdate).FieldName,
             TargetDS.ID,
             (UL[I] as TgdcReferenceUpdate).KeyFieldName,
             (UL[I] as TgdcReferenceUpdate).ID]));
        end;
        UL.Delete(I);
      end;

      ObjectSet.Remove(SourceDS.FieldByName(TargetDS.GetKeyField(SubType)).AsInteger);

      Result := True;
    except
      on E: EDatabaseError do
      begin
        if TargetDS.State = dsInsert then
          ErrorSt := Format('Невозможно добавить объект: %s %s %s',
            [TargetDS.ClassName,
             SourceDS.FieldByName(TargetDS.GetListField(TargetDS.SubType)).AsString,
             SourceDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsString])
        else
          ErrorSt := Format('Невозможно обновить объект: %s %s %s',
            [TargetDS.ClassName,
             SourceDS.FieldByName(TargetDS.GetListField(TargetDS.SubType)).AsString,
             SourceDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsString]);

        MessageBox(ParentHandle,
          PChar(ErrorSt),
          'Ошибка',
          MB_OK or MB_ICONHAND);

        AddMistake(#13#10 + ErrorSt + #13#10, clRed);
        AddMistake(#13#10 + E.Message + #13#10, clRed);
        Space;

        TargetDS.Cancel;

        IDMapping.ValuesByIndex[
          IDMapping.Add(SourceDS.FieldByName(TargetDS.GetKeyField(SubType)).AsInteger)] := -1;
      end;
    end;
  end;

  procedure InsertToRUID(aID, axID, aDBID: Integer; aModified: TDateTime; aEditorKey: Integer);
  begin
    FibSQL_InsertToRUID.Close;
    FibSQL_InsertToRUID.ParamByName('id').AsInteger := aID;
    FibSQL_InsertToRUID.ParamByName('xid').AsInteger := aXID;
    FibSQL_InsertToRUID.ParamByName('dbid').AsInteger := aDBID;
    FibSQL_InsertToRUID.ParamByName('modified').AsDateTime := aMODIFIED;
    if aEditorKey > 0 then
      FibSQL_InsertToRUID.ParamByName('editorkey').AsInteger := aEditorKey
    else
      FibSQL_InsertToRUID.ParamByName('editorkey').Clear;
    FibSQL_InsertToRUID.ExecQuery;
  end;

  procedure InsertRecord(SourceDS: TDataSet; TargetDS: TgdcBase; UL: TObjectList);
  begin
    TargetDS.Insert;
    if CopyRecord(SourceDS, TargetDS, UL) then
    begin
      TargetDS.CheckBrowseMode;
      FibSQL_SelectRUID.Close;
      FibSQL_SelectRUID.ParamByName('id').AsInteger := TargetDS.ID;
      FibSQL_SelectRUID.ExecQuery;
      if FibSQL_SelectRUID.EOF then
      begin
        if Assigned(IBLogin) then
          InsertToRUID(TargetDS.ID, SourceDS.FieldByName('_XID').AsInteger, SourceDS.FieldByName('_DBID').AsInteger,
                     SourceDS.FieldByName('_MODIFIED').AsDateTime, IBLogin.ContactKey)
        else
          InsertToRUID(TargetDS.ID, SourceDS.FieldByName('_XID').AsInteger, SourceDS.FieldByName('_DBID').AsInteger,
                     SourceDS.FieldByName('_MODIFIED').AsDateTime, 0);
      end else
      begin
        // этот объект уже приходил к нам из другой базы
        // его РУИД уже сформирован. Если мы не хотим в будущем
        // каждый раз указывать соответствие объектов при импорте
        // необходимо передать назад в базу источник
        // существующий РУИД этого объекта, чтобы там прописать его.
        //
        // хм. надо подумать...
        //
        // пока же просто обновим его РУИД
        // проблема будет только если из двух баз постоянно
        // поочередно передаются данные в третью
        // придется каждый раз указывать соответствие объектов

        FibSQL_SelectRUID.Close;
        FibSQL_UpdateRUID.ParamByName('id').AsInteger := TargetDS.ID;
        FibSQL_UpdateRUID.ParamByName('xid').AsInteger := SourceDS.FieldByName('_XID').AsInteger;
        FibSQL_UpdateRUID.ParamByName('dbid').AsInteger := SourceDS.FieldByName('_DBID').AsInteger;
        FibSQL_UpdateRUID.ParamByName('modified').AsDateTime := SourceDS.FieldByName('_MODIFIED').AsDateTime;
        FibSQL_UpdateRUID.ExecQuery;
      end;
      FibSQL_SelectRUID.Close;
    end;
  end;

var
  CDS: TClientDataSet;
  I, D: Integer;
  MS: TMemoryStream;
  Modified: TDateTime;
  DidActivate: Boolean;

begin

  Assert(IBLogin <> nil);

  if not FStreamSQLInitialised then
    StreamSQLInitialize;

  Include(FBaseState, sLoadFromStream);
  CDS := TClientDataSet.Create(nil);
  try
    Stream.Read(I, SizeOf(I));
    MS := TMemoryStream.Create;
    try
      MS.CopyFrom(Stream, I);
      MS.Position := 0;
      CDS.LoadFromStream(MS);
    finally
      MS.Free;
    end;

    CDS.Open;

    Space;
    if (CDS.FindField(GetListField(SubType)) = nil) then
    begin
      AddText(#13#10 + 'Считывание объекта ' + GetDisplayName(GetSubType) + ' ' +
          ' (XID =  ' + CDS.FieldByName('_xid').AsString + ', DBID = ' +
        CDS.FieldByName('_dbid').AsString + ')'#13#10, clBlue);

      AddMistake('Структура загружаемого объекта не соответствует '#13#10 +
        ' структуре уже существующего объекта в базе. '#13#10 +
        ' Поле ' + GetListField(SubType) + ' не найдено в потоке данных!'#13#10, clRed);
    end else
    begin
      AddText(#13#10 + 'Считывание объекта ' + GetDisplayName(GetSubType) + ' ' +
        CDS.FieldByName(GetListField(SubType)).AsString + #13#10 +
        ' (XID =  ' + CDS.FieldByName('_xid').AsString + ', DBID = ' +
        CDS.FieldByName('_dbid').AsString + ')'#13#10, clBlue);
    end;

    DidActivate := False;
    try
      DidActivate := ActivateTransaction;

      SelectRUID.Close;
      SelectRUID.ParamByName('xid').AsInteger := CDS.FieldByName('_XID').AsInteger;
      SelectRUID.ParamByName('dbid').AsInteger := CDS.FieldByName('_DBID').AsInteger;
      SelectRUID.ExecQuery;

      if SelectRUID.EOF then
        D := -1
      else
        D := SelectRUID.FieldByName('id').AsInteger;

      if SelectRUID.EOF and (CDS.FieldByName('_XID').AsInteger < cstUserIDStart) then
      begin
        { TODO : Небольшая проблема: такой запрос вытянет из главной таблицы запись по id,
          но если в объекте у Where-часть ВСЕГДА добавляется еще к-л условие, то объекта с таким ид может не быть }
        TempSQL.Close;
        TempSQL.SQL.Text := Format('SELECT * FROM %s WHERE %s=:id',
          [GetListTable(SubType), GetKeyField(SubType)]);
        TempSQL.ParamByName('id').AsInteger := CDS.FieldByName('_XID').AsInteger;
        TempSQL.ExecQuery;

        if not TempSQL.EOF then
        begin
          InsertToRUID(CDS.FieldByName('_XID').AsInteger,
            CDS.FieldByName('_XID').AsInteger,
            CDS.FieldByName('_DBID').AsInteger, Date, -1);
          D := CDS.FieldByName('_XID').AsInteger;
        end;
      end;

      if D = -1 then
      begin
        InsertRecord(CDS, Self, UpdateList);
      end else
      begin
        Modified := SelectRUID.FieldByName('modified').AsDateTime;

        TempSQL.Close;
        TempSQL.SQL.Text := Format('SELECT * FROM %s WHERE %s=:id',
          [GetListTable(SubType), GetKeyField(SubType)]);
        TempSQL.ParamByName('id').AsInteger := D;
        TempSQL.ExecQuery;

        if TempSQL.EOF then
        begin
          DeleteRUID.Close;
          DeleteRUID.ParamByName('xid').AsInteger := CDS.FieldByName('_XID').AsInteger;
          DeleteRUID.ParamByName('dbid').AsInteger := CDS.FieldByName('_DBID').AsInteger;
          DeleteRUID.ExecQuery;

          InsertRecord(CDS, Self, UpdateList);
        end else
        begin
          AddText(#13#10 + 'Объект найден по РУИДу'#13#10, clBlue);

          if NeedDeleteTheSame(SubType) and
            DeleteTheSame(D, CDS.FieldByName(GetListField(SubType)).AsString)
          then
          begin
            InsertRecord(CDS, Self, UpdateList);
          end else

          //Если мы нашли объект по руиду и
          //Если дата модификации руида более ранняя, чем загружаемая из потока
          //или объект нуждается в обновлении данными из потока по умолчанию
          if (Modified < CDS.FieldByName('_modified').AsDateTime) or
             ModifyFromStream then
          begin
            //Устанавливаем курсор на запись с необходимым id
            if SubSet <> 'ByID' then
              SubSet := 'ByID';
            ID := TempSQL.FieldByName(GetKeyField(SubType)).AsInteger;
            Open;

            //Уточням, нуждается ли наш объект в обновлении данными из потока
            if CheckNeedModify(CDS, IDMapping, AnAnswer) then
            begin
              Edit;
              //если обновление прошло успешно и мы имеем более раннюю дату модификации руида
              //изменяем руид
              if CopyRecord(CDS, Self, UpdateList) and
                (Modified < CDS.FieldByName('_modified').AsDateTime)
              then
              begin
                CheckBrowseMode;

                UpdateRUID.Close;
                UpdateRUID.ParamByName('xid').AsInteger := CDS.FieldByName('_XID').AsInteger;
                UpdateRUID.ParamByName('dbid').AsInteger := CDS.FieldByName('_DBID').AsInteger;
                UpdateRUID.ParamByName('modified').AsDateTime := CDS.FieldByName('_MODIFIED').AsDateTime;
                UpdateRUID.ExecQuery;
              end;
            end else
            //Если мы не обновляли наш объект, то занесем его идентификатор в IDMapping
            //try...except добавлен из-за пользовательских таблиц-ссылок
            //их данные сохраняются отдельно от основного объекта,
            //из-за чего на один ID может получится несколько объектов
              try
                IDMapping.ValuesByIndex[
                  IDMapping.Add(CDS.FieldByName(GetKeyField(SubType)).AsInteger)] :=
                  TempSQL.FieldByName(GetKeyField(SubType)).AsInteger;
              except
              end;
          end else
          begin
            //try...except добавлен из-за пользовательских таблиц-ссылок
            //их данные сохраняются отдельно от основного объекта,
            //из-за чего на один ID может получится несколько объектов
            try
              IDMapping.ValuesByIndex[
                IDMapping.Add(CDS.FieldByName(GetKeyField(SubType)).AsInteger)] :=
                TempSQL.FieldByName(GetKeyField(SubType)).AsInteger;
            except
            end;
          end;
        end;
      end;

    finally
      if DidActivate and Transaction.InTransaction then
        Transaction.Commit;
    end;
  finally
    CDS.Free;
    Exclude(FBaseState, sLoadFromStream);
  end;
end;

procedure TgdcBase._LoadFromStream(Stream: TStream; IDMapping: TgdKeyIntAssoc;
  ObjectSet: TgdcObjectSet; UpdateList: TObjectList);

  function StreamReadString(St: TStream): String;
  var
    L: Integer;
  begin
    St.Read(L, SizeOf(L));
    SetLength(Result, L);
    if L > 0 then
      St.Read(Result[1], L);
  end;

var
  I: Integer;
  Obj: TgdcBase;
  C: TClass;
  IDMappingCreated: Boolean;
  LoadClassName, LoadSubType: String;
  ULCreated: Boolean;
  DidActivate: Boolean;
  OldPos: Integer;
  stVersion: String;
  stRecord: TgsStreamRecord;
  AnAnswer: Word;
  SelectRuid, DeleteRuid, UpdateRuid, TempSQL: TIBSQL;
  RecCount: Integer;
  PrSet: TgdcPropertySet;
  PropInfo: PPropInfo;
  ObjList: TStringList;
  Ind: Integer;
begin
  AnAnswer := 0;
  CheckBrowseMode;

  Assert(IBLogin <> nil);
  Assert(atDatabase <> nil);
  Assert(ObjectSet <> nil);

  Obj := nil;
  Space;
  AddText(#13#10 + TimeToStr(Time) + ': Начата загрузка данных из потока.'#13#10, clBlack, True);

  if Assigned(frmSQLProcess) and Assigned(ObjectSet) then
  begin
    with frmSQLProcess.pb do
    begin
      Min := 0;
      Max := ObjectSet.Count;
      Position := 0;
    end;
  end;

  ObjList := TStringList.Create;

  if IDMapping = nil then
  begin
    IDMapping := TgdKeyIntAssoc.Create;
    IDMappingCreated := True;
  end else
    IDMappingCreated := False;

  if UpdateList = nil then
  begin
    UpdateList := TObjectList.Create(True);
    ULCreated := True;
  end else
    ULCreated := False;

  PrSet := TgdcPropertySet.Create('', nil, '');
  try
    DidActivate := False;
    try
      DidActivate := ActivateTransaction;

      SelectRuid := TIBSQL.Create(nil);
      DeleteRuid := TIBSQL.Create(nil);
      UpdateRuid := TIBSQL.Create(nil);
      TempSQL := TIBSQL.Create(nil);
      try
        SelectRuid.SQL.Text := 'SELECT * FROM gd_ruid WHERE xid=:xid AND dbid=:dbid';
        SelectRuid.Transaction := Transaction;
        DeleteRuid.SQL.Text := 'DELETE FROM gd_ruid WHERE xid=:xid AND dbid=:dbid';
        DeleteRuid.Transaction := Transaction;
        UpdateRuid.SQL.Text := 'UPDATE gd_ruid SET modified=:modified WHERE xid=:xid AND dbid=:dbid';
        UpdateRuid.Transaction := Transaction;
        TempSQL.Transaction := Transaction;
        RecCount := 0;
        while Stream.Position < Stream.Size do
        begin
          // проверим тот ли поток нам подсунули для считывания из
          Stream.Read(I, SizeOf(I));
          if I <> $55443322 then
            raise EgdcException.CreateObj('Invalid stream format', Self);

          OldPos := Stream.Position;
          SetLength(stVersion, Length(cst_WithVersion));
          Stream.ReadBuffer(stVersion[1], Length(cst_WithVersion));
          if stVersion = cst_WithVersion then
          begin
            Stream.Read(stRecord.StreamVersion, SizeOf(stRecord.StreamVersion));
            if stRecord.StreamVersion >= 1 then
              Stream.Read(stRecord.StreamDBID, SizeOf(stRecord.StreamDBID));
          end else
          begin
            stRecord.StreamVersion := 0;
            stRecord.StreamDBID := -1;
            Stream.Position := OldPos;
          end;
          // загружаем класс и подтип сохраненного объекта
          LoadClassName := StreamReadString(Stream);
          LoadSubType := StreamReadString(Stream);

          //Считываем свойство ModifyFromStream
          //Для версии потока не ниже 2
          if stRecord.StreamVersion >= 2 then
          begin
            PrSet.LoadFromStream(Stream);
          end;

          C := GetClass(LoadClassName);

          if C = nil then
            raise EgdcException.CreateObj('Invalid class name', Self);

          if (Obj = nil) or (Obj.ClassType <> C) or (LoadSubType <> Obj.SubType) then
          begin
            Ind := ObjList.IndexOf(LoadClassName + '('+ LoadSubType + ')');
            if Ind = -1 then
            begin
              Obj := CgdcBase(C).CreateWithParams(nil,
                Database, Transaction, LoadSubType);
              Obj.ReadTransaction := Transaction;
              //Убираем рефреш
              Obj.SetRefreshSQLOn(False);
              ObjList.AddObject(LoadClassName + '('+ LoadSubType + ')', Obj);
              ObjList.Sort;
            end else
              Obj := TgdcBase(ObjList.Objects[Ind]);
          end;

          if Obj.SubSet <> 'ByID' then
            Obj.SubSet := 'ByID';
          Obj.Open;

           //Считываем свойство ModifyFromStream
          //Для версии потока не ниже 2
          if stRecord.StreamVersion >= 2 then
          begin
            for I := 0 to PrSet.Count - 1 do
            begin
              PropInfo := GetPropInfo(Obj.ClassInfo, PrSet.Name[I]);
              if (PropInfo <> nil) then
              begin
                SetPropValue(Obj, PrSet.Name[I], PrSet.Value[PrSet.Name[I]]);
              end;
            end;
          end;

            //За счет этого дополнительного метода исчезает рекурсия =>
            //меньше жрется память, работает быстрее в 10 раз
          Obj._LoadFromStreamInternal(Stream, IDMapping, ObjectSet, UpdateList, stRecord, AnAnswer, SelectRuid, DeleteRuid, UpdateRuid, TempSQL);
          inc(RecCount);

          if Assigned(frmSQLProcess) then
          begin
            frmSQLProcess.pb.Position := frmSQLProcess.pb.Position + 1;
          end;

          if ((RecCount mod 500) = 0) and DidActivate and Transaction.InTransaction then
          begin
            Transaction.Commit;
            RecCount := 0;
          end;

        end;
      finally
        FreeAndNil(TempSQL);
        FreeAndNil(SelectRuid);
        FreeAndNil(DeleteRuid);
        FreeAndNil(UpdateRuid);
      end;

      if DidActivate and Transaction.InTransaction then
        Transaction.Commit;

      Space;
      AddText(#13#10 + TimeToStr(Time) + ': Закончена загрузка данных из потока.'#13#10, clBlack, True);
      Space;

    except
      on E: Exception do
      begin
        if DidActivate and Transaction.InTransaction then
          Transaction.Rollback;
        AddMistake(E.Message, clRed);
        Space;
        raise;
      end;
    end;
  finally
    PrSet.Free;

    if IDMappingCreated then
      IDMapping.Free;

    if ULCreated then
      UpdateList.Free;

    for I := 0 to ObjList.Count - 1 do
    begin
      Obj := TgdcBase(ObjList.Objects[I]);
      ObjList.Objects[I] := nil;
      if Assigned(Obj) then
        FreeAndNil(Obj);
    end;
    ObjList.Free;
  end;
end;

procedure TgdcBase.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  if (Operation = Classes.opRemove) and (AComponent <> nil) then
  begin
    if AComponent = FInternalTransaction then
      FInternalTransaction := nil
    else if AComponent = MasterSource then
      MasterSource := nil
    else if AComponent = ReadTransaction then
      ReadTransaction := nil
    else if AComponent is TgdcBase then
      RemoveDetailLink(AComponent as TgdcBase);
  end;
  inherited;
end;

function TgdcBase.ParamByName(Idx: String): TIBXSQLVAR;
begin
  InternalPrepare;
  Result := QSelect.ParamByName(Idx);
end;

function TgdcBase.PasteFromClipboard(const ATestKeyboard: Boolean = False): Boolean;
var
  H: THandle;
  P: PgdcClipboardData;
begin
  Result := False;

  if not CanPasteFromClipboard then
    exit;

  H := Clipboard.GetAsHandle(gdcClipboardFormat);
  if H <> 0 then
  begin
    P := GlobalLock(H);
    try
      if (P <> nil)
        and (P^.Signature = gdcCurrentClipboardSignature)
        and (P^.Version = gdcCurrentClipboardVersion)
        and ((P^.ClassName = '') or (GetClass(P^.ClassName) <> nil))
      then begin
        if ATestKeyboard then
          P.Cut := not (GetAsyncKeyState(VK_CONTROL) < 0);

        if (P^.Obj <> nil) and (gdcObjectList.IndexOf(P^.Obj) = -1) then
          P^.Obj := nil;

        Result := AcceptClipboard(P);
      end;
    finally
      GlobalUnlock(H);
    end;
  end;
end;

class procedure TgdcBase.RefreshStats;
begin
  //...
end;

(*

  Сохранение сделаем следующим образом:
  1. создадим клиент датасет, взяв определение колонок из
     нашего датасета
  2. перенесем в него данные
  3. сохраним в поток
*)
procedure TgdcBase._SaveToStream(Stream: TStream; ObjectSet: TgdcObjectSet;
  PropertyList: TgdcPropertySets; BindedList: TgdcObjectSet;
  const SaveDetailObjects: Boolean = True);

const
  NotSavedField = ';CREATORKEY;EDITORKEY;';

  procedure StreamWriteString(St: TStream; const S: String);
  var
    L: Integer;
  begin
    L := Length(S);
    St.Write(L, SizeOf(L));
    if L > 0 then
      St.Write(S[1], L);
  end;

  procedure SaveBindedObjectsForTable(const ATableName: String; ReversedList: TgdcObjectSets);
  var
    R: TatRelation;
    I: Integer;
    Obj: TgdcBase;
    C: TgdcFullClass;
    OS: TgdcObjectSet;
  begin
    Assert(Assigned(ReversedList));

    // найдем все поля ссылки и запишем в поток
    // объекты на которые они ссылаются
    R := atDatabase.Relations.ByRelationName(ATableName);
    Assert(R <> nil);

    for I := 0 to R.RelationFields.Count - 1 do
    begin
      if AnsiPos(';' + Trim(R.RelationFields[I].FieldName) + ';', NotSavedField) > 0 then
        continue;

      if (FindField(R.RelationName, R.RelationFields[I].FieldName) = nil) or
          (FieldByName(R.RelationName, R.RelationFields[I].FieldName).IsNull) then
        continue;

      if R.RelationFields[I].gdClass <> nil then
      begin
        C.gdClass := CgdcBase(R.RelationFields[I].gdClass);
        C.SubType := R.RelationFields[I].gdSubType;
      end else
      begin
        C.gdClass := nil;
        C.SubType := '';
      end;

      if (C.gdClass = nil) and (R.RelationFields[I].References <> nil) then
        C := GetBaseClassForRelation(R.RelationFields[I].References.RelationName);

// смысл второго условия, недопустить зацикливания, когда в записи есть поле-ссылка
// на эту же запись
      if (C.gdClass <> nil) and
        ((C.gdClass <> Self.ClassType) or (FieldByName(R.RelationName, R.RelationFields[I].FieldName).AsInteger <> ID)) then
      begin
        if IsReverseOrder(FieldByName(R.RelationName, R.RelationFields[I].FieldName).FieldName) then
        begin
          OS := ReversedList.Find(C);
          if OS = nil then
          begin
            OS := TgdcObjectSet.Create(C.gdClass, C.SubType);
            ReversedList.Add(OS);
          end;
          OS.Add(FieldByName(R.RelationName, R.RelationFields[I].FieldName).AsInteger, C.gdClass.ClassName, C.SubType);
        end else begin
          Obj := C.gdClass.CreateSingularByID(nil,
              Database,
              Transaction,
              FieldByName(R.RelationName, R.RelationFields[I].FieldName).AsInteger,
              C.SubType);
          try
            Obj._SaveToStream(Stream, ObjectSet, PropertyList, BindedList, False);
          finally
            Obj.Free;
          end;
        end;
      end;
    end;
  end;

var
  RUID: TRUID;
  CDS: TClientDataSet;
  MS: TMemoryStream;
  ObjectSetCreated: Boolean;
  OL, DL: TObjectList;
  ReversedList: TgdcObjectSets;
  LinkTableList: TStringList;
  ibsql: TIBSQL;
  CurDBID: Integer;
  CurStrVersion: Integer;
  F: TField;
  C: TgdcFullClass;
  PropertyListIndex: Integer;
  PropInfo: PPropInfo;
  {$IFDEF DEBUG}Ch: array[0..255] of Char;{$ENDIF}


  procedure SaveToStreamCLDS(Obj: TgdcBase);
  var
    I, K: Integer;
    PrSets: TgdcPropertySet;
    PrList: TStringList;
  begin
    CDS := TClientDataSet.Create(nil);
    try
      for I := 0 to Obj.FieldDefs.Count - 1 do
      begin
        if (not (DB.faReadOnly in Obj.FieldDefs[I].Attributes))
          and (not Obj.FieldDefs[I].InternalCalcField) then
        begin
          //Последний параметр - false, т.к. возникает проблема с сохранением пустой строки
          //Interbase различает пустую строку и null,
          //а ClientDataset - нет
          CDS.FieldDefs.Add(Obj.FieldDefs[I].Name, Obj.FieldDefs[I].DataType,
            Obj.FieldDefs[I].Size, False);
        end;
      end;

      CDS.FieldDefs.Add('_XID', ftInteger, 0, True);
      CDS.FieldDefs.Add('_DBID', ftInteger, 0, True);
      CDS.FieldDefs.Add('_MODIFIED', ftDateTime, 0, True);

      CDS.CreateDataSet;

      CDS.Insert;
      for K := 0 to Obj.FieldCount - 1 do
      begin
        F := CDS.FindField(Obj.Fields[K].FieldName);
        if F <> nil then
        begin
          if AnsiPos(';' + F.FieldName + ';', NotSavedField) > 0 then
            F.Clear
          else
            F.Assign(Obj.Fields[K]);
        end;
      end;
      CDS.FieldByName('_XID').AsInteger := RUID.XID;
      CDS.FieldByName('_DBID').AsInteger := RUID.DBID;
      CDS.FieldByName('_MODIFIED').AsDateTime := EditionDate;
      CDS.Post;


      // запишем метку потока, чтобы потом знать то ли
      // нам подсунули для считывания
      I := $55443322;
      Stream.Write(I, SizeOf(I));

      //Добавлено 08.10.02 запись версии потока
      Stream.WriteBuffer(cst_WithVersion[1], Length(cst_WithVersion));
      CurStrVersion := cst_StreamVersion;
      Stream.Write(CurStrVersion, sizeof(CurStrVersion));
      //Добавлено 08.10.02 запись id БД
      //Версия потока не ниже 1
      CurDBID := IBLogin.DBID;
      Stream.Write(CurDBID, SizeOf(CurDBID));

      StreamWriteString(Stream, Obj.ClassName);
      StreamWriteString(Stream, Obj.SubType);

      //Версия потока не ниже 2
      PrSets := TgdcPropertySet.Create(RUIDToStr(Obj.GetRUID),
        CgdcBase(Obj.ClassType), Obj.SubType);
      PrList := TStringList.Create;
      try
        PrList.CommaText := Obj.GetPropertiesForStream(Obj.SubType);
        for I := 0 to PrList.Count - 1 do
        begin
          PropInfo := GetPropInfo(Obj.ClassInfo, PrList[I]);
          if (PropInfo <> nil) then
          begin
            PrSets.Add(PrList[I], GetPropValue(Obj, PrList[I], False));
          end;
        end;
        PrSets.SaveToStream(Stream);
      finally
        PrSets.Free;
        PrList.Free;
      end;

      MS := TMemoryStream.Create;
      try
        CDS.SaveToStream(MS);
        I := MS.Size;
        Stream.Write(I, SizeOf(I));
        Stream.CopyFrom(MS, 0);
      finally
        MS.Free;
      end;
    finally
      CDS.Free;
    end;
  end;

var
  I, J: Integer;
  Obj: TgdcBase;
  ObjectIDIndex: Integer;
  BaseClassList: TStringList;
  DidCreate: Boolean;
begin
  CheckBrowseMode;

  Assert(IBLogin <> nil);
  Assert(atDatabase <> nil);

  // если объект с заданным ИД уже сохранен в потоке,
  // то выходим, ничего не делая
  if ((ObjectSet <> nil) and (ObjectSet.Find(ID) <> -1)) or
    (Assigned(BindedList) and BindedList.FindgdClassByID(ID, ClassName, SubType)) then
    exit;

  LinkTableList := TStringList.Create;
  BaseClassList := TStringList.Create;
  BaseClassList.Sorted := True;

  ibsql := CreateReadIBSQL;

  if ObjectSet = nil then
  begin
    ObjectSet := TgdcObjectSet.Create(TgdcBase, '');
    ObjectSetCreated := True;
  end else
    ObjectSetCreated := False;

  ReversedList := TgdcObjectSets.Create;
  try
    // если текущая запись репрезентует объект другого
    // класса, то создадим экземпляр и вызовем его метод
    // сохранения в потоке
    C := GetCurrRecordClass;

    if (Self.ClassType <> C.gdClass) or (Self.SubType <> C.SubType) then
    begin
      try
        Obj := C.gdClass.CreateSingularByID(nil,
          Database, Transaction, ID, C.SubType);
        try
          Obj._SaveToStream(Stream, ObjectSet, PropertyList, BindedList, SaveDetailObjects);
        finally
          Obj.Free;
        end;
      except
        on E: Exception do
        begin
          if not (E is EAbort) then
            MessageBox(ParentHandle,
              PChar(Format('Нарушена целостность данных. '#13#10# +
              'Предполагаемая информация о типе объекта'#13#10# +
              'c идентификатором %d: %s (подтип: "%s")'#13#10# +
              'не соответствует действительности.'#13#10#13#10 +
              'Объект не будет сохранен.', [ID, C.gdClass.ClassName, C.SubType])),
              'Ошибка',
              MB_OK or MB_ICONEXCLAMATION);

          AddMistake(#13#10 + E.Message + #13#10, clRed);
          Space;
        end;
      end;
    end else
    begin
      {$IFDEF DEBUG}
      StrPCopy(Ch, ClassName + ' ' + IntToStr(GetTickCount));
      OutputDebugString(Ch);
      {$ENDIF}

      // сохраним все объекты на которые есть ссылки из
      // главной таблицы текущего объекта
      DidCreate := not Assigned(BindedList);
      if DidCreate then
        BindedList := TgdcObjectSet.Create(nil, '');
      try
        BindedList.Add(ID, ClassName, SubType);
        SaveBindedObjectsForTable(GetListTable(SubType), ReversedList);
      finally
        if DidCreate and Assigned(BindedList) then
          FreeAndNil(BindedList);
      end;

      // для избежания рекурсивного сохранения пометим
      // что мы начали сохранять объект с текущим идентификатором
      ObjectIDIndex := ObjectSet.Find(ID);
      if (ObjectIDIndex <> -1) then
        exit;
      ObjectIDIndex := ObjectSet.Add(ID, ClassName, SubType);
      if Assigned(PropertyList) then
      begin
        PropertyListIndex := PropertyList.IndexOf(RUIDToStr(Self.GetRUID));
        if PropertyListIndex > -1 then
          for I := 0 to PropertyList.Objects[PropertyListIndex].Count - 1 do
          begin
            PropInfo := GetPropInfo(Self.ClassInfo,
              PropertyList.Objects[PropertyListIndex].Name[I]);
            if (PropInfo <> nil) then
            begin
              SetPropValue(Self, PropertyList.Objects[PropertyListIndex].Name[I],
                PropertyList.Objects[PropertyListIndex].Value[
                  PropertyList.Objects[PropertyListIndex].Name[I]]);
            end;
          end;
      end;

      AddText(#13#10 + 'Сохранение объекта ' + GetDisplayName(GetSubType) + ' ' +
        FieldByName(GetListField(SubType)).AsString + #13#10 +
        ' (с идентификатором  ' + FieldByName(GetKeyField(SubType)).AsString + ')'#13#10,
        clBlue);
      Space;

      // теперь найдем все таблицы, первичный ключ которых одновременно
      // является ссылкой на нашу запись, т.е. таблицы связанные
      // жесткой связью один-к-одному с нашей таблицей
      // записи в таких таблицах, в совокупности с записью в главной
      // таблице, представляют данные одного объекта
      // пример: gd_contact -- gd_company -- gd_companycode
      OL := TObjectList.Create(False);
      try
        atDatabase.ForeignKeys.ConstraintsByReferencedRelation(
          GetListTable(SubType), OL);
        for I := 0 to OL.Count - 1 do
          with OL[I] as TatForeignKey do
        begin
          if IsSimpleKey
            and (Relation.PrimaryKey <> nil)
            and (Relation.PrimaryKey.ConstraintFields.Count = 1)
            and (ConstraintField = Relation.PrimaryKey.ConstraintFields[0]) then
          begin
            LinkTableList.Add(Relation.RelationName);
            SaveBindedObjectsForTable(Relation.RelationName, ReversedList);
          end;
        end;
      finally
        OL.Free;
      end;

      RUID := GetRUID;

     //сохраним поля объекта в поток
      SaveToStreamCLDS(Self);

      Obj := nil;
      C := GetBaseClassForRelation(GetListTable(GetSubType));
      BaseClassList.Clear;
      BaseClassList.Add(C.gdClass.ClassName + '(' + C.SubType + ')');
      try
        for I := 0 to LinkTableList.Count - 1 do
        begin
          //Если среди таблиц, которые ссылаются на наш объект один к одному
          //есть пользовательские таблицы, то их данные сохраним отдельно
          //Здесь получается интересная ситуация - на один ID - несколько объектов:
          //основной (главный объект) и объекты
          //с ключевым полем, которое ссылается на основной объект
          C := GetBaseClassForRelation(LinkTableList[I]);

          if Assigned(C.gdClass) and
            (BaseClassList.IndexOf(C.gdClass.ClassName + '(' + C.SubType + ')') = -1)
          then
          begin
            BaseClassList.Add(C.gdClass.ClassName + '(' + C.SubType + ')');
            if (Obj = nil) or (Obj.ClassType <> C.gdClass) or (Obj.SubType <> C.SubType) then
            begin
              if Assigned(Obj) then
                FreeAndNil(Obj);
              Obj := C.gdClass.CreateSubType(nil, C.SubType, 'ByID');
            end;
            Obj.Close;
            Obj.Transaction := Transaction;
            Obj.ID := ID;
            Obj.Open;
            if Obj.RecordCount > 0 then
            begin
              C := Obj.GetCurrRecordClass;

              while Assigned(C.gdClass) and ((Obj.ClassType <> C.gdClass) or (Obj.SubType <> C.SubType)) do
              begin
                FreeAndNil(Obj);
                Obj := C.gdClass.CreateSubType(nil, C.SubType, 'ByID');
                Obj.Transaction := Transaction;
                Obj.ID := ID;
                Obj.Open;
                C := Obj.GetCurrRecordClass;
              end;

              if Assigned(C.gdClass) and
                (not ObjectSet.FindgdClass(ObjectIDIndex, C.gdClass.ClassName, C.SubType)) then
              begin
                if Obj.RecordCount > 0 then
                begin
                  Space;
                  AddText(#13#10 + 'Сохранение объекта ' + Obj.GetDisplayName(Obj.GetSubType) + ' ' +
                    Obj.FieldByName(Obj.GetListField(Obj.SubType)).AsString + #13#10 +
                    ' (с идентификатором  ' + Obj.FieldByName(Obj.GetKeyField(Obj.SubType)).AsString + ')'#13#10,
                    clBlue);
                  SaveToStreamCLDS(Obj);
                  ObjectIDIndex := ObjectSet.Add(Obj.ID, Obj.ClassName, Obj.SubType);
                end;
              end;
            end;
          end;
        end;
      finally
        if Assigned(Obj) then
          FreeAndNil(Obj);
      end;


      for I := 0 to ReversedList.Count - 1 do
      begin
        for J := 0 to (ReversedList[I] as TgdcObjectSet).Count - 1 do
        begin
          Obj := (ReversedList[I] as TgdcObjectSet).gdClass.CreateSingularByID(nil,
            Database, Transaction,
            (ReversedList[I] as TgdcObjectSet).Items[J],
            (ReversedList[I] as TgdcObjectSet).SubType);
          try
            Obj._SaveToStream(Stream, ObjectSet, PropertyList, BindedList, SaveDetailObjects);
          finally
            Obj.Free;
          end;
        end;
      end;

      // теперь надо сохранить все детальные объекты
      // детальный объект мы создаем следующим образом:
      // 1. строим список фореин ключей, ссылающихся на нашу таблицу
      // !!!!! и на связанные с ней таблицы
      // 2. из списка берем только те ключи, которые состоят из
      //    одного поля и тип домена которых
      //    DMASTERKEY
      // 3. находим базовые классы для таблиц, для которых
      //    созданы эти ключи
      // 4. создаем экземпляры объектов по найденным классам
      // 5. устанавливаем дополнительное условие: ссылка на
      //    мастер запись
      // 6. открываем датасет с примененным условием
      // 7. сохраняем все его записи в потоке
      if SaveDetailObjects then
      begin
        DL := TObjectList.Create(False);
        try
          atDatabase.ForeignKeys.ConstraintsByReferencedRelation(
            GetListTable(SubType), DL, True);
          //Добавим все ключи по таблицам находящимся в связи 1:1
          //к главной таблице
          for I := 0 to LinkTableList.Count - 1 do
            atDatabase.ForeignKeys.ConstraintsByReferencedRelation(
              LinkTableList[I], DL, False);

          for I := 0 to DL.Count - 1 do
          begin
            if TatForeignKey(DL[I]).IsSimpleKey and
              (TatForeignKey(DL[I]).ConstraintField.Field.FieldName = 'DMASTERKEY') then
            begin
              ibsql.Close;
              //Мы не проверяем наши таблицы на простой
              //первичный ключ, т.к. в список могли попасть
              //только такие таблицы
              ibsql.SQL.Text := Format('SELECT %s FROM %s WHERE %s = %s ',
                [TatForeignKey(DL[I]).Relation.PrimaryKey.ConstraintFields[0].FieldName,
                TatForeignKey(DL[I]).Relation.RelationName,
                TatForeignKey(DL[I]).ConstraintField.FieldName,
                FieldByName(GetKeyField(SubType)).AsString]);
              ibsql.ExecQuery;
              if ibsql.RecordCount > 0 then
              begin
                //Находим базовый класс
                C := GetBaseClassForRelation(TatForeignKey(DL[I]).Relation.RelationName);
                if C.gdClass <> nil then
                begin
                  //Создаем его экземпляр с одной записью
                  Obj := C.gdClass.CreateSubType(nil, C.SubType, 'ByID');
                  try
                    Obj.Transaction := Transaction;
                    while not ibsql.Eof do
                    begin
                      Obj.ID := ibsql.Fields[0].AsInteger;  
                      Obj.Open;
                      if Obj.RecordCount > 0 then
                        Obj._SaveToStream(Stream, ObjectSet, PropertyList, BindedList, SaveDetailObjects);
                      ibsql.Next;  
                    end;
                  finally
                    Obj.Free;
                  end;
                end;
              end;
            end;
          end;
        finally
          DL.Free;
        end;
      end;
    end;
  finally
    ReversedList.Free;
    LinkTableList.Free;
    BaseClassList.Free;
    ibsql.Free;

    if ObjectSetCreated then
      ObjectSet.Free;
  end;
end;

procedure TgdcBase.SetDetailField(const Value: String);
begin
  if FgdcDataLink <> nil then
    FgdcDataLink.DetailField := Value;
end;

procedure TgdcBase.SetID(const Value: Integer);
begin
  Assert(Value >= -1, 'Invalid id specified');
  if Value = -1 then
  begin
    Close;
    FID := -1;
  end else
  begin
    if State in dsEditModes then
    begin
      FieldByName(GetKeyField(SubType)).AsInteger := Value;
    end
    else if State = dsInactive then
    begin
      FID := Value;
    end
    else if HasSubSet('ByID') then
    begin
      Close;
      FID := Value;
      Open;
    end else
      if not Locate(GetKeyField(SubType), Value, []) then
        raise EgdcException.CreateObj('Invalid id specified', Self);
  end;
end;

procedure TgdcBase.SetMasterField(const Value: String);
begin
  if FgdcDataLink <> nil then
    FgdcDataLink.MasterField := Value;
end;

procedure TgdcBase.SetMasterSource(Value: TDataSource);
var
  isActive: Boolean;
begin
  if IsLinkedTo(Value) then
    IBError(ibxeCircularReference, [nil]);

  if (FgdcDataLink <> nil) and (MasterSource <> Value) then
  begin
    if FgdcDataLink.DataSet is TgdcBase then
      (FgdcDataLink.DataSet as TgdcBase).RemoveDetailLink(Self);

    FgdcDataLink.DataSource := Value;
    FgdcDataLink.FLinkEstablished := False;

    if Assigned(MasterSource) and (MasterSource.DataSet is TIBCustomDataSet) then
    begin
      Transaction := (MasterSource.DataSet as TIBCustomDataSet).Transaction;
      ReadTransaction := (MasterSource.DataSet as TIBCustomDataSet).ReadTransaction;
    end else
    begin
      { TODO : 
может быть вообще не трогать объект при присваивании
MasterSource = nil? не трогать ни транзакции, ни состояние
объекта. }
      if not (State in dsEditModes) then
      begin
        isActive := Active;
        Close;
        Transaction := FInternalTransaction;
        if Assigned(gdcBaseManager) then
          ReadTransaction := gdcBaseManager.ReadTransaction
        else
          ReadTransaction := nil;
        Active := isActive;
      end;  
    end;

    if FgdcDataLink.DataSet is TgdcBase then
      (FgdcDataLink.DataSet as TgdcBase).AddDetailLink(Self);

    {for I := 0 to FDetailLinks.Count - 1 do
    begin
      if FDetailLinks[I] is TgdcBase then
      begin
        MS := TgdcBase(FDetailLinks[I]).MasterSource;
        if MS <> nil then
        begin
          TgdcBase(FDetailLinks[I]).MasterSource := nil;
          TgdcBase(FDetailLinks[I]).MasterSource := MS;
        end;
      end;
    end;}
  end;
end;

{ TgdcDataLink }

procedure TgdcDataLink.ActiveChanged;
begin
  FTimer.Enabled := False;
  if DataSet = nil then
    FLinkEstablished := False
  else if (FMasterField.Count > 0) and (FDetailField.Count > 0) then
    if not DataSet.Active then
      FDetailObject.Close
    else begin
      if not FLinkEstablished then
      begin
        if (DataSet is TIBCustomDataSet) then
        begin
          if (FDetailObject.Transaction = nil) or (FDetailObject.Transaction = FDetailObject.FInternalTransaction) then
          begin
            { TODO : не ошибка ли это, если сюда мы придем с открытым датасетом? }
            FDetailObject.Close;
            FDetailObject.Transaction := (DataSet as TIBCustomDataSet).Transaction;
          end;

          if (FDetailObject.ReadTransaction = nil) or (FDetailObject.ReadTransaction <> (DataSet as TIBCustomDataSet).ReadTransaction) then
          begin
            { TODO : не ошибка ли это, если сюда мы придем с открытым датасетом? }
            FDetailObject.Close;
            FDetailObject.ReadTransaction := (DataSet as TIBCustomDataSet).ReadTransaction;
          end;
        end;

        if DataSet is TgdcBase then
          (DataSet as TgdcBase).AddDetailLink(FDetailObject);

        FLinkEstablished := True;
      end;

      if FDetailObject.Active then
        FDetailObject.RefreshParams
      else
        FDetailObject.Open;
    end;
end;

procedure TgdcDataLink.CheckBrowseMode;
begin
  {if FDetailObject.Active then
    FDetailObject.CheckBrowseMode;}
end;

constructor TgdcDataLink.Create(ADetailObject: TgdcBase);
begin
  inherited Create;
  FDetailObject := ADetailObject;
  FTimer := TTimer.Create(nil);
  FTimer.Enabled := False;
  FTimer.Interval := 0; {60}
  FTimer.OnTimer := DoOnTimer;
  FMasterField := TStringList.Create;
  FDetailField := TStringList.Create;
  FLinkEstablished := False;
end;

destructor TgdcDataLink.Destroy;
begin
  FTimer.Free;
  if DataSet is TgdcBase then
    (DataSet as TgdcBase).RemoveDetailLink(FDetailObject);
  FDetailObject.FgdcDataLink := nil;
  FMasterField.Free;
  FDetailField.Free;
  inherited;
end;

procedure TgdcDataLink.DoOnTimer(Sender: TObject);
begin
  if FTimer.Enabled then
  begin
    FTimer.Enabled := False;
    if FDetailObject.Active then
      FDetailObject.RefreshParams;
  end;
end;

procedure TgdcDataLink.EditingChanged;
begin
  FTimer.Enabled := False;
  if (DataSet <> nil) and (DataSet.State in dsEditModes) then
  begin
    if FDetailObject.State in dsEditModes then
    begin
      if (DataSet as TgdcBase).FIgnoreDataSet.IndexOf(FDetailObject) = -1 then
        FDetailObject.Post;
    end;
  end;  
end;

function TgdcDataLink.GetDetailField: String;
begin
  Result := StringReplace(FDetailField.CommaText, ',', ';', [rfReplaceAll]);
end;

function TgdcDataLink.GetMasterField: String;
begin
  Result := StringReplace(FMasterField.CommaText, ',', ';', [rfReplaceAll]);
end;

procedure TgdcDataLink.RecordChanged(F: TField);
begin
  if ((F = nil) {or (FMasterField.IndexOf(F.FieldName) <> -1)})
    and FDetailObject.Active then
  begin
    if (FTimer.Interval = 0)
      or (not (sView in FDetailObject.BaseState))
      or (sDialog in FDetailObject.BaseState)
      or (sLoadFromStream in FDetailObject.BaseState) then
    begin
      if (DataSet as TgdcBase).FIgnoreDataSet.IndexOf(FDetailObject) = -1 then
        FDetailObject.RefreshParams;
    end else begin
      FTimer.Enabled := False;
      FTimer.Enabled := True;
    end;
  end;
end;

(*procedure TgdcDataLink.RefreshParams(const AnyWay: Boolean);
var
  Master, Detail: TStringList;
  I: Integer;
  ParamsChanged: Boolean;

begin
  if (DataSet = nil)
    or (not DataSet.Active)
    or (FDetailObject = nil)
    {or (not FgdcObject.Active)} then exit;

  Master := TStringList.Create;
  Detail := TStringList.Create;

  //FgdcObject.DisableControls;
  try
    MakeFieldList(FMasterField, Master);
    MakeFieldList(FDetailField, Detail);

    ParamsChanged := False;

    if not AnyWay then
      for I := 0 to Master.Count - 1 do
        if DataSet.FieldByName(Master[I]).AsString <>
          FDetailObject.ParamByName(Detail[I]).AsString then
        begin
          ParamsChanged := True;
          Break;
        end;

    if AnyWay or ParamsChanged then
    begin
      FDetailObject.Close;

      //
      // Присваиваем соответствующее подключение
      //  и транзакцию

      { TODO :
тут вопрос. правильнее все эти манипуляции с транзакциями делать
по присваиванию мастер обжекта а не тут... }
      {if not Assigned(FgdcObject.Transaction) and (DataSet is TgdcBase) then
        FgdcObject.Transaction := (DataSet as TgdcBase).Transaction else

      if (DataSet is TgdcBase) and
        (FgdcObject.Transaction = FgdcObject.FInternalTransaction) then
      begin
        FreeAndNil(FgdcObject.FInternalTransaction);
        FgdcObject.Transaction := (DataSet as TgdcBase).Transaction;
      end;

      if not Assigned(FgdcObject.Database) and (DataSet is TgdcBase) then
        FgdcObject.Database := (DataSet as TgdcBase).Database;}

      //
      // Устанавливаем параметры

      for I := 0 to Master.Count - 1 do
        if not DataSet.FieldByName(Master[I]).IsNull then
          FDetailObject.ParamByName(Detail[I]).AsString :=
              DataSet.FieldByName(Master[I]).AsString
        else
          FDetailObject.ParamByName(Detail[I]).Clear;

      FDetailObject.Open;
    end;
  finally
    Master.Free;
    Detail.Free;

    //FgdcObject.EnableControls;
  end;
end;*)

procedure TgdcDataLink.SetDetailField(const Value: String);
begin
  FDetailField.CommaText := StringReplace(Value, ';', ',', [rfReplaceAll]);
end;

procedure TgdcDataLink.SetMasterField(const Value: String);
begin
  FMasterField.CommaText := StringReplace(Value, ';', ',', [rfReplaceAll]);
end;

{ TgdcBaseManager }

function TgdcBaseManager.AdjustMetaName(const S: String): String;
var
  Tmp, S1: String;
begin
  //Мы будем работать только с прописными буквами в названиях мета-данных
  //Данная функция может вернуть различные результаты при различных регистрах
  S1 := AnsiUpperCase(S);

  if Length(S1) < 32 then
    Result := S1
  else begin
    Tmp := IntToStr(Crc32_P(@S1[1], Length(S1), 0));
    Result := Copy(S1, 1, 31 - Length(Tmp)) + Tmp;
  end;
end;

constructor TgdcBaseManager.Create(AnOwner: TComponent);
begin
  Assert(gdcBaseManager = nil, 'Only one instance of gdcBaseManager is allowed');
  inherited Create(AnOwner);
  FIBBase := TIBBase.Create(Self);
  FReadTransaction := TIBTransaction.Create(nil);
  FReadTransaction.Params.Text := 'read_committed'#13#10'rec_version'#13#10'nowait'#13#10'read'#13#10;
  FReadTransaction.Name := 'InternalRead';
  FReadTransaction.AutoStopAction := saNone;
  gdcBaseManager := Self;
end;

destructor TgdcBaseManager.Destroy;
begin
  gdcBaseManager := nil;
  if Assigned(FReadTransaction) and FReadTransaction.InTransaction then
    FReadTransaction.Commit;

  FreeAndNil(FReadTransaction);
  FreeAndNil(FIBBase);
  FNextIDSQL.Free;
  inherited;
end;

function TgdcBaseManager.GenerateNewDBID: Integer;
var
  D: TDateTime;
begin
  { TODO : перепроверить! }
  D := Abs(Now - EncodeDate(2003, 08, 06));
  while D > 10 * 365 do
    D := D / (10 * 365);
  Result := Round(D * 24 * 60 * 60 * 6.8) + 2000;
end;

function TgdcBaseManager.GetDatabase: TIBDatabase;
begin
  if Assigned(FIBBase) then
    Result := FIBBase.Database
  else
    Result := nil;
end;

function TgdcBaseManager.GetExplorer: IgdcBase;
begin
  Result := FExplorer;
end;

procedure TgdcBaseManager.GetFullRUIDByID(const ID: TID; out XID,
  DBID: TID);
begin
  Assert(IBLogin <> nil, 'Необходимо подключение к базе!');
  GetRUIDByID(ID, XID, DBID);
  if (XID = -1) and (DBID = -1) then
  begin
    XID := ID;
    if ID < cstUserIDStart then
      DBID := cstEtalonDBID
    else
      DBID := IBLogin.DBID;
  end;
end;

function TgdcBaseManager.GetIDByRUID(const XID, DBID: TID): TID;
var
  q: TIBSQL;
  DidActivate: Boolean;
  I: Integer;
  S: String;
begin
  if (XID = -1) and (DBID = -1) then
  begin
    Result := -1;
  end else
  begin
    if not Assigned(CacheList) then
    begin
      CacheList := TStringList.Create;
      CacheList.Sorted := True;
      CacheList.Duplicates := dupError;
    end;

    if Assigned(IBLogin) and (IBLogin.DBID <> CacheDBID) then
    begin
      CacheList.Clear;
      CacheDBID := IBLogin.DBID;
    end;

    S := IntToStr(XID - cstUserIDStart) + '.' + IntToStr(DBID);
    I := CacheList.IndexOf(S);

    if I <> -1 then
    begin
      Result := TID(CacheList.Objects[I]);
    end else
    begin
      q := TIBSQL.Create(Self);
      try
        q.Transaction := ReadTransaction;
        if not q.Transaction.Active then
        begin
          q.Transaction.StartTransaction;
          DidActivate := True;
        end else
          DidActivate := False;
        try
          q.SQL.Text := 'SELECT id FROM gd_ruid WHERE xid=' + IntToStr(XID) +
            ' AND dbid=' + IntToStr(DBID);
          q.ExecQuery;
          if q.EOF then
          begin
            //Возможно РУИД еще не попал в таблицу
            if IBLogin.DBID = DBID then
              Result := XID
            else
              Result := -1;
          end else
          begin
            Result := q.Fields[0].AsInteger;
            CacheList.AddObject(S, Pointer(Result));
          end;
          q.Close;
        finally
          if DidActivate then
            q.Transaction.Commit;
        end;
      finally
        q.Free;
      end;
    end;
  end;
end;

function TgdcBaseManager.GetIDByRUIDString(const RUID: TRUIDString): TID;
var
  R: TRUID;
begin
  R := StrToRUID(RUID);
  Result := GetIDByRUID(R.XID, R.DBID);
end;

function TgdcBaseManager.GetNextID: TID;
var
  DidActivate: Boolean;
begin
  if FNextIDSQL = nil then
  begin
    FNextIDSQL := TIBSQL.Create(nil);
    FNextIDSQL.Database := Database;
    FNextIDSQL.Transaction := ReadTransaction;
    FNextIDSQL.SQL.Text := 'SELECT GEN_ID(gd_g_unique, 1) + GEN_ID(gd_g_offset, 0) FROM rdb$database';
  end;

  DidActivate := False;
  try
    DidActivate := not ReadTransaction.InTransaction;
    if DidActivate then
      ReadTransaction.StartTransaction;
    FNextIDSQL.ExecQuery;
    Result := FNextIDSQL.Fields[0].AsInteger;
    FNextIDSQL.Close;
  finally
    if DidActivate then
      ReadTransaction.Commit;
  end;
end;

function TgdcBaseManager.GetReadTransaction: TIBTransaction;
begin
  if (not FReadTransaction.InTransaction) and Assigned(FReadTransaction.DefaultDatabase)
    and (FReadTransaction.DefaultDatabase.Connected) then
    FReadTransaction.StartTransaction;

  Result := FReadTransaction;
end;

procedure TgdcBaseManager.GetRUIDByID(const ID: TID; out XID, DBID: TID);
var
  q: TIBSQL;
  DidActivate: Boolean;
  Tr: TIBTransaction;
begin
  if ID = -1 then
  begin
    XID := -1;
    DBID := -1;
  end else
  begin
    q := TIBSQL.Create(Self);
    try
      q.Transaction := ReadTransaction;

      if not ReadTransaction.InTransaction then
      begin
        ReadTransaction.StartTransaction;
        DidActivate := True;
      end else
        DidActivate := False;

      try
        q.SQL.Text := 'SELECT xid, dbid FROM gd_ruid WHERE id=' + IntToStr(ID);
        q.ExecQuery;
        if q.EOF then
        begin

          q.Close;

          Tr := TIBTransaction.Create(nil);
          try
            Tr.DefaultDatabase := gdcBaseManager.Database;
            q.Transaction := Tr;

            Tr.StartTransaction;

            q.SQL.Text := 'INSERT INTO gd_ruid (id, xid, dbid, modified, editorkey) ' +
              'VALUES (:id, :xid, :dbid, CURRENT_TIMESTAMP, :editorkey) ';
            q.ParamByName('id').AsInteger := ID;
            XID := ID;
            q.ParamByName('xid').AsInteger := XID;
            if ID < cstUserIDStart then
              DBID := cstEtalonDBID
            else
              DBID := IBLogin.DBID;
            q.ParamByName('dbid').AsInteger := DBID;
            q.ParamByName('editorkey').AsInteger := IBLogin.ContactKey;
            q.ExecQuery;

            q.Close;
            Tr.Commit;

          finally
            Tr.Free;
          end;

        end else
        begin
          XID := q.Fields[0].AsInteger;
          DBID := q.Fields[1].AsInteger;
        end;
        q.Close;
      finally
        if DidActivate then
          ReadTransaction.Commit;
      end;
    finally
      q.Free;
    end;
  end;
end;

function TgdcBaseManager.GetRUIDStringByID(const ID: TID): TRUIDString;
var
  RUID: TRUID;
begin
  GetRUIDByID(ID, RUID.XID, RUID.DBID);
  Result := RUIDToStr(RUID);
end;

procedure TgdcBaseManager.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if Operation = Classes.opRemove then
  begin
    if AComponent = Database then
      Database := nil;
    if AComponent = FExplorer then
      FExplorer := nil;
    if AComponent = FReadTransaction then
      raise Exception.Create(GetGsException(Self, 'Cannot delete global read transaction'));
  end;
end;

function TgdcBase.GetRUID: TRUID;
var
  q: TIBSQL;
  RuidDBID: Integer;
  DidActivate: Boolean;
begin
{ TODO : для ускорения может создавать и подготавливать СКЛ заранее? }
  q := TIBSQL.Create(nil);
  try
    if Transaction.InTransaction then
      q.Transaction := Transaction
    else
      q.Transaction := ReadTransaction; { TODO : подразумеваем что реадтранзакция открыта всегда?? }

    q.SQL.Text := 'SELECT xid, dbid FROM gd_ruid WHERE id=' + IntToStr(ID);
    q.ExecQuery;

    if not q.EOF then
    begin
      Result.XID := q.Fields[0].AsInteger;
      Result.DBID := q.Fields[1].AsInteger;
    end else
    begin
      q.Close;
      if q.Transaction = ReadTransaction then
      begin
        q.Transaction := Transaction;
      end;
      DidActivate := not q.Transaction.InTransaction;
      if DidActivate then
        q.Transaction.StartTransaction;
      q.SQL.Text := 'INSERT INTO gd_ruid (id, xid, dbid, modified, editorkey) ' +
        'VALUES (:id, :xid, :dbid, CURRENT_TIMESTAMP, :editorkey) ';
      q.ParamByName('id').AsInteger := ID;
      q.ParamByName('xid').AsInteger := ID;
      if ID < cstUserIDStart then
        RuidDBID := cstEtalonDBID
      else
        RuidDBID := IBLogin.DBID;
      q.ParamByName('dbid').AsInteger := RuidDBID;
      q.ParamByName('editorkey').AsInteger := IBLogin.ContactKey;
      q.ExecQuery;
      if DidActivate then
        q.Transaction.Commit;

      Result.XID := ID;
      Result.DBID := RuidDBID;

      { TODO :
во-первых эдитор кей надо брать из таблицы. во-вторых могут быть разные ДБИД,
если в другом месте программы будет ошибка... }
    end;
    q.Close;
  finally
    q.Free;
  end;
end;

procedure TgdcBaseManager.PackStream(SourceStream, DestStream: TStream; CompressionLevel: TZCompressionLevel);
var
  Z: TZCompressionStream;
begin
  Z := TZCompressionStream.Create(DestStream, CompressionLevel);
  try
    DestStream.CopyFrom(SourceStream, 0)
  finally
    Z.Free
  end
end;

function TgdcBaseManager.ProcessSQL(const S: String): String;
var
  I, K, J: Integer;
  XID, DBID, ID: TID;
  Tmp: String;
begin
  Result := S;
  I := 0;
  repeat
    if I > 0 then
    begin
      K := StrIPos('XID', Copy(Result, I + 6, 255));
      if K = 0 then
        raise EgdcBaseManager.Create('Invalid RUID data.');
      J := I + 6 + K + 4;
      Tmp := '';
      while (J < Length(Result)) and (Result[J] in ['0'..'9', '"', '=', ' ']) do
      begin
        if Result[J] in ['0'..'9'] then
          Tmp := Tmp + Result[J];
        Inc(J);
      end;
      XID := StrToIntDef(Tmp, -1);
      if XID = -1 then
        raise EgdcBaseManager.Create('Invalid RUID data.');

      K := StrIPos('DBID', Copy(Result, J, 255));
      if K = 0 then
        raise EgdcBaseManager.Create('Invalid RUID data.');
      J := J + K + 5;
      Tmp := '';
      while (J < Length(Result)) and (Result[J] in ['0'..'9', '"', '=', ' ']) do
      begin
        if Result[J] in ['0'..'9'] then
          Tmp := Tmp + Result[J];
        Inc(J);
      end;
      DBID := StrToIntDef(Tmp, -1);
      if DBID = -1 then
        raise EgdcBaseManager.Create('Invalid RUID data.');

      K := Pos('/>', Copy(Result, J, 255));
      if K = 0 then
        raise EgdcBaseManager.Create('Invalid RUID data.');

      ID := GetIDByRUID(XID, DBID);
      if ID = -1 then
        raise EgdcBaseManager.Create('Unknown RUID.');

      Delete(Result, I, J + K - I + 1);
      Insert(IntToStr(ID), Result, I);
    end;
    I := StrIPos('<RUID ', Result);
  until I = 0;

  I := 0;
  repeat
    if I > 0 then
    begin
      Delete(Result, I, Length('<INGROUP/>'));
      Insert(IntToStr(IBLogin.InGroup), Result, I); 
    end;
    I := StrIPos('<INGROUP/>', Result);
  until I = 0;

  I := 0;
  repeat
    if I > 0 then
    begin
      Delete(Result, I, Length('<COMPANYKEY/>'));
      Insert(IntToStr(IBLogin.CompanyKey), Result, I);
    end;
    I := StrIPos('<COMPANYKEY/>', Result);
  until I = 0;

  I := 0;
  repeat
    if I > 0 then
    begin
      Delete(Result, I, Length('<CONTACTKEY/>'));
      Insert(IntToStr(IBLogin.ContactKey), Result, I);
    end;
    I := StrIPos('<CONTACTKEY/>', Result);
  until I = 0;
end;

procedure TgdcBaseManager.SetDatabase(const Value: TIBDatabase);
begin
  if (Database <> Value) and Assigned(FIBBase) and Assigned(FReadTransaction) then
  begin
    FIBBase.Database := Value;
    FReadTransaction.DefaultDatabase := Value;
    //InitObjects;
  end;
end;

class function TgdcBase.CreateViewForm(AnOwner: TComponent;
  const AClassName: String = ''; const ASubType: String = '';
  const ANewInstance: Boolean = False): TForm;
var
  C: TPersistentClass;
begin
  if not Class_TestUserRights([tiAFull, tiAChag, tiAView], ASubType) then
    raise EgdcUserHaventRights.Create('Нет прав для открытия формы.');

  C := GetClass(AClassName);
  if C = nil then
    C := GetClass(GetViewFormClassName(ASubType));
  if (C <> nil) and C.InheritsFrom(TgdcCreateableForm) then
  begin
    Result := CgdcCreateableForm(C).FindForm(CgdcCreateableForm(C), ASubType);
    if (Result = nil) or ANewInstance then
      Result := CgdcCreateableForm(C).CreateSubType(AnOwner, ASubType);
  end else
    Result := nil;
end;

procedure TgdcBase.SetSubSet(const Value: TgdcSubSet);
var
  I: Integer;
begin
  if not (csLoading in ComponentState) then
    Close;
  if (csDesigning in ComponentState) then
    FSubSets.CommaText := Value
  else if SubSet <> Value then
  begin
    FSubSets.CommaText := Value;
    if FSubSets.Count = 0 then
      raise EgdcException.CreateObj(Format('Invalid subset "%s" specified.', [Value]), Self);
    for I := 0 to FSubSets.Count - 1 do
      if not CheckSubSet(FSubSets[I]) then
        raise EgdcException.CreateObj(Format('Invalid subset "%s" specified.', [Value]), Self);
    UniDirectional := HasSubSet('ByID');
    if HasSubSet('All') then
      BufferChunks := 200
    else if HasSubSet('ByName') then
      BufferChunks := 10
    else
      BufferChunks := 100;
    FSQLInitialized := False;
  end;
end;

function TgdcBase.CheckSubSet(const ASubSet: String): Boolean;
begin
  Result := Pos(';' + ASubSet + ';', ';' + GetSubSetList) > 0;
end;

// Слияние
function TgdcBase.Reduction(BL: TBookmarkList): Boolean;
var
  FgsDBReduction: TgsDBReductionWizard;
  C: TClass;
  S: String;
  DidActivate: Boolean;
begin
  DidActivate := False;
  FgsDBReduction := TgsDBReductionWizard.Create(Self);
  try
    DidActivate := ActivateTransaction;
    if not Assigned(FgsDBReduction) then
      FgsDBReduction := TgsDBReductionWizard.Create(Self);

    FgsDBReduction.Database := DataBase;
    FgsDBReduction.Transaction := Transaction;

    FgsDBReduction.Table := GetReductionTable;
    FgsDBReduction.MainTable := GetListTable(SubType);
    FgsDBReduction.KeyField := GetKeyField(SubType);
    FgsDBReduction.ListField := GetListField(SubType);
    FgsDBReduction.AddCondition := GetReductionCondition;

    if Assigned(BL) then
      BL.Refresh;

    if (BL = nil) or (BL.Count <= 1) then
      FgsDBReduction.CondemnedKey := IntToStr(ID)
    else begin
      FgsDBReduction.CondemnedKey := IntToStr(GetIDForBookmark(BL[0]));
      FgsDBReduction.MasterKey := IntToStr(GetIDForBookmark(BL[1]));
    end;

    C := GetCurrRecordClass.gdClass;

    if C <> nil then
      S := C.ClassName
    else
      S := '';

    Result := FgsDBReduction.Wizard(S, SubType);
  finally
    if DidActivate then
      Transaction.Commit;
    FgsDBReduction.Free;
  end;
end;

function TgdcBase.GetCurrRecordClass: TgdcFullClass;
begin
  Result.gdClass := CgdcBase(Self.ClassType);
  Result.SubType := SubType;
end;

function TgdcBase.GetNameInScript: String;
begin
  if FNameInScript > '' then
    Result := FNameInScript
  else
    Result := Name;
end;

function TgdcBase.CreateDescendant: Boolean;
begin
  Result := CreateDialog(QueryDescendant);
end;

function TgdcBase.CreateDialog(C: CgdcBase): Boolean;
begin
  Result := CreateDialog(MakeFullClass(C, ''));
end;

function TgdcBase.CreateDialog(C: TgdcFullClass): Boolean;
var
  Obj: TgdcBase;
  I: Integer;
  F: TField;
begin
  if C.gdClass <> nil then
  begin
    CheckClass(C.gdClass);
    if (C.gdClass = Self.ClassType) and (C.SubType = SubType) then
      Result := CreateDialog
    else begin
      Obj := C.gdClass.CreateWithParams(Owner, Database, Transaction, C.SubType, 'OnlySelected');
      try
        // обязательно надо сохранить мастера!
        //Obj.MasterField := MasterField;
        //Obj.DetailField := DetailField;
        CopyEventHandlers(Obj, Self);
        try

          //Obj.Assign(Self);

          Result := Obj.CreateDialog;

          if Result and Active and Obj.Active then
          begin
            FDataTransfer := True;

            ResetEventHandlers(Self);
            try
              { TODO : вернется только одна запись! поскольку СабСет стоит БайИД }

              Obj.First;
              while not Obj.EOF do
              begin
                Insert;
                for I := 0 to FieldCount - 1 do
                begin
                  F := Obj.FindField(Fields[I].FieldName);
                  if Assigned(F) then
                    Fields[I].Assign(F);
                end;
                Post;
                Obj.Next;
              end;
            finally
              FDataTransfer := False;
            end;
          end;

        finally
          CopyEventHandlers(Self, Obj);
        end;

      finally
        Obj.Free;
      end;
    end;
  end else
    Result := False;
end;


// Вызов списка отчетов
procedure TgdcBase.DoOnReportListClick(Sender: TObject);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_SENDER('TGDCBASE', 'DOONREPORTLISTCLICK', KEYDOONREPORTLISTCLICK)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOONREPORTLISTCLICK);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOONREPORTLISTCLICK]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(Sender)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOONREPORTLISTCLICK', KEYDOONREPORTLISTCLICK, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
//  ClientReport.Execute(GroupID);
  if Assigned(EventControl) then
  begin
    EventControl.EditObject(Self, emReport);
  end;
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOONREPORTLISTCLICK', KEYDOONREPORTLISTCLICK)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOONREPORTLISTCLICK', KEYDOONREPORTLISTCLICK);
  {M}  end;
  {END MACRO}
end;

// Выбор отчета для печати
procedure TgdcBase.DoOnReportClick(Sender: TObject);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_SENDER('TGDCBASE', 'DOONREPORTCLICK', KEYDOONREPORTCLICK)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOONREPORTCLICK);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOONREPORTCLICK]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(Sender)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOONREPORTCLICK', KEYDOONREPORTCLICK, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  PrintReport((Sender as TMenuItem).Tag);
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOONREPORTCLICK', KEYDOONREPORTCLICK)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOONREPORTCLICK', KEYDOONREPORTCLICK);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.PrintReport(const ID: Integer);
begin
  Assert(ClientReport <> nil, 'Не подключен сервер отчетов');
  if Assigned(FCurrentForm) and FCurrentForm.InheritsFrom(TCreateableForm) then
    ClientReport.BuildReport(GetGdcOLEObject(FCurrentForm) as IDispatch, ID)
  else
    ClientReport.BuildReport(Unassigned, ID);
end;

procedure TgdcBase.isUse;
var
  I: Integer;
  LI: TListItem;
  //atRelation: TatRelation;
  FTableList, FForeignList, FKeyList: TStringList;
  FKeyField: String;
  FTable, FKey: String;
  OL: TObjectList;

  // возвращает первичный ключ для заданной таблицы
  function GetPrimary(const TableName: String): String;
  var
    q: TIBSQL;
  begin
    q := TIBSQL.Create(Self);
    try
      q.Database := DataBase;
      q.Transaction := Transaction;
      q.SQL.Text :=
        ' SELECT ' +
        '   isg1.rdb$field_name primaryname ' +
        ' FROM ' +
        '   rdb$index_segments isg1 ' +
        '   JOIN rdb$relation_constraints rc1 ON rc1.rdb$index_name = isg1.rdb$index_name ' +
        ' WHERE ' +
        '   rc1.rdb$relation_name = UPPER(''' + TableName + ''')' +
        '   AND rc1.rdb$index_name = isg1.rdb$index_name ' +
        '   AND rc1.rdb$constraint_type = ''PRIMARY KEY''';
      q.ExecQuery;
      Result := '';
      while not q.Eof do
      begin
        if Result = '' then
          Result := q.FieldByName('PrimaryName').AsTrimString
        else
          raise EgdcException.CreateObj('gdc.IsUse: Composite primary keys are not supported', Self);
          // Result := Result + ';' + q.FieldByName('PrimaryName').AsTrimString;
        q.Next;
      end;
    finally
      q.Free;
    end;
  end;

  procedure AddTable(TableName: String);
  var
    sql, sqlValue: TIBSQL;
    NewTable, NewPrimary: String;

  begin
    try
      sql := TIBSQL.Create(Self);
      sqlvalue := TIBSQL.Create(Self);
      try
        sql.Database := Database;
        sql.Transaction := Transaction;
        sqlValue.Database := Database;
        sqlValue.Transaction := Transaction;

        sql.sql.Text :=
          ' SELECT ' +
          '   isg2.rdb$field_name AS targetfield, ' +
          '   rc2.rdb$relation_name AS targettable ' +
          ' FROM ' +
          '   rdb$relation_constraints rc1 ' +
          '   JOIN rdb$ref_constraints rfc ON rfc.rdb$const_name_uq = rc1.rdb$constraint_name ' +
          '   JOIN rdb$relation_constraints rc2 ON rfc.rdb$constraint_name = rc2.rdb$constraint_name ' +
          '   JOIN rdb$index_segments isg2 ON rc2.rdb$index_name = isg2.rdb$index_name ' +
          '   JOIN rdb$relation_constraints rc3 ON rc3.rdb$relation_name = rc2.rdb$relation_name ' +
          '   JOIN rdb$ref_constraints rrc ON rrc.rdb$constraint_name = rc2.rdb$constraint_name ' +
          ' WHERE ' +
          '   rc1.rdb$relation_name = UPPER(''' + TableName + ''')' +
          '   AND rc3.rdb$constraint_type = ''PRIMARY KEY''' +
          '   AND rrc.rdb$delete_rule = ''RESTRICT'' ' +
          ' ORDER BY ' +
          '   rc2.rdb$relation_name ';
        sql.ExecQuery;

        NewTable := '';
        while not sql.Eof do
        begin
          try
            if NewTable <> sql.FieldByName('targettable').AsTrimString then
            begin
              NewTable := sql.FieldByName('targettable').AsTrimString;
              NewPrimary := GetPrimary(NewTable);
            end;

            sqlValue.Close;
            sqlValue.sql.Text := 'SELECT ' + sql.FieldByName('TargetField').AsTrimString +
              ' FROM ' + NewTable + ' WHERE ' + sql.FieldByName('TargetField').AsTrimString +
              ' = ' + FKey; //!!!
            sqlValue.ExecQuery;
            if sqlValue.RecordCount > 0 then
            begin
              FTableList.Add(NewTable);
              FForeignList.Add(sql.FieldByName('targetfield').AsTrimString);
              FKeyList.Add(NewPrimary);

              if NewPrimary = sql.FieldByName('targetfield').AsTrimString then
                AddTable(NewTable);
            end;
          except
          end;
          sql.Next;
        end;

      finally
        sql.Free;
        sqlValue.Free;
      end;
    except
    end;
  end;

  var
    gdcCurrClass: TgdcBase;
    gdcClassByRecord: TgdcBase;
    FC: TgdcFullClass;
    qryID: TIBSQL;
    IDList: TStringList;
    FNotEof: Boolean;
begin
  FTableList := TStringList.Create;
  FForeignList := TStringList.Create;
  FKeyList := TStringList.Create;
  IDList := TStringList.Create;
  try
    FTable := GetListTable(SubType);
    FKeyField := GetPrimary(FTable);
    FKey := FieldByName(FKeyField).AsString;

    Assert(FKeyField > '', 'У таблицы отсутствует ключевое поле.');
    AddTable(FTable);
//вытягиваем все таблицы, которые имеют с главной таблицей связь 1:1
    OL := TObjectList.Create(False);
    try
      atDatabase.ForeignKeys.ConstraintsByReferencedRelation(
        GetListTable(SubType), OL);
      for I := 0 to OL.Count - 1 do
        with OL[I] as TatForeignKey do
      begin
        if IsSimpleKey
          and (Relation.PrimaryKey <> nil)
          and (Relation.PrimaryKey.ConstraintFields.Count = 1)
          and (ConstraintField = Relation.PrimaryKey.ConstraintFields[0]) then
        begin
          AddTable(Relation.RelationName);
        end;
      end;
    finally
      OL.Free;
    end;


    if FTableList.Count <> 0 then
    begin
      qryID := TIBSQL.Create(nil);
      qryID.Database := Database;
      qryID.Transaction := Transaction;
      try
        with TdlgTableValues.Create(Self) do
        try
          lvTables.Items.BeginUpdate;
          for I := 0 to FTableList.Count - 1 do
          begin
            qryID.Close;
            //Находим все значения ключевого поля по удаляемой ссылке
            qryID.SQL.Text := Format('SELECT %0:s as ID FROM %1:s WHERE %2:s = %3:s ',
              [FKeyList[I], FTableList[I], FForeignList[I], FKey]);
            qryID.ExecQuery;
            //находим базовый класс для таблицы
            FC := GetBaseClassForRelation(FTableList[I]);
            //Если мы не нашли базовый класс для таблицы генерируем эксепшен
            if FC.gdClass = nil then
              raise EgdcException.Create('Невозможно удалить запись ' + GetDisplayName(SubType) + ' '
                + FieldByName(GetListField(SubType)).AsString + ' с идентификатором ' + IntToStr(ID));

            //создаем объект класса по id
            gdcCurrClass := FC.gdClass.CreateSingularByID(Self,
              qryID.FieldByName('ID').AsInteger, FC.SubType);
            try
              //Добавляем все ID  в список
              IDList.Clear;
              while (not qryID.Eof) and (IDList.Count < 1000)do
              begin
                //Вытянем первую тысячу, если значений больше
                IDList.Add(qryID.FieldByName('ID').AsString);
                qryID.Next;
              end;
              //Устанавливаем флаг, считали ли мы весь объект
              FNotEof := not qryID.Eof;
              qryID.FreeHandle;
              //по текущей записи находим конкретный класс объекта
              FC := gdcCurrClass.GetCurrRecordClass;
              if not Assigned(FC.gdClass) then
                raise EgdcException.Create(Format('Для таблицы %s не найден класс! ', [FTableList[I]]));
              //создаем объект, чтобы вытянуть его отображаемое имя и добавляем его в список
              gdcClassByRecord := FC.gdClass.CreateSubType(Self, FC.SubType);
              try
                AddNewObject(gdcClassByRecord.GetDisplayName(gdcClassByRecord.SubType),
                  FC, IDList{.CommaText}, FNotEof);
                LI := lvTables.Items.Add;
                LI.Caption := gdcClassByRecord.GetDisplayName(gdcClassByRecord.SubType);
              finally
                gdcClassByRecord.Free;
              end;
            finally
              gdcCurrClass.Free;
            end;
          end;
          if lvTables.Items.Count <> 0 then
            lvTables.Items[lvTables.Items.Count - 1].Selected := True;
          lvTables.Items.EndUpdate;

          Caption := GetDisplayName(SubType) + ' '
            + FieldByName(GetListField(SubType)).AsString +
            ' с идентификатором ' + IntToStr(ID);
          ShowModal;
        finally
          Free;
        end
      finally
        qryID.Free;
      end;
    end
    else
      raise EgdcException.Create('Невозможно удалить запись ' + GetDisplayName(SubType) + ' '
        + FieldByName(GetListField(SubType)).AsString + ' с идентификатором ' + IntToStr(ID));
  finally
    FTableList.Free;
    FForeignList.Free;
    FKeyList.Free;
    IDList.Free;
  end;
end;

procedure TgdcBase.ExecSingleQuery(const S: String);
begin
  ExecSingleQuery(S, varNull);
end;

function TgdcBase.DeleteRecord: Boolean;
begin
  Result := False;
  try
    Delete;
    Result := True
  except
    on E: EIBError do
    begin
      if E.IBErrorCode = isc_foreign_key then
      begin
        isUse;
        Abort;
      end else
        raise EgdcIBError.CreateObj(E, Self);
    end;
  end;
end;

class procedure TgdcBase.CheckClass(C: TClass);
begin
  if not C.InheritsFrom(Self) then
    raise EgdcIBError.Create('Invalid gdc class specified');
end;

{procedure TgdcBase.ChooseElement(F: TgdcFindObject);
begin
end;         }

function TgdcBase.GetGroupID: Integer;
var
  q: TIBSQL;
  DidActivate: Boolean;
begin
  DidActivate := False;
  q := TIBSQL.Create(nil);
  try
    try
      q.Database := Database;
      q.Transaction := Transaction;
      DidActivate := ActivateTransaction;

      q.SQL.Text := 'SELECT id FROM rp_reportgroup WHERE usergroupname = ''' +
        UpperCase(ClassName + SubType) + '''';
      q.ExecQuery;
      if q.RecordCount > 0 then
        Result := q.FieldByName('ID').ASInteger
      else
      begin
        q.Close;
        Result := GetNextID;
        q.SQL.Text := Format('INSERT INTO RP_REPORTGROUP(ID, USERGROUPNAME, NAME) ' +
          ' VALUES(%d, ''' + UpperCase(ClassName + SubType) + ''', ''' +
            GetDisplayName(SubSet) + ''')', [Result]);
        q.ExecQuery;
        { TODO : что-то не нравится мне этот ретаининг...
                 тут скорее всего надо использовать отдельную
                 транзакцию
        }
        Transaction.CommitRetaining;
      end;
    finally
      q.Free;

      if DidActivate then
        Transaction.Commit;
    end;
  except
    Result := cst_ReportGroupID;
  end;
end;

procedure TgdcBase.LoadEventList;
begin
  FEventList.Add(gdcEventTypesString[etAfterCancel]);
  FEventList.Add(gdcEventTypesString[etAfterClose]);
  FEventList.Add(gdcEventTypesString[etAfterDelete]);
  FEventList.Add(gdcEventTypesString[etAfterEdit]);
  FEventList.Add(gdcEventTypesString[etAfterInsert]);
  FEventList.Add(gdcEventTypesString[etAfterOpen]);
  FEventList.Add(gdcEventTypesString[etAfterPost]);
  FEventList.Add(gdcEventTypesString[etAfterRefresh]);
  FEventList.Add(gdcEventTypesString[etAfterScroll]);
  FEventList.Add(gdcEventTypesString[etBeforeCancel]);
  FEventList.Add(gdcEventTypesString[etBeforeClose]);
  FEventList.Add(gdcEventTypesString[etBeforeDelete]);
  FEventList.Add(gdcEventTypesString[etBeforeEdit]);
  FEventList.Add(gdcEventTypesString[etBeforeInsert]);
  FEventList.Add(gdcEventTypesString[etBeforeOpen]);
  FEventList.Add(gdcEventTypesString[etBeforePost]);
  FEventList.Add(gdcEventTypesString[etBeforeRefresh]);
  FEventList.Add(gdcEventTypesString[etBeforeScroll]);
  FEventList.Add(gdcEventTypesString[etOnCalcFields]);
  FEventList.Add(gdcEventTypesString[etOnNewRecord]);
  FEventList.Add(gdcEventTypesString[etOnFieldChange]);
end;

procedure TgdcBase.CreateFields;

var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  I, J: Integer;
  F: TatRelationField;
  FieldName, RelationName: String;
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'CREATEFIELDS', KEYCREATEFIELDS)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYCREATEFIELDS);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYCREATEFIELDS]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'CREATEFIELDS', KEYCREATEFIELDS, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  inherited;

  // локализуем экранные метки полей
  for I := 0 to FieldCount - 1 do
  begin
    RelationName := ExtractIdentifier(Database.SQLDialect,
      System.Copy(Fields[I].Origin, 1, Pos('.', Fields[I].Origin) - 1));

    FieldName := ExtractIdentifier(Database.SQLDialect,
      System.Copy(Fields[I].Origin, Pos('.', Fields[I].Origin) + 1, 255));

    F := atDatabase.FindRelationField(RelationName, FieldName);

    if F <> nil then
      Fields[I].DisplayLabel := F.LName;

    // для полей, которые не входят в запросы на обновление данных
    // и если для объекта не предусмотрена специальная обработка
    // мы снимаем Required
    if (CustomProcess * [cpInsert, cpModify]) = [] then
      if StrIPos(',' + Fields[I].FieldName + ',', ',' + FUpdateableFields + ',') = 0 then
      begin
        Fields[I].Required := False;
      end;

    //
    Fields[I].Visible := ShowFieldInGrid(Fields[I]);
  end;

  for I := 0 to FieldCount - 1 do
  begin
    for J := I + 1 to FieldCount - 1 do
    begin
      if (AnsiCompareText(Fields[I].DisplayName, Fields[J].DisplayName) = 0) then
      begin
        RelationName := ExtractIdentifier(Database.SQLDialect,
          System.Copy(Fields[J].Origin, 1, Pos('.', Fields[J].Origin) - 1));

        FieldName := ExtractIdentifier(Database.SQLDialect,
          System.Copy(Fields[J].Origin, Pos('.', Fields[J].Origin) + 1, 255));

        F := atDatabase.FindRelationField(RelationName, FieldName);

        if (F <> nil) and (F.Relation <> nil) then
        begin
          Fields[J].DisplayLabel := F.LName + ' (' + F.Relation.LName + ')';
        end;
      end;
    end;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'CREATEFIELDS', KEYCREATEFIELDS)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'CREATEFIELDS', KEYCREATEFIELDS);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.GetHasWhereClause: Boolean;
begin
  Result := (GetWhereClause > '') or
    (Assigned(IBLogin) and ([tiAView, tiAChag, tiAFull] * gdcTableInfos <> []));
end;

class function TgdcBase.GetListTableAlias: String;
begin
  Result := 'z';
end;

function TgdcBase.QueryDescendant: TgdcFullClass;
var
  I: Integer;
  CL: TClassList;
begin
  Result.SubType := SubType;

  CL := TClassList.Create;
  try
    if not GetChildrenClass(CL) then
    begin
      Result.gdClass := CgdcBase(Self.ClassType);
      exit;
    end;

    if CL.Count = 1 then
    begin
      Result.gdClass := CgdcBase(CL[0]);
      exit;
    end;

    with Tgdc_dlgQueryDescendant.Create(ParentForm) do
    try
      rgObjects.Items.Clear;
      for I := 0 to CL.Count - 1 do
        rgObjects.Items.Add(CgdcBase(CL[I]).GetDisplayName(SubType));

      if Height < CL.Count * 30 + 30 then
        Height := CL.Count * 30 + 30;

      rgObjects.ItemIndex := 0;

      if ShowModal <> mrOk then
      begin
        Result.gdClass := nil;
        exit;
      end;

      Result.gdClass := CgdcBase(CL[rgObjects.ItemIndex]);
    finally
      Free;
    end;

  finally
    CL.Free;
  end;
end;

class function TgdcBase.GetListNameByID(const AnID: TID;
  const ASubType: TgdcSubType = ''): String;
var
  q: TIBSQL;
begin
  Assert(Assigned(gdcBaseManager) and Assigned(gdcBaseManager.Database));
  Assert(Assigned(gdcBaseManager.ReadTransaction));
  Assert(gdcBaseManager.ReadTransaction.InTransaction);

  q := TIBSQL.Create(nil);
  try
    q.Transaction := gdcBaseManager.ReadTransaction;
    q.SQL.Text := 'SELECT ' + GetListField(ASubType) + ' FROM ' +
      GetListTable(ASubType) + ' WHERE ' + GetKeyField(ASubType) + ' = :ID';
    q.Params[0].AsInteger := AnID;
    q.ExecQuery;
    if q.EOF then
      Result := ''
    else
      Result := q.Fields[0].AsString;
    q.Close;
  finally
    q.Free;
  end;
end;

procedure TgdcBase.PopupReportMenu(const X, Y: Integer);
var
  Pt: TPoint;
begin
//При изменении отчетов, добавлении или удалении необходимо перечитывать меню
  //if not Assigned(FpmReport) then
    MakeReportMenu;

  if (X = -1) and (Y = -1) then
    GetCursorPos(Pt)
  else
    Pt := Point(X, Y);

  FpmReport.Popup(Pt.X, Pt.Y);
end;

procedure TgdcBase.PopupFilterMenu(const X, Y: Integer);
begin
  if Assigned(FFilter) then
    FFilter.PopupMenu(X, Y);
end;

procedure TgdcBase.DoOnFilterChanged(Sender: TObject;
  const AnCurrentFilter: Integer);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_DOONFILTERCHANGED('TGDCBASE', 'DOONFILTERCHANGED', KEYDOONFILTERCHANGED)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOONFILTERCHANGED);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOONFILTERCHANGED]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self),
  {M}          GetGdcInterface(Sender), AnCurrentFilter]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOONFILTERCHANGED', KEYDOONFILTERCHANGED, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if Assigned(FOnFilterChanged) then
    FOnFilterChanged(Sender);

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOONFILTERCHANGED', KEYDOONFILTERCHANGED)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOONFILTERCHANGED', KEYDOONFILTERCHANGED);
  {M}  end;
  {END MACRO}
end;

{procedure TgdcBase.SetIBSQL;
begin
  FIBSQL.Close;
  FIBSQL.DataBase := DataBase;
  FIBSQL.Transaction := Transaction;
end;}

function TgdcBase.GetDetailLinks(Index: Integer): TgdcBase;
begin
  Result := FDetailLinks[Index] as TgdcBase;
end;

function TgdcBase.GetDetailLinksCount: Integer;
begin
  Result := FDetailLinks.Count;
end;

procedure TgdcBase.AddDetailLink(AnObject: TgdcBase);
begin
  if Assigned(FDetailLinks) and (FDetailLinks.IndexOf(AnObject) = -1) then
  begin
    FDetailLinks.Add(AnObject);
  end;  
end;

procedure TgdcBase.RemoveDetailLink(AnObject: TgdcBase);
begin
  if Assigned(FDetailLinks) then
    FDetailLinks.Remove(AnObject);
end;

function TgdcBase.GetChildrenClass(CL: TClassList): Boolean;
begin
  Result := GetDescendants(CgdcBase(Self.ClassType), CL, True);
end;

procedure TgdcBase.ValidateField(Sender: TField);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_VALIDATEFIELD('TGDCBASE', 'VALIDATEFIELD', KEYVALIDATEFIELD)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYVALIDATEFIELD);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYVALIDATEFIELD]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(Sender)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'VALIDATEFIELD', KEYVALIDATEFIELD, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  //

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'VALIDATEFIELD', KEYVALIDATEFIELD)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'VALIDATEFIELD', KEYVALIDATEFIELD);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.RelationByAliasName(const AnAliasName: String): String;
begin
  Result := QSelect.FieldByName(AnAliasName).AsXSQLVAR.relname;
end;

function TgdcBase.FieldNameByAliasName(const AnAliasName: String): String;
var
  F: TField;
begin
  { TODO : 
если наименование таблицы будет в себе содержать
точку, то привет -- будет ошибка }
  F := FieldByName(AnAliasName);
  Result := ExtractIdentifier(Database.SQLDialect,
    System.Copy(F.Origin, Pos('.', F.Origin) + 1, 255));
  //Result := QSelect.FieldByName(AnAliasName).AsXSQLVAR.sqlname;
end;

procedure TgdcBase.CustomDelete(Buff: Pointer);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_CUSTOMINSERT('TGDCBASE', 'CUSTOMDELETE', KEYCUSTOMDELETE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYCUSTOMDELETE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYCUSTOMDELETE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), Integer(Buff)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'CUSTOMDELETE', KEYCUSTOMDELETE, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if FSetTable > '' then
  else
  begin
    SetInternalSQLParams(FQDelete, Buff);
    FQDelete.ExecQuery;
    FRowsAffected := FQDelete.RowsAffected;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'CUSTOMDELETE', KEYCUSTOMDELETE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'CUSTOMDELETE', KEYCUSTOMDELETE);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.CustomInsert(Buff: Pointer);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_CUSTOMINSERT('TGDCBASE', 'CUSTOMINSERT', KEYCUSTOMINSERT)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYCUSTOMINSERT);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYCUSTOMINSERT]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), Integer(Buff)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'CUSTOMINSERT', KEYCUSTOMINSERT, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  if FSetTable > '' then
  else
  begin
  //
    SetInternalSQLParams(QInsert, Buff);
    QInsert.ExecQuery;
    FRowsAffected := QInsert.RowsAffected;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'CUSTOMINSERT', KEYCUSTOMINSERT)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'CUSTOMINSERT', KEYCUSTOMINSERT);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.CustomModify(Buff: Pointer);
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  QModifySet: TIBSQL;
  DidActivate: Boolean;

  function GetModifySQLTextForSet: String;
  var
    I: Integer;
    SL: TStrings;
    KFL: TStringList;
    ModifiedFields: String;
    KeyFields: String;
  begin
    Result := '';
    //проверяем есть ли у нас таблица-множество
    if (FSetTable = '') or (atDatabase = nil) or (Database = nil) then
      Exit;

    //Проверяем есть ли у таблицы множества составной первичный ключ
    if Assigned(atDatabase.Relations.ByRelationName(FSetTable).PrimaryKey) and
      (atDatabase.Relations.ByRelationName(FSetTable).PrimaryKey.ConstraintFields.Count > 1)
    then
    begin
      KFL := TStringList.Create;
      SL := TStringList.Create;
      try
        with atDatabase.Relations.ByRelationName(FSetTable).PrimaryKey do
        for I := 0 to ConstraintFields.Count - 1 do
          KFL.Add(AnsiUpperCase(Trim(ConstraintFields[I].FieldName)));

        Database.GetFieldNames(FSetTable, SL);

        ModifiedFields := '';
        for I := 0 to SL.Count - 1 do
        begin
          //В секцию SET запихнем все поля (в том числе и ключевые)
          if ModifiedFields > '' then
            ModifiedFields := ModifiedFields + ', ';
          ModifiedFields := ModifiedFields + SL[I] + ' = :NEW_' + cstSetPrefix + SL[I];
        end;

        KeyFields := '';
        for I := 0 to KFL.Count - 1 do
        begin
          if KeyFields > '' then
            KeyFields := KeyFields + ' AND ';
          KeyFields := KeyFields + KFL[I] + ' = :OLD_' + cstSetPrefix + KFL[I];
        end;

        Result := Format('UPDATE %0:s SET %1:s WHERE %2:s',
          [FSetTable, ModifiedFields, KeyFields]);

      finally
        KFL.Free;
        SL.Free;
      end;
    end;
  end;
begin
  {@UNFOLD MACRO INH_ORIG_CUSTOMINSERT('TGDCBASE', 'CUSTOMMODIFY', KEYCUSTOMMODIFY)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYCUSTOMMODIFY);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYCUSTOMMODIFY]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), Integer(Buff)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'CUSTOMMODIFY', KEYCUSTOMMODIFY, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  DidActivate := False;
  try
    DidActivate := ActivateTransaction;

    if FSetTable > '' then
    begin
      QModifySet := TIBSQL.Create(nil);
      try
        QModifySet.Transaction := Transaction;
        QModifySet.Close;
        QModifySet.SQL.Text := GetModifySQLTextForSet;
        if QModifySet.SQL.Text > '' then
        begin
          SetInternalSQLParams(QModifySet, Buff);
          QModifySet.ExecQuery;
        end;
      finally
        QModifySet.Free;
      end;
    end else
    begin
      SetInternalSQLParams(QModify, Buff);
      QModify.ExecQuery;
      FRowsAffected := QModify.RowsAffected;
    end;

    if DidActivate and Transaction.InTransaction then
      Transaction.Commit;

  except
    if DidActivate and Transaction.InTransaction then
      Transaction.Rollback;
    raise;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'CUSTOMMODIFY', KEYCUSTOMMODIFY)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'CUSTOMMODIFY', KEYCUSTOMMODIFY);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.GetObjectName: String;
begin
  if Active then
  begin
    Result := Trim(FieldByName(GetListField(SubType)).AsString);
    if AnsiCompareText(GetListField(SubType), GetKeyField(SubType)) = 0 then
      Result := GetDisplayName(SubType) + ', ИД: ' + Result;
  end else
    Result := FObjectName;
end;

procedure TgdcBase.SetObjectName(const Value: String);
begin
  { TODO : а пустое имя может быть?? }
  if Value = '' then
  begin
    Close;
    FObjectName := '';
  end else
  begin
    if State in dsEditModes then
    begin
      FieldByName(GetListField(SubType)).AsString := Value;
    end
    else if State = dsInactive then
    begin
      FObjectName := Value;
    end
    else if HasSubSet('ByName') then
    begin
      Close;
      FObjectName := Value;
      Open;
    end else
      if not Locate(GetListField(SubType), Value, []) then
        raise EgdcException.CreateObj('Invalid object name specified', Self);
  end;
end;

procedure TgdcBase.SetRefreshSQLOn(SetOn: Boolean);
var
  WasActive: Boolean;
begin
  if FSetRefreshSQLOn <> SetOn then
  begin
    if FSQLInitialized then
    begin
      WasActive := Active;
      if WasActive then
        Close;

      if SetOn then
      begin
        if not Assigned(FSQLSetup) then
          FSQLSetup := TatSQLSetup.Create(nil);

        if not (csDesigning in ComponentState) then
        begin
          RefreshSQL.Text := FSQLSetup.PrepareSQL(GetRefreshSQLText, Self.ClassName +
            '(' + Self.SubType + ')');
        end else
          RefreshSQL.Text := GetRefreshSQLText;

      end else
        RefreshSQL.Text := '';

      if WasActive then
        Open;
    end;

    FSetRefreshSQLOn := SetOn;
  end;
end;

procedure TgdcBase.RevertRecord;
var
  I: Integer;
begin
  Assert(sSubDialog in FBaseState);
  Assert(State in dsEditModes);
  for I := 0 to FOldValues.Count - 1 do
    if (FOldValues[I] as TFieldValue).IsNull then
      FieldByName((FOldValues[I] as TFieldValue).FieldName).Clear
    else
      FieldByName((FOldValues[I] as TFieldValue).FieldName).AsString :=
        (FOldValues[I] as TFieldValue).Value;
  FOldValues.Clear;
end;

procedure TgdcBase.SetSubType(const Value: String);
begin
  if FSubType <> Value then
  begin
    Close;
    FSubType := Value;
    FgdcTableInfos := GetTableInfos(FSubType);
    FModifyFromStream := NeedModifyFromStream(SubType);
    if Assigned(FFilter) then
      FFilter.Name := 'flt_' + RemoveProhibitedSymbols(FSubType) + System.copy(ClassName, 2, 255);
    FSQLInitialized := False;
  end;
end;

constructor TgdcBase.CreateSubType(AnOwner: TComponent;
  const ASubType: TgdcSubType; const ASubSet: TgdcSubSet = 'All');
begin
  Create(AnOwner);
  SubType := ASubType; // тут должно быть обязательно присваивание проперти!
  SubSet := ASubSet;
end;

procedure TgdcBaseManager.SetExplorer(const Value: IgdcBase);
begin
  if Assigned(FExplorer) then
    FExplorer.RemoveFreeNotification(Self);

  if Value <> nil then
  begin
    FExplorer := Value.GetObject as TgdcBase;
    FExplorer.FreeNotification(Self);
  end else
    FExplorer := nil;
end;

procedure TgdcBaseManager.UnPackStream(SourceStream, DestStream: TStream);
var
  Z: TZDecompressionStream;
begin
  Z := TZDecompressionStream.Create(SourceStream);
  try
    DestStream.CopyFrom(Z, 0)
  finally
    Z.Free
  end
end;

{ TgdcDragObject }

constructor TgdcDragObject.Create(ASourceControl: TWinControl);
begin
  inherited Create;
  SourceControl := ASourceControl;
end;

function TgdcBase.GetSubType: String;
begin
  Result := FSubType;
end;

function TgdcBase.ParentHandle: Integer;
begin
  Result := 0;

  if (FDlgStack.Count > 0) and (FDlgStack.Peek <> nil) and (FDlgStack.Peek is TForm) then
    Result := (FDlgStack.Peek as TForm).Handle
  else if Assigned(FgdcDataLink) and (FgdcDataLink.DataSet is TgdcBase) then
    Result := (FgdcDataLink.DataSet as TgdcBase).ParentHandle;

  if (Result = 0) and Assigned(FParentForm) then
    Result := FParentForm.Handle;
end;

procedure TgdcBase.Post;
var
  I: Integer;
  Det: TgdcBase;
  F: TField;
begin
  if FDataTransfer then
    inherited Post
  else begin

    if (State = dsEdit) and (sDialog in FBaseState) and
      (not Modified) then Cancel
    else begin
      {if State = dsInsert then
      begin}
        for I := 0 to FDetailLinks.Count - 1 do
        begin
          Det := FDetailLinks[I] as TgdcBase;
          if (Det.State = dsInsert)
            and (AnsiCompareText(Det.DetailField, Det.GetKeyField(Det.SubType)) = 0)
            and (Det.Transaction = Self.Transaction)
            and (AnsiCompareText(Det.MasterField, GetKeyField(SubType)) <> 0) then
          begin
            F := FindField(Det.MasterField);
            if F <> nil then
            begin
              FIgnoreDataSet.Add(Det);
              try
                F.Clear;
                inherited Post;
                Edit;
                F.AsInteger := Det.ID;
                Det.Post;
              finally
                FIgnoreDataSet.Remove(Det);
              end;
            end;
          end;
        end;
      //end;

      inherited Post;
      FDSModified := Transaction.InTransaction;
      if HasSubSet('OnlySelected') then
        FSelectedID.Add(ID, True);
    end;
    FOldValues.Clear;
  end;
end;

procedure TgdcBase.Assign(Source: TPersistent);
var
  I: Integer;
begin
  if not Self.InheritsFrom(Source.ClassType) then
    raise EgdcException.Create('Object of invalid class specified');

  if Active then
    raise EgdcException.Create('Object is not closed');

  Transaction := (Source as TgdcBase).Transaction;
  SubType := (Source as TgdcBase).SubType;
  SubSet := (Source as TgdcBase).SubSet;

  for I := 0 to (Source as TgdcBase).Params.Count - 1 do
  begin
    ParamByName((Source as TgdcBase).Params[I].Name).AsString :=
      (Source as TgdcBase).Params[I].AsString;
  end;
end;

procedure TgdcBase.SyncField(Field: TField);
begin
  if ((sDialog in FBaseState)
    and (FDlgStack.Count > 0)
    and (FDlgStack.Peek is Tgdc_dlgG)) then
  begin
    if FSyncList = nil then
      FSyncList := TList.Create;

    if FSyncList.IndexOf(Field) = -1 then
    begin
      FSyncList.Add(Field);
      try
        (FDlgStack.Peek as Tgdc_dlgG).SyncField(Field, FSyncList);
      finally
        FSyncList.Remove(Field);
      end;
    end;

    if (not (sSyncControls in FBaseState)) then
    begin
      Include(FBaseState, sSyncControls);
      try
        (FDlgStack.Peek as Tgdc_dlgG).SyncControls;
      finally
        Exclude(FBaseState, sSyncControls);
      end;
    end;
  end
  else if Assigned(MasterSource)
    and (MasterSource.DataSet is TgdcBase) then
  begin
    (MasterSource.DataSet as TgdcBase).SyncField(Field);
  end;
end;

function TgdcBase.FieldChanged(const AFieldName: String): Boolean;
var
  I: Integer;
begin
  Result := FOldValues.Count = 0;
  for I := 0 to FOldValues.Count - 1 do
    if AnsiCompareText((FOldValues[I] as TFieldValue).FieldName, AFieldName) = 0 then
    begin
      Result := True;
      exit;
    end;
end;

function TgdcBase.GetCustomProcess: TgsCustomProcesses;
begin
  Result := FCustomProcess;
end;

procedure TgdcBase.SetCustomProcess(const Value: TgsCustomProcesses);
begin
  FCustomProcess := Value;
end;

procedure TgdcBase._CustomInsert(Buff: Pointer);
begin
  CustomInsert(Buff);
  DoAfterCustomProcess(Buff, cpInsert);
end;

procedure TgdcBase._CustomModify(Buff: Pointer);
begin
  CustomModify(Buff);
  DoAfterCustomProcess(Buff, cpModify);
end;

procedure TgdcBase._CustomDelete(Buff: Pointer);
begin
  try
    CustomDelete(Buff);
  except
    on Ex: EIBError do
    begin
      if Ex.IBErrorCode = isc_foreign_key then
      begin
        isUse;
        Abort;
      end else
        raise;
    end;
  end;
  DoAfterCustomProcess(Buff, cpDelete);
end;

class function TgdcBase.GetSubTypeList(SubTypeList: TStrings): Boolean;
begin
  SubTypeList.Clear;
  Result := False;
end;

function TgdcBase.GetNextID(const Increment: Boolean): Integer;
var
  q: TIBSQL;
begin
  if Increment and Assigned(gdcBaseManager) then
    Result := gdcBaseManager.GetNextID
  else
  begin
    q := TIBSQL.Create(nil);
    try
      q.Database := Database;
      q.Transaction := ReadTransaction;
      if Increment then
        q.SQL.Text := 'SELECT GEN_ID(gd_g_unique, 1) + GEN_ID(gd_g_offset, 0) FROM rdb$database'
      else
        q.SQL.Text := 'SELECT GEN_ID(gd_g_unique, 0) + GEN_ID(gd_g_offset, 0) FROM rdb$database';
      q.ExecQuery;
      Result := q.Fields[0].AsInteger;
      q.Close;
    finally
      q.Free;
    end;
  end;
end;

class function TgdcBase.GetTableInfos(const ASubType: String): TgdcTableInfos;
var
  R: TatRelation;
begin
  Assert(Assigned(atDatabase));
  R := atDatabase.Relations.ByRelationName(GetListTable(ASubType));
  Result := [];
  if (R <> nil) and (R.RelationFields <> nil) then
  begin
    if R.RelationFields.ByFieldName(GetKeyField(ASubType)) <> nil then
      Include(Result, gdcBaseInterface.tiID);
    if R.RelationFields.ByFieldName('xid') <> nil then
      Include(Result, gdcBaseInterface.tiXID);
    if R.RelationFields.ByFieldName('dbid') <> nil then
      Include(Result, gdcBaseInterface.tiDBID);
    if (R.RelationFields.ByFieldName('creationdate') <> nil)
        and (R.RelationFields.ByFieldName('creatorkey') <> nil) then
      Include(Result, tiCreationInfo);
    if (R.RelationFields.ByFieldName('editiondate') <> nil)
        and (R.RelationFields.ByFieldName('editorkey') <> nil) then
      Include(Result, tiEditionInfo);
    if R.RelationFields.ByFieldName('disabled') <> nil then
      Include(Result, tiDisabled);
    if R.RelationFields.ByFieldName('aview') <> nil then
      Include(Result, tiAView);
    if R.RelationFields.ByFieldName('achag') <> nil then
      Include(Result, tiAChag);
    if R.RelationFields.ByFieldName('afull') <> nil then
      Include(Result, tiAFull);
  end;
end;

function TgdcBase.HasAttribute: Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to FieldCount - 1 do
    if AnsiCompareText(System.Copy(Fields[I].FieldName, 1, 4), UserPrefix) = 0 then
    begin
      Result := True;
      exit;
    end;
end;


procedure TgdcBase.DoAfterCustomProcess(Buff: Pointer;
  Process: TgsCustomProcess);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_DOAFTERCUSTOMPROCESS('TGDCBASE', 'DOAFTERCUSTOMPROCESS', KEYDOAFTERCUSTOMPROCESS)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOAFTERCUSTOMPROCESS);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOAFTERCUSTOMPROCESS]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self),
  {M}          Integer(Buff), TgsCustomProcess(Process)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOAFTERCUSTOMPROCESS', KEYDOAFTERCUSTOMPROCESS, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  // should be overridden by descendant classes

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTERCUSTOMPROCESS', KEYDOAFTERCUSTOMPROCESS)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOAFTERCUSTOMPROCESS', KEYDOAFTERCUSTOMPROCESS);
  {M}  end;
  {END MACRO}
end;

{ EgdcBase }

constructor EgdcIBError.CreateObj(E: EIBError; AnObj: TgdcBase);
begin
  Assert(E is EIBError);
  Assert(AnObj is TgdcBase);
  FOriginalClass := CIBError(E.ClassType);
  Create(E.SQLCode, E.IBErrorCode,
    Format('%s'#13#10#13#10'Class: %s'#13#10'Object: %s'#13#10'SubType: %s'#13#10'SubSet: %s'#13#10'ID: %d'#13#10,
      [E.Message, AnObj.ClassName, AnObj.Name, AnObj.SubType, AnObj.SubSet, AnObj.ID]));
end;

procedure TgdcBase.DoAfterShowDialog(DlgForm: TCreateableForm;
  IsOk: Boolean);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_DOAFTERSHOWDIALOG('TGDCBASE', 'DOAFTERSHOWDIALOG', KEYDOAFTERSHOWDIALOG)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOAFTERSHOWDIALOG);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOAFTERSHOWDIALOG]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self),
  {M}          GetGdcInterface(DlgForm), IsOk]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOAFTERSHOWDIALOG', KEYDOAFTERSHOWDIALOG, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  if Assigned(FAfterShowDialog) then
    FAfterShowDialog(Self, DlgForm, IsOk);
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTERSHOWDIALOG', KEYDOAFTERSHOWDIALOG)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOAFTERSHOWDIALOG', KEYDOAFTERSHOWDIALOG);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoBeforeShowDialog(DlgForm: TCreateableForm);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_DOBEFORESHOWDIALOG('TGDCBASE', 'DOBEFORESHOWDIALOG', KEYDOBEFORESHOWDIALOG)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOBEFORESHOWDIALOG);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOBEFORESHOWDIALOG]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(DlgForm)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOBEFORESHOWDIALOG', KEYDOBEFORESHOWDIALOG, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  if Assigned(FBeforeShowDialog) then
    FBeforeShowDialog(Self, DlgForm);
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFORESHOWDIALOG', KEYDOBEFORESHOWDIALOG)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOBEFORESHOWDIALOG', KEYDOBEFORESHOWDIALOG);
  {M}  end;
  {END MACRO}
end;

class function TgdcBase.GetSubSetList: String;
begin
  Result := 'All;ByID;ByName;OnlySelected;';
end;

{ TgdcObjectSet }

constructor TgdcObjectSet.Create(AgdClass: CgdcBase; const ASubType: TgdcSubType; const ASize: Integer = 32);
begin
  FgdClass := AgdClass;
  FSubType := ASubType;
  FCount := 0;
  SetLength(FArray, ASize);
  FgdClassList := TStringList.Create;
end;

destructor TgdcObjectSet.Destroy;
begin
  inherited;
  SetLength(FArray, 0);
  FgdClassList.Free;
end;

function TgdcObjectSet.Get_gdClass: CgdcBase;
begin
  Result := FgdClass;
end;

function TgdcObjectSet.Get_gdClassName: String;
begin
  if FgdClass <> nil then
    Result := FgdClass.ClassName
  else
    Result := '';
end;

function TgdcObjectSet.GetCount: Integer;
begin
  Result := FCount;
end;

function TgdcObjectSet.GetItems(Index: Integer): TID;
begin
  if (Index < 0) or (Index >= FCount) then
    raise Exception.Create(GetGsException(Self, 'Invalid index'));
  Result := FArray[Index];
end;

procedure TgdcObjectSet.Set_gdClass(const Value: CgdcBase);
begin
  if FgdClass <> Value then
  begin
    FgdClass := Value;
    FCount := 0;
  end;  
end;

function TgdcObjectSet.Add(const AnID: TID; const AgdClassName: String;
  const ASubType: String ): Integer;
begin
  Result := Find(AnID);
  if Result = -1 then
  begin
    if FCount = Size then
      SetLength(FArray, (Size + 1) * 2);
    FArray[FCount] := AnID;
    Result := FCount;
    AddgdClass(Result, AgdClassName, ASubType);
    Inc(FCount);
  end else
  begin
    AddgdClass(Result, AgdClassName, ASubType);
  end;
end;

function TgdcObjectSet.GetSize: Integer;
begin
  Result := High(FArray) - Low(FArray) + 1;
end;

class function TgdcBase.GetListTable(const ASubType: TgdcSubType): String;
begin
  //raise EgdcIBError.Create(Self.ClassName + ': GetListTable is not defined');
  Result := '';
end;

class function TgdcBase.GetListField(const ASubType: TgdcSubType): String;
begin
  Result := '';
end;

procedure TgdcBase.GetDistinctColumnValues(const AFieldName: String;
  S: TStrings; const DoSort: Boolean);
var
  q: TIBSQL;
begin
  Assert(S <> nil);
  Assert(AFieldName > '');

  S.Clear;
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := ReadTransaction;
    q.SQL.Text := 'SELECT DISTINCT ' + AFieldName + ' FROM ' + GetListTable(SubType);
    if DoSort then
      q.SQL.Text := q.SQL.Text + ' ORDER BY 1';
    q.ExecQuery;
    while not q.EOF do
    begin
      S.Add(q.Fields[0].AsString);
      q.Next;
    end;
    q.Close;
  finally
    q.Free;
  end;
end;

function TgdcBase.GetFieldNameComparedToParam(
  const AParamName: String): String;

{ TODO :
ограничения: мы не поддерживаем IN, BETWEEN
}

{ TODO : 
внимание! есть ошибка! если в запросе несколько
одноименных полей, то может вернуть неправильное
значение!

поскольку мы не можем найти имя таблицы, а только ее алиас...

}

  function _Sub(const S, AParamName: String; out ARelationName, AFieldName: String): Boolean;
  var
    B, E: Integer;
    Found: Boolean;
  begin
    if AParamName > '' then
    begin
      E := Pos(':' + UpperCase(AParamName), UpperCase(S)) - 1;
      B := 0;
      Found := True;
      repeat
        while (E > 0) and (S[E] in [' ', '=', '!', '<', '>', ')', '+', '-', '*', '/', '|', '"', #9, #13, #10]) do
          Dec(E);
        if E > 0 then
        begin
          B := E - 1;
          if S[E + 1] = '"' then
          begin
            while (B > 0) and (S[B] <> '"') do
              Dec(B);
          end else
          begin
            while (B > 0) and (S[B] in ['A'..'Z', 'a'..'z', '0'..'9', '_', '$']) do
              Dec(B);
          end;

          AFieldName := System.Copy(S, B + 1, E - B);

          if (B > 0) and (S[B] = '"') then
            Dec(B);

          if (AFieldName > '')
            and (not (AFieldName[1] in ['A'..'Z', 'a'..'z', '_']))
            and (S[E + 1] <> '"') then
          begin
            E := B;
            Found := False;
          end else
          begin
            Found := True;
            if S[E + 1] = '"' then
              AFieldName := '"' + AFieldName + '"';
          end;
        end else
          AFieldName := '';
      until Found;

      if (B > 1) and (S[B] = '.') then
      begin
        Dec(B);
        if S[B] = '"' then
          Dec(B);
        E := B;
        if S[E + 1] = '"' then
          while (B > 0) and (S[B] <> '"') do
            Dec(B)
        else
          while (B > 0) and (S[B] in ['A'..'Z', 'a'..'z', '0'..'9', '_', '$']) do
            Dec(B);
        ARelationName := System.Copy(S, B + 1, E - B);
        if S[E + 1] = '"' then
          ARelationName := '"' + ARelationName + '"';
      end else
        ARelationName := '';
    end else
    begin
      AFieldName := '';
      ARelationName := '';
    end;

    Result := AFieldName > '';
  end;

var
  RN: String;
  F: TField;
begin
  if _Sub(GetFromClause + GetWhereClause, AParamName, RN, Result) then
  begin
    if RN > '' then
      F := FindField({RN,} Result)
    else
      F := FindField(Result);
    if F <> nil then
      Result := F.FieldName
    else
      Result := '';  
  end else
    Result := '';
end;

procedure TgdcBase.LoadDialogDefaults(F: TgsStorageFolder; Dlg: TForm);
var
  L: TList;
  I: Integer;
begin
  L := TList.Create;
  try
    GetFieldList(L, GetDialogDefaultsFields);

    for I := 0 to L.Count - 1 do
      if TField(L[I]).IsNull then
      begin
        if F.ValueExists(TField(L[I]).FieldName) then
        try
          TField(L[I]).AsString := F.ReadString(TField(L[I]).FieldName);
        except
          on Exception do
            F.DeleteValue(TField(L[I]).FieldName);
        end;
      end;
  finally
    L.Free;
  end;
end;

procedure TgdcBase.SaveDialogDefaults(F: TgsStorageFolder; Dlg: TForm);
var
  L, L2: TList;
  I: Integer;
  PropInfo: PPropInfo;
  Fld: TField;
begin
  L := TList.Create;
  L2 := TList.Create;
  try
    GetFieldList(L, GetDialogDefaultsFields);

    // the intention here is to store only those
    // field values which controls are on the form
    { TODO : 
это не помогает. надо бы проверять только контролы
которые могут менять данные. а так подхватываются
и ДБЛэйблы, а это все портит }
    with Dlg do
      for I := 0 to ComponentCount - 1 do
      begin
        PropInfo := GetPropInfo(Components[I].ClassInfo, 'DataSource');
        if (PropInfo <> nil)
          and (PropInfo^.PropType^.Kind = tkClass)
          and (GetTypeData(PropInfo^.PropType^).ClassType.InheritsFrom(TDataSource)) then
        begin
          PropInfo := GetPropInfo(Components[I].ClassInfo, 'DataField');
          if (PropInfo <> nil) and (PropInfo^.PropType^.Kind = tkLString) then
          begin
            Fld := Self.FindField(GetStrProp(Components[I], PropInfo));
            if (Fld <> nil) and (L.IndexOf(Fld) <> -1) then
              L2.Add(Fld);
          end;
        end;
      end;

    for I := 0 to L2.Count - 1 do
    begin
      if TField(L2[I]).IsNull then
        F.DeleteValue(TField(L2[I]).FieldName)
      else
        F.WriteString(TField(L2[I]).FieldName, TField(L2[I]).AsString);
    end;
  finally
    L.Free;
    L2.Free;
  end;
end;

function TgdcBase.GetDialogDefaultsFields: String;
const
  Prohibited = ';ID;NAME;AFULL;ACHAG;AVIEW;RESERVED;PARENT;CREATIONDATE;CREATORKEY;EDITIONDATE;EDITORKEY;LB;RB;RUID;XID;DBID;';
var
  SL: TStringList;
  I: Integer;
  F: TField;
begin
  if FGetDialogDefaultsFieldsCached then
    Result := FGetDialogDefaultsFieldsCache
  else begin
    Result := '';
    SL := TStringList.Create;
    try
      Database.GetFieldNames(GetListTable(SubType), SL);
      for I := 0 to SL.Count - 1 do
        if Pos(';' + SL[I] + ';', ';' + GetListField(SubType) + Prohibited) = 0 then
        begin
          F := FindField(SL[I]);
          if (F <> nil) and (F.DefaultExpression = '') and (not (F is TBlobField)) and (F.Size < 64) then
            Result := Result + F.FieldName + ';';
        end;
    finally
      SL.Free;
    end;

    FGetDialogDefaultsFieldsCached := True;
    FGetDialogDefaultsFieldsCache := Result;
  end;
end;

function TgdcBase.ShowFieldInGrid(AField: TField): Boolean;
var
  AFieldName: String;
begin
  Assert((AField <> nil) and (AField.DataSet = Self));
  AFieldName := System.Copy(AField.Origin, Pos('.', AField.Origin) + 2, 255);
  SetLength(AFieldName, Length(AFieldName) - 1);
  Result := AField.Visible and (StrIPos(';' + AFieldName + ';', ';' + HideFieldsList) = 0);
end;

function TgdcBase.HideFieldsList: String;
begin
  Result := 'afull;achag;aview;';
end;

function TgdcObjectSet.Find(const AnID: TID): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if Items[I] = AnID then
    begin
      Result := I;
      break;
    end;
end;

procedure TgdcObjectSet.LoadFromStream(S: TStream);
var
  I: Integer;
  ID: TID;
  St: String;
begin
  if S.Position >= S.Size then
    Exit;
  S.Read(I, SizeOf(I));
  SetLength(St, I);
  S.Read(St[1], I);
  FgdClass := CgdcBase(FindClass(St));
  FCount := 0;
  S.Read(I, SizeOf(I));
  while I > 0 do
  begin
    S.Read(ID, SizeOf(ID));
{ TODO -oJulia : Пока считывать из потока будем без наименований классов и сабтайпов }
    Add(ID, '', '');
    Dec(I);
  end;
end;

procedure TgdcObjectSet.SaveToStream(S: TStream);
var
  I: Integer;
  ID: TID;
begin
  I := Length(gdClassName);
  S.Write(I, SizeOf(I));
  S.Write(gdClassName[1], I);
  I := Count;
  S.Write(I, SizeOf(I));
  for I := 0 to Count - 1 do
  begin
    ID := Items[I];
    S.Write(ID, SizeOf(ID));
  end;
end;

procedure TgdcObjectSet.Remove(const AnID: TID);
var
  I: Integer;
begin
  I := Find(AnID);
  if I <> -1 then
    Delete(I);
end;

procedure TgdcObjectSet.Delete(const Index: Integer);
var
  J: Integer;
begin
  if (Index < 0) or (Index >= Count) then
    raise Exception.Create(GetGsException(Self, 'Index is out of bounds'));
  for J := Index to Count - 2 do
    FArray[J] := FArray[J + 1];
  Dec(FCount);
  FgdClassList.Delete(Index);
end;

function TgdcObjectSet.GetSubType: TgdcSubType;
begin
  Result := FSubType;
end;

procedure TgdcObjectSet.SetSubType(const Value: TgdcSubType);
begin
  if Value <> FSubType then
  begin
    FSubType := Value;
    FCount := 0;
  end;
end;

procedure TgdcObjectSet.AddgdClass(const Index: Integer; const AgdClassName,
  ASubType: String);
begin
  if (Index < 0) or (Index > FgdClassList.Count) then
  begin
    raise EgdcException.Create('TgdcObjectSet: Некорректный индекс!');
  end;

  if Index = FgdClassList.Count then
  begin
    FgdClassList.Add(FormClassSubTypeString(AgdClassName, ASubType))
  end else
  begin
    FgdClassList[Index] := FgdClassList[Index] + ',' +
      FormClassSubTypeString(AgdClassName, ASubType);
  end;
end;

function TgdcObjectSet.FindgdClass(const Index: Integer; const AgdClassName,
  ASubType: String): Boolean;
var
//  HelpList: TStringList;
//  I: Integer;
  St, SubSt: String;
  Pos: Integer;
begin
  Result := False;
  if Index > -1 then
  begin
    St := FgdClassList[Index];
    Pos := AnsiPos(',', St);
    if Pos = 0 then
    begin
      Result := St = FormClassSubTypeString(AgdClassName, ASubType);
    end else
    begin
      while Pos > 0 do
      begin
        SubSt := Copy(St, 1, Pos - 1);
        if SubSt = FormClassSubTypeString(AgdClassName, ASubType) then
        begin
          Result := True;
          Exit;
        end;
        St := Copy(St, Pos + 1, Length(St) - Pos);
        Pos := AnsiPos(',', St);
      end;
      Result := St = FormClassSubTypeString(AgdClassName, ASubType);
    end;
  end;
end;

function TgdcObjectSet.FormClassSubTypeString(const gdClassName,
  SubType: String): String;
begin
  Result := AnsiUpperCase(gdClassName) + '(' + AnsiUpperCase(SubType) + ')';
end;

function TgdcObjectSet.FindgdClassByID(const AnID: TID; const AgdClassName,
  ASubType: String): Boolean;
var
  Index: Integer;  
begin
  Index := Find(AnID);
  Result := FindgdClass(Index, AgdClassName, ASubType);
end;

function TgdcObjectSet.GetgdInfo(Index: Integer): String;
begin
  if (Index < 0) or (Index >= FCount) then
    raise Exception.Create(GetGsException(Self, 'Invalid index'));
  Result := FgdClassList[Index];
end;

{ TgdcObjectSets }

constructor TgdcObjectSets.Create;
begin
  inherited Create(True);
end;

function TgdcObjectSets.Find(C: TgdcFullClass): TgdcObjectSet;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
  begin
    Result := (Items[I] as TgdcObjectSet);
    if (Result.gdClass = C.gdClass) and (Result.SubType = C.SubType) then
      exit;
  end;
  Result := nil;
end;

procedure TgdcObjectSets.LoadFromStream(S: TStream);
var
  I: Integer;
  ObjectSet: TgdcObjectSet;
begin
  Clear;
  S.Read(I, SizeOf(I));
  if I <> $66778899 then
    raise Exception.Create(GetGsException(Self, 'Invalid stream format'));
  S.Read(I, SizeOf(I));
  while I > 0 do
  begin
    ObjectSet := TgdcObjectSet.Create(TgdcBase, '');
    ObjectSet.LoadFromStream(S);
    Add(ObjectSet);
    Dec(I);
  end;
end;

procedure TgdcObjectSets.SaveToStream(S: TStream);
var
  I: Integer;
begin
  I := $66778899;
  S.Write(I, SizeOf(I));
  I := Count;
  S.Write(I, SizeOf(I));
  for I := 0 to Count - 1 do
    (Items[I] as TgdcObjectSet).SaveToStream(S);
end;

function TgdcBase.FindField(ARelationName,
  AFieldName: String): TField;
var
  I, P, L: Integer;
  Origin: String;
begin
  Result := nil;
  ARelationName := UpperCase(ARelationName);
  AFieldName := UpperCase(AFieldName);
  L := Length(ARelationName) + Length(AFieldName) + 5; // 5 = Length('"".""')
  for I := 0 to FieldCount - 1 do
  begin
    Origin := UpperCase(Fields[I].Origin);
    P := Pos(ARelationName, Origin);
    if (P > 0) and (Pos(AFieldName, Origin) > P) and (Length(Origin) = L) then
    begin
      Result := Fields[I];
      break;
    end;
  end;

(*
  if ARelationName = '' then
    Result := FindField(AFieldName)
  else begin
    Result := nil;
    for I := 0 to FieldCount - 1 do
      if (AnsiCompareText(AFieldName, FieldNameByAliasName(Fields[I].FieldName)) = 0)
        and (AnsiCompareText(ARelationName, RelationByAliasName(Fields[I].FieldName)) = 0) then
    begin
      Result := Fields[I];
      break;
    end;
  end;
*)
end;

function TgdcBase.FieldByName(const ARelationName,
  AFieldName: String): TField;
begin
  Result := FindField(ARelationName, AFieldName);
  if Result = nil then
    raise EgdcException.CreateObj(
      Format('Field "%s" (relation "%s") not found',
        [AFieldName, ARelationName]), Self);
end;

function TgdcBase.IsReverseOrder(const AFieldName: String): Boolean;
begin
  Result := False;
end;

procedure TgdcBase.LoadFromFile(const AFileName: String);
var
  S: TStream;
  FN: String;
begin
  FN := QueryLoadFileName(AFileName);
  if (FN > '') and
    (MessageBox(0, PChar('Загрузить данные из файла ' + FN + ' ?'),
      'Загрузка данных', MB_TASKMODAL + MB_ICONQUESTION + MB_YESNO) = IDYES)
  then
  begin
    S := TFileStream.Create(FN, fmOpenRead);
    try
      LoadFromStream(S);
    finally
      S.Free;
    end;
  end;  
end;

procedure TgdcBase.SaveToFile(const AFileName: String = ''; const ADetail: TgdcBase = nil;
  const BL: TBookmarkList = nil; const OnlyCurrent: Boolean = True);
var
  S: TStream;
  FN: String;
begin
  if Assigned(BL) then
    BL.Refresh;

  FN := QuerySaveFileName(AFileName);
  if FN > '' then
  begin
    S := TFileStream.Create(FN, fmCreate);
    try
      SaveToStream(S, ADetail, BL, OnlyCurrent);
    finally
      S.Free;
    end;
  end;
end;

procedure TgdcBase.SaveToStream(Stream: TStream;  DetailDS: TgdcBase;
  const BL: TBookmarkList = nil; const OnlyCurrent: Boolean = True);
var
  MS: TMemoryStream;
  OS: TgdcObjectSet;
  Bm: TBookmarkStr;
  I: Integer;

  procedure SaveDetail;
  var
    DBm: TBookmarkStr;
  begin
    if DetailDS <> nil then
    begin
      DetailDS.DisableControls;
      try
        DBm := DetailDS.Bookmark;
        DetailDS.First;
        while not DetailDS.EOF do
        begin
          DetailDS._SaveToStream(MS, OS, nil, nil);
          DetailDS.Next;
        end;
        DetailDS.Bookmark := DBm;
      finally
        DetailDS.EnableControls;
      end;
    end;
  end;

begin
  MS := TMemoryStream.Create;
  OS := TgdcObjectSet.Create(TgdcBase, '');

  Space;
  AddText(#13#10+ TimeToStr(Time) + ': Началось сохранение данных в поток.'#13#10, clBlack, True);

  try
    if BL <> nil then
      BL.Refresh;

    if DetailDS <> nil then
      DetailDS.DisableControls;
    try
      if OnlyCurrent then
      begin
        _SaveToStream(MS, OS, nil, nil);
        SaveDetail;
      end else begin
        Bm := Bookmark;
        DisableControls;

        try
          if BL = nil then
          begin
            First;
            while not EOF do
            begin
              _SaveToStream(MS, OS, nil, nil);
              SaveDetail;
              Next;
            end;
          end else
          begin
            for I := 0 to BL.Count - 1 do
            begin
              Bookmark := BL[I];
              _SaveToStream(MS, OS, nil, nil);
              SaveDetail;
            end;
          end;
        finally
          Bookmark := Bm;
          EnableControls;
        end;
      end;
    finally
      if DetailDS <> nil then
        DetailDS.EnableControls;
    end;

    // в процессе сохранения мы генерировали РУИДы
    // сохраним теперь их окончательно
    if Transaction.InTransaction then
      Transaction.CommitRetaining;

  finally
    Space;
    AddText(#13#10+ TimeToStr(Time) + ': Закончено сохранение данных в поток.'#13#10, clBlack, True);
    Space;

    OS.SaveToStream(Stream);
    Stream.CopyFrom(MS, 0);

    MS.Free;
    OS.Free;
  end;
end;

procedure TgdcBase.LoadFromStream(Stream: TStream);
var
  OS: TgdcObjectSet;
  DidActivate: Boolean;
begin
  DidActivate := False;
  OS := TgdcObjectSet.Create(TgdcBase, '');
  try
    try
      DidActivate := ActivateTransaction;
      OS.LoadFromStream(Stream);
      _LoadFromStream(Stream, nil, OS, nil);
      if DidActivate and Transaction.InTransaction then
        Transaction.Commit;
    except
      if DidActivate and Transaction.InTransaction then
        Transaction.Rollback;
      raise;
    end;
  finally
    OS.Free;
  end;
end;

function TgdcBase.QuerySaveFileName(const AFileName: String): String;
  function CorrectFileName(const FN: String): String;
  const
    CorrectSymbols = ['A'..'Z', 'a'..'z', 'А'..'я', '_', '0'..'9', ' '];
  var
    S: String;
    i: Integer;

  begin
    S := '';
    for I := 1 to Length(FN) do
      if FN[I] in CorrectSymbols then
        S := S + FN[I];
    Result := S;
  end;
begin
  if AFileName = '' then
  begin
    with TSaveDialog.Create(FParentForm) do
    try
      Options := [ofOverwritePrompt,ofHideReadOnly,ofPathMustExist,ofNoReadOnlyReturn,ofEnableSizing];
      DefaultExt := 'dat';
      Filter := 'Dat files|*.dat';
      {$IFDEF GEDEMIN}
      if Assigned(UserStorage) then
      begin
        InitialDir := UserStorage.ReadString('GDC\' + Self.ClassName + SubType, 'SaveDir', '');
        //зачем считывать имя последнего сохраненного файла?
        //Не легче ли указывать имя а-ля FieldByName(GetListField(SubType)).AsString
        //так логичнее. Если я сохраняю настройку с названием Справочники
        //то название файла логичнее сделать Справочники.dat,
        //а не брать имя последнего сохраненного файла 22222.dat
        FileName := CorrectFileName(FieldByName(GetListField(SubType)).AsString);

      end;
      {$ENDIF}
      if not Execute then
      begin
        Result := '';
        exit;
      end;
      {$IFDEF GEDEMIN}
      if Assigned(UserStorage) then
      begin
        UserStorage.WriteString('GDC\' + Self.ClassName + SubType, 'SaveDir', InitialDir);
        UserStorage.WriteString('GDC\' + Self.ClassName + SubType, 'SaveFileName', FileName);
      end;
      {$ENDIF}
      Result := FileName;
    finally
      Free;
    end
  end else
    Result := AFileName;
end;

function TgdcBase.QueryLoadFileName(const AFileName: String): String;
begin
  Result := AFileName;

  while (Result = '') or (not FileExists(Result)) do
    with TOpenDialog.Create(FParentForm) do
    try
      Options := [ofPathMustExist,ofFileMustExist,ofEnableSizing];
      DefaultExt := 'dat';
      Filter := 'Dat files|*.dat';
      {$IFDEF GEDEMIN}
      if (AFileName = '') and Assigned(UserStorage) then
      begin
        InitialDir := UserStorage.ReadString('GDC\' + Self.ClassName + SubType, 'SaveDir', '');
        FileName := UserStorage.ReadString('GDC\' + Self.ClassName + SubType, 'SaveFileName', '');
      end else
      {$ENDIF}
        FileName := Result;
      if not Execute then
      begin
        Result := '';
        exit;
      end;
      {$IFDEF GEDEMIN}
      if (AFileName = '') and Assigned(UserStorage) then
      begin
        UserStorage.WriteString('GDC\' + Self.ClassName + SubType, 'SaveDir', InitialDir);
        UserStorage.WriteString('GDC\' + Self.ClassName + SubType, 'SaveFileName', FileName);
      end;
      {$ENDIF}
      Result := FileName;
    finally
      Free;
    end;
end;

procedure TgdcBase.GetWhereClauseConditions(S: TStrings);
var
  I: Integer;
  Str: String;
begin
  { TODO :
сабсет бый ид может быть перекрыт!
например в выписках для ускорения }
  if HasSubSet('ByID') then
    S.Add(Format('%s.%s=:%s', [GetListTableAlias, GetKeyField(SubType), GetKeyField(SubType)]))
  else if HasSubSet('ByName') then
    S.Add(Format('%s.%s=:%s', [GetListTableAlias, GetListField(SubType), GetListField(SubType)]))
  { TODO -oJulia : Проблема не только с сабсетом ByID,
  но и с сабсетом OnlySelected. В некоторых случаях
  его тоже нужно перекрывать для ускорения. Тем более,
  что он аналогичен сабсету ByID.
  Его нельзя перекрыть полностью, потому как этот сабсет может
  использоваться во взаимодействии с другими.
  Поэтому он будет формироваться два раза (как минимум)
  для объектов, в которых перекрыт. }
  else if HasSubSet('OnlySelected') then
  begin
    Str := '';
    for I := 0 to FSelectedID.Count - 1 do
    begin
      if Length(Str) >= 8192 then break;
      Str := Str + IntToStr(FSelectedID[I]) + ',';
    end;
    if Str = '' then
      Str := '-1'
    else
      SetLength(Str, Length(Str) - 1);
    S.Add(Format('%s.%s IN (%s)', [GetListTableAlias, GetKeyField(SubType), Str]));
  end;
end;

function TgdcBase.GetCreationDate: TDateTime;
begin
  if tiCreationInfo in gdcTableInfos then
    Result := FieldByName('creationdate').AsDateTime
  else
    Result := GetEditionDate;
end;

function TgdcBase.GetCreatorKey: TID;
begin
  if tiCreationInfo in gdcTableInfos then
    Result := FieldByName('creatorkey').AsInteger
  else
    Result := GetEditorKey;
end;

function TgdcBase.GetCreatorName: String;
var
  q: TIBSQL;
begin
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := ReadTransaction;
    q.SQL.Text := 'SELECT name FROM gd_contact WHERE id=:ID';
    q.Params[0].AsInteger := CreatorKey;
    q.ExecQuery;
    if q.EOF then
      Result := ''
    else
      Result := q.Fields[0].AsString;
  finally
    q.Free;
  end;
end;

function TgdcBase.GetEditionDate: TDateTime;
var
  q: TIBSQL;
begin
  if tiEditionInfo in gdcTableInfos then
    Result := FieldByName('editiondate').AsDateTime
  else begin
    q := TIBSQL.Create(nil);
    try
      q.Database := Database;
      q.Transaction := ReadTransaction;
      q.SQL.Text := 'SELECT modified FROM gd_ruid WHERE id=:ID';
      q.Params[0].AsInteger := ID;
      q.ExecQuery;
      if not q.EOF then
        Result := q.Fields[0].AsDateTime
      else
        Result := Now;
    finally
      q.Free;
    end;
  end;
end;

function TgdcBase.GetEditorKey: TID;
var
  q: TIBSQL;
begin
  if tiEditionInfo in gdcTableInfos then
    Result := FieldByName('editorkey').AsInteger
  else begin
    q := TIBSQL.Create(nil);
    try
      q.Database := Database;
      q.Transaction := ReadTransaction;
      q.SQL.Text := 'SELECT editorkey FROM gd_ruid WHERE id=:ID';
      q.Params[0].AsInteger := ID;
      q.ExecQuery;
      if not q.EOF then
        Result := q.Fields[0].AsInteger
      else
        Result := IBLogin.ContactKey;
    finally
      q.Free;
    end;
  end;
end;

function TgdcBase.GetEditorName: String;
var
  q: TIBSQL;
begin
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := ReadTransaction;
    q.SQL.Text := 'SELECT name FROM gd_contact WHERE id=:ID';
    q.Params[0].AsInteger := EditorKey;
    q.ExecQuery;
    if q.EOF then
      Result := ''
    else
      Result := q.Fields[0].AsString;
  finally
    q.Free;
  end;
end;

function TgdcBase.GetExtraConditions: TStrings;
begin
  Result := FExtraConditions;
end;

procedure TgdcBase.DoAfterExtraChanged(Sender: TObject);
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  WasActive: Boolean;
begin
  {@UNFOLD MACRO INH_ORIG_SENDER('TGDCBASE', 'DOAFTEREXTRACHANGED', KEYDOAFTEREXTRACHANGED)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOAFTEREXTRACHANGED);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOAFTEREXTRACHANGED]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(Sender)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOAFTEREXTRACHANGED', KEYDOAFTEREXTRACHANGED, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  WasActive := Active;
  Close;
  FSQLInitialized := False;
  Active := WasActive;
  
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTEREXTRACHANGED', KEYDOAFTEREXTRACHANGED)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOAFTEREXTRACHANGED', KEYDOAFTEREXTRACHANGED);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.GetDSModified: Boolean;
begin
  Result := FDSModified or
    (State = dsInsert) or
    (FOldValues.Count > 0) or
    (CachedUpdates and UpdatesPending);
end;

procedure TgdcBase.DoAfterTransactionEnd(Sender: TObject);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_SENDER('TGDCBASE', 'DOAFTERTRANSACTIONEND', KEYDOAFTERTRANSACTIONEND)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOAFTERTRANSACTIONEND);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOAFTERTRANSACTIONEND]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(Sender)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOAFTERTRANSACTIONEND', KEYDOAFTERTRANSACTIONEND, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  inherited;
  FDSModified := False;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTERTRANSACTIONEND', KEYDOAFTERTRANSACTIONEND)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOAFTERTRANSACTIONEND', KEYDOAFTERTRANSACTIONEND);
  {M}  end;
  {END MACRO}
end;

function TgdcBase.GetSelectedID: TgdKeyArray;
begin
  Result := FSelectedID;
end;

procedure TgdcBase.AddToSelectedID(const AnID: Integer = -1);
var
  AddId: Integer;
begin
  if AnID = -1 then
    AddId := ID
  else
    AddId := AnID;

  FSelectedID.Add(AddId, True);

  if HasSubSet('OnlySelected') then
    FSQLInitialized := False;
end;

procedure TgdcBase.AddToSelectedID(ASelectedID: TgdKeyArray);
var
  I: Integer;
begin
  for I := 0 to ASelectedID.Count - 1 do
    FSelectedID.Add(ASelectedID.Keys[I], True);

  if HasSubSet('OnlySelected') then
    FSQLInitialized := False;
end;

procedure TgdcBase.RemoveFromSelectedID(const AnID: Integer = -1);
var
  DelId: Integer;
begin
  if AnID = -1 then
    DelId := ID
  else
    DelId := AnID;

  FSelectedID.Remove(DelId);

  { TODO :
тут большая проблема которую еще предстоит решить
поскольку набор выделенных ИД задается не через
параметры а через условие в запросе с непосредстенным
подставлением ИД, то приходится каждый раз переформировать
запрос, что может быть очень больно! }
  if HasSubSet('OnlySelected') then
    FSQLInitialized := False;
end;

function TgdcBase.CheckTheSame(var AnAnswer: Word; Modify: Boolean = False): Boolean;
var
  q: TIBSQL;
  I: Integer;
  CDS: TClientDataSet;
  R: TatRelation;
  F: TatRelationField;
begin
  if not (State = dsInsert) then
    raise EgdcException.CreateObj('Объект должен находиться в состоянии вставки!', Self);
{  if SubSet <> 'All' then
    raise EgdcException.CreateObj('Object must has "All" subset', Self);}

  Result := False;
  if CheckTheSameStatement > '' then
  begin
    q := TIBSQL.Create(nil);
    CDS := TClientDataSet.Create(nil);
    try
      q.Database := Database;
      q.Transaction := ReadTransaction;
      q.SQL.Text := CheckTheSameStatement;
      q.ExecQuery;
      q.Next;
      if q.RecordCount = 1 then
      begin
        AddText(#13#10 + 'Объект найден по уникальному ключу'#13#10, clBlue);
        if (sLoadFromStream in BaseState) and NeedDeleteTheSame(SubType) then
        begin
          DeleteTheSame(q.Fields[0].AsInteger, FieldByName(GetListField(SubType)).AsString);
        end else

        begin
          if Modify and (sLoadFromStream in BaseState) then
          begin
            for I := 0 to FieldDefs.Count - 1 do
            begin
            //Будем добавлять поля по-одному, т.к. нам нужно чтобы они все были необязательны
              CDS.FieldDefs.Add(FieldDefs[I].Name, FieldDefs[I].DataType, FieldDefs[I].Size, False)
            end;
            CDS.CreateDataSet;
            CDS.Open;
            CDS.Insert;
            for I := 0 to Fields.Count - 1 do
            begin
              if (CDS.FieldByName(Fields[I].FieldName).DataType = ftString) and
                (FieldByName(Fields[I].FieldName).AsString = '')
              then
                CDS.FieldByName(Fields[I].FieldName).AsString := ''
              else
                CDS.FieldByName(Fields[I].FieldName).Value := FieldByName(Fields[I].FieldName).Value;
            end;
            CDS.Post;
          end;

          Cancel;
          //Result := Locate(GetKeyField(SubType), q.Fields[0].AsInteger, []);
          ID := q.Fields[0].AsInteger;
          Result := RecordCount > 0;
          if not Result then
            raise EgdcIBError.Create('Запись ' + GetListTable(SubType) + ' '+
              ' с идентификатором ' +  q.Fields[0].AsString +
              ' не найдена! ');

          if Modify and ModifyFromStream
            and (sLoadFromStream in BaseState)
            and CheckNeedModify(CDS, nil, AnAnswer) then
            try
              Edit;
              for I := 0 to Fields.Count - 1 do
              begin
                R := nil;
                F := nil;
                if (FieldByName(Fields[I].FieldName).AsString = IntToStr(ID)) and
                  Assigned(atDatabase) then
                begin
                 //Проверяем не является ли наше поле, содержащее значение = keyfield, ссылкой
                  R := atDatabase.Relations.ByRelationName(RelationByAliasName(Fields[I].FieldName));
                  if Assigned(R) then
                    F := R.RelationFields.ByFieldName(FieldNameByAliasName(Fields[I].FieldName));
                end;

                if ((not Assigned(R)) or (not Assigned(F)) or (F.References = nil)) and
                  (AnsiCompareText(Fields[I].FieldName, GetKeyField(SubType)) <> 0)
                then
                begin
                  if (FieldByName(Fields[I].FieldName).DataType = ftString) and
                    (CDS.FieldByName(Fields[I].FieldName).AsString = '')
                  then
                    FieldByName(Fields[I].FieldName).AsString := ''
                  else
                    FieldByName(Fields[I].FieldName).Value := CDS.FieldByName(Fields[I].FieldName).Value;
                end;
              end;
              Post;
              AddText('Объект обновлен данными из потока!', clBlack);
              Space;
            except
              Cancel;
            end;
        end;
      end;
    finally
      q.Free;
      CDS.Free;
    end;
  end;
end;

function TgdcBase.CheckTheSameStatement: String;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_CHECKTHESAMESTATEMENT('TGDCBASE', 'CHECKTHESAMESTATEMENT', KEYCHECKTHESAMESTATEMENT)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYCHECKTHESAMESTATEMENT);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYCHECKTHESAMESTATEMENT]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'CHECKTHESAMESTATEMENT', KEYCHECKTHESAMESTATEMENT, Params, LResult) then
  {M}          begin
  {M}            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
  {M}              Result := String(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'CHECKTHESAMESTATEMENT' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не строковый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Result := '';//Inherited CheckTheSameStatement;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  //Стандартные записи ищем по идентификатору
  if (FieldByName(GetKeyField(SubType)).AsInteger < cstUserIDStart) and
    not(FieldByName(GetKeyField(SubType)).IsNull)
  then
    Result := Format('SELECT %0:s FROM %1:s WHERE %0:s=%2:s ',
      [GetKeyField(SubType), GetListTable(SubType),
       FieldByName(GetKeyField(SubType)).AsString])
  else
    Result := '';
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'CHECKTHESAMESTATEMENT', KEYCHECKTHESAMESTATEMENT)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'CHECKTHESAMESTATEMENT', KEYCHECKTHESAMESTATEMENT);
  {M}  end;
  {END MACRO}
end;

class function TgdcBase.CommitRequired: Boolean;
begin
  Result := False;
end;

procedure TgdcBase.ExecSingleQuery(const S: String; Param: Variant);
var
  q: TIBSQL;
  I, CutOff: Integer;
  DidActivate: Boolean;
begin
  DidActivate := False;
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := Transaction;
    DidActivate := ActivateTransaction;
    try
      CutOff := 5;
      repeat
        try
          q.Close;
          q.SQL.Text := S;
          q.Prepare;
          if q.Params.Count > 0 then
          begin
            if not VarIsArray(Param) then
              Param := VarArrayOf([Param]);
            for I := 0 to q.Params.Count - 1 do
              q.Params[I].AsVariant := Param[I];
          end;
          q.ExecQuery;
          CutOff := 0;
        except
          on E: EIBError do
          begin
            if (E.IBErrorCode = isc_lock_conflict)
              and DidActivate
              //and AllowCloseTransaction
              and (CutOff > 0) then
            begin
              Transaction.Rollback;
              Sleep(500);
              Dec(CutOff);
              Transaction.StartTransaction;
            end else
              raise;
          end else
            raise;
        end;
      until CutOff = 0;
    except
      if DidActivate and Transaction.InTransaction then
        Transaction.RollBack;
      raise;
    end;
  finally
    if DidActivate and Transaction.InTransaction then
      Transaction.Commit;
    q.Free;
  end;
end;

function TgdcBase.GetFromClause(const ARefresh: Boolean = False): String;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_GETFROMCLAUSE('TGDCBASE', 'GETFROMCLAUSE', KEYGETFROMCLAUSE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYGETFROMCLAUSE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYGETFROMCLAUSE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), ARefresh]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'GETFROMCLAUSE', KEYGETFROMCLAUSE, Params, LResult) then
  {M}          begin
  {M}            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
  {M}              Result := String(LResult)
  {M}            else
  {M}              begin
  {M}                raise Exception.Create('Для метода ''' + 'GETFROMCLAUSE' + ' ''' +
  {M}                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
  {M}                  'Из макроса возвращен не строковый тип');
  {M}              end;
  {M}            exit;
  {M}          end;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Result := '';//Inherited GetFromClause(ARefresh);
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  Result := Format('FROM %s %s ', [GetListTable(SubType), GetListTableAlias]);
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'GETFROMCLAUSE', KEYGETFROMCLAUSE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'GETFROMCLAUSE', KEYGETFROMCLAUSE);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.InternalSetFieldData(Field: TField; Buffer: Pointer);
var
  I: Integer;
  Found: Boolean;
  FV: TFieldValue;
begin
  if FDataTransfer then
    inherited InternalSetFieldData(Field, Buffer)
  else begin
    if State = dsEdit then
    begin
      Found := False;
      for I := 0 to FOldValues.Count - 1 do
        if AnsiCompareText((FOldValues[I] as TFieldValue).FieldName, Field.FieldName) = 0 then
        begin
          // если поле редактировали дважды и второй раз восстановили
          // первоначальное значение то считаем, что поле не трогали вообще
          if ((FOldValues[I] as TFieldValue).Value = Field.AsString) and
            ((FOldValues[I] as TFieldValue).IsNull = Field.IsNull) then
            FOldValues.Delete(I);
          Found := True;
          break;
        end;
      if not Found then
      begin
        FV := TFieldValue.Create;
        FV.FieldName := Field.FieldName;
        FV.Value := Field.AsString;
        FV.IsNull := Field.IsNull;
        FOldValues.Add(FV);
      end;
    end;
    inherited InternalSetFieldData(Field, Buffer);
    if not FIsNewRecord then
    begin
      SyncField(Field);
      if (FFieldsCallDoChange.Count = 0) or
        (FFieldsCallDoChange.IndexOf(Field.FieldName) > -1) then
        DoFieldChange(Field);
    end;
  end;
end;

procedure TgdcBase.InternalPrepare;
var
  I, J: Integer;
begin
  if not FSQLInitialized then
    InitSQL;

  inherited InternalPrepare;

  { TODO :
сохранять-восстанавливать надо только те параметры
которые не участвуют в связи мастер-дитэйл }
  if FSavedParams.Count > 0 then
  begin
    for I := 0 to FSavedParams.Count - 1 do
      for J := 0 to Params.Count - 1 do
        with FSavedParams[I] as TFieldValue do
          if AnsiCompareText(Params[J].Name, FieldName) = 0 then
          begin
            if IsNull then
              Params[J].Clear
            else
              Params[J].AsString := Value;
            break;  
          end;

    FSavedParams.Clear;
  end;
end;

procedure TgdcBase.UnPrepare;
begin
  InternalUnprepare;
end;

procedure TgdcBase.InternalOpen;
begin
  ActivateConnection;
  ActivateReadTransaction;
  if not FSQLInitialized then
    InitSQL;
  InternalSetParamsFromCursor;
  try
    inherited InternalOpen;
  except
    on E: EIBError do
    begin
      if E.IBErrorCode = 335544344 then
      begin
        MessageBox(ParentHandle,
          'Произошла ошибка при создании файла сортировки.'#13#10 +
          'Вероятно закончилось свободное место на диске, где'#13#10 +
          'находится каталог для временных файлов сервера'#13#10 +
          'Interbase/Firebird. Освободите место, увеличте размер'#13#10 +
          'диска или переформулируйте запрос, чтобы он приводил'#13#10 +
          'к меньшей выборке данных.',
          'Ошибка',
          MB_OK or MB_ICONHAND);
        Abort;
      end else
        raise;
    end;
  end;
end;

procedure TgdcBase._DoOnNewRecord;
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
  FN: String;
  I: Integer;
  MO: TDataSet;
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', '_DOONNEWRECORD', KEY_DOONNEWRECORD)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEY_DOONNEWRECORD);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEY_DOONNEWRECORD]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          '_DOONNEWRECORD', KEY_DOONNEWRECORD, Params, LResult) then exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}

  // проверим права на создание записи
  if not CanCreate then
    raise EgdcException.CreateObj('Access denied', Self);

  // присваиваем уникальный идентификатор записи
  if gdcBaseInterface.tiID in gdcTableInfos then
  begin
    FieldByName(GetKeyField(SubType)).AsInteger := GetNextID;
  end;

  if gdcBaseInterface.tiXID in gdcTableInfos then
  begin
    FieldByName('xid').AsInteger := FieldByName(GetKeyField(SubType)).AsInteger;
  end;

  if gdcBaseInterface.tiDBID in gdcTableInfos then
  begin
    if FieldByName(GetKeyField(SubType)).AsInteger < cstUserIDStart then
      FieldByName('dbid').AsInteger := cstEtalonDBID
    else
      FieldByName('dbid').AsInteger := IBLogin.DBID;
  end;

  // если есть поле Дизэйблед, то присваиваем его
  if gdcBaseInterface.tiDisabled in gdcTableInfos then
  begin
    FieldByName('disabled').AsInteger := 0;
  end;

  // присваиваем права записи по-умолчанию
  if Assigned(IBLogin) then
  begin
    if tiCreationInfo in gdcTableInfos then
    begin
      FieldByName('CREATORKEY').AsInteger := IBLogin.ContactKey;
      FieldByName('CREATIONDATE').AsDateTime := Now;
    end;

    if tiEditionInfo in gdcTableInfos then
    begin
      FieldByName('EDITORKEY').AsInteger := IBLogin.ContactKey;
      FieldByName('EDITIONDATE').AsDateTime := Now;
    end;

    if tiAView in gdcTableInfos then
      FieldByName('aview').AsInteger := IBLogin.InGroup;
    if tiAChag in gdcTableInfos then
      FieldByName('achag').AsInteger := IBLogin.InGroup;
    if tiAFull in gdcTableInfos then
      FieldByName('afull').AsInteger := IBLogin.InGroup;
  end else
    raise EgdcException.CreateObj('IBLogin is not assigned', Self);

  // если объект связан с другим объектом, то проинициализируем ссылку
  if (MasterSource <> nil)
    and (MasterSource.DataSet <> nil)
    and MasterSource.DataSet.Active then
    MO := MasterSource.DataSet
  else
    MO := nil;

  if (MO <> nil) and (MO.State <> dsSetKey) then
    with FgdcDataLink do
  begin
    if FSetTable = '' then
    begin
      for I := 0 to FDetailField.Count - 1 do
        if (UpperCase(FDetailField[I]) <> 'LB') and (UpperCase(FDetailField[I]) <> 'RB') then
        begin
          FN := GetFieldNameComparedToParam(FDetailField[I]);

          if (AnsiCompareText(GetKeyField(SubType), FN) <> 0)
            or (not MO.FieldByName(FMasterField[I]).IsNull) then
          begin
            if FindField(FN) <> nil then
            begin
              FieldByName(FN).Assign(MO.FieldByName(FMasterField[I]));
            end else
              { TODO :
  не всегда надо присваивать детальные поля!
  может вместо эксепшена ничего не делать? }
              raise EgdcException.CreateObj(Format('Detail field "%s" to set not found.', [FN]), Self);
          end;
        end
    end else begin
      { TODO : непосредственно прописываем имя поля ИД }
      FieldByName(cstSetPrefix + FSetMasterField).AsInteger := MO.FieldByName('id').AsInteger;
      FieldByName(cstSetPrefix + FSetItemField).AsInteger := ID;
    end;
  end;

  { TODO : а если для строкового поля дефаулт значение пустая строка? }
  for i := 0 to Fields.Count - 1 do
  begin
    if (Fields[i].IsNull) and (Fields[i].DefaultExpression <> '') then
    begin
      Fields[i].Value := Fields[i].DefaultExpression;
    end;
  end;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', '_DOONNEWRECORD', KEY_DOONNEWRECORD)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', '_DOONNEWRECORD', KEY_DOONNEWRECORD);
  {M}  end;
  {END MACRO}
end;

class function TgdcBase.GetViewFormClassName(
  const ASubType: TgdcSubType): String;
begin
  Result := '';
end;

class function TgdcBase.IsAbstractClass: Boolean;
begin
  Result := Self.ClassNameIs('TgdcBase');
end;

function TgdcBase.GetSubSet: TgdcSubSet;
begin
  if Assigned(FSubSets) then
    Result := FSubSets.CommaText
  else
    Result := '';
end;

function TgdcBase.GetSubSetCount: Integer;
begin
  Result := FSubSets.Count;
end;

function TgdcBase.GetSubSets(Index: Integer): TgdcSubSet;
begin
  Result := FSubSets[Index];
end;

procedure TgdcBase.SetSubSets(Index: Integer; const Value: TgdcSubSet);
begin
  if CheckSubSet(Value) then
    FSubSets[Index] := Value
  else
    raise EgdcException.CreateObj('Invalid sub set', Self);  
end;

procedure TgdcBase.DeleteSubSet(const Index: Integer);
var
  WasActive: Boolean;
begin
  if Index > -1 then
  begin
    WasActive := Active;
    Close;
    FSubSets.Delete(Index);
    FSQLInitialized := False;
    Active := WasActive;
  end;
end;

function TgdcBase.HasSubSet(const ASubSet: TgdcSubSet): Boolean;
begin
  Result := FSubSets.IndexOf(ASubSet) <> -1;
end;

procedure TgdcBase.RemoveSubSet(const ASubSet: TgdcSubSet);
begin
  DeleteSubSet(FSubSets.IndexOf(ASubSet));
end;

procedure TgdcBase.AddSubSet(const ASubSet: TgdcSubSet);
var
  WasActive: Boolean;
begin
  if not CheckSubSet(ASubSet) then
    raise EgdcException.CreateObj('Invalid sub set', Self);

  if (FSubSets.IndexOf(ASubSet) = -1) then
  begin
    WasActive := Active;
    Close;
    FSubSets.Add(ASubSet);
    FSQLInitialized := False;
    Active := WasActive;
  end;

end;

procedure TgdcBase.ClearSubSets;
var
  WasActive: Boolean;
begin
  WasActive := Active;
  Close;
  FSubSets.Clear;
  FSubSets.Add('All');
  FSQLInitialized := False;
  Active := WasActive;
end;

procedure TgdcBase.InternalUnPrepare;
var
  I: Integer;
  FV: TFieldValue;
  SL: TStringList;
begin
  FSavedParams.Clear;
  SL := TStringList.Create;
  try
    for I := 0 to Params.Count - 1 do
    begin
      if SL.IndexOf(Params[I].Name) = -1 then
      begin
        FV := TFieldValue.Create;
        FV.FieldName := Params[I].Name;
        FV.Value := Params[I].AsString;
        FV.IsNull := Params[I].IsNull;
        FSavedParams.Add(FV);
        SL.Add(Params[I].Name);
      end;
    end;
  finally
    SL.Free;
  end;

  inherited;
end;

procedure TgdcBase.LoadDialogDefaults;
{$IFDEF GEDEMIN}
var
  F: TgsStorageFolder;
  DlgForm: TForm;
{$ENDIF}
begin
  if Assigned(UserStorage) and UserStorage.ReadBoolean('Options', 'DialogDefaults', True) then
  begin
    if FDlgStack.Count > 0 then
    begin
      {$IFDEF GEDEMIN}
      DlgForm := FDlgStack.Peek as TForm;

      if Assigned(UserStorage) then
      begin
        F := UserStorage.OpenFolder('GDC\' + ClassName + SubType + '\' + DlgForm.ClassName, False, False);
        try
          if F <> nil then
            LoadDialogDefaults(F, DlgForm);
        finally
          UserStorage.CloseFolder(F);
        end;
      end;
      {$ENDIF}
    end else
      raise Exception.Create(GetGsException(Self, 'No dialog form found'));
  end;    
end;

procedure TgdcBase.SaveDialogDefaults;
{$IFDEF GEDEMIN}
var
  DlgForm: TForm;
  F: TgsStorageFolder;
{$ENDIF}
begin
  if Assigned(UserStorage) and UserStorage.ReadBoolean('Options', 'DialogDefaults', True) then
  begin
    if FDlgStack.Count > 0 then
    begin
      {$IFDEF GEDEMIN}
      DlgForm := FDlgStack.Peek as TForm;

      if Assigned(UserStorage) and (GetDialogDefaultsFields > '') then
      begin
        F := UserStorage.OpenFolder('GDC\' + ClassName + SubType + '\' + DlgForm.ClassName, True, False);
        try
          if F <> nil then
            SaveDialogDefaults(F, DlgForm);
    { TODO :  тут надо проверить и если ничего не сохранено удалить папку }
        finally
          UserStorage.CloseFolder(F);
        end;
      end;
      {$ENDIF}
    end else
      raise Exception.Create(GetGsException(Self, 'No dialog form found'));
  end;
end;

function TgdcBase.CreateReadIBSQL: TIBSQL;
begin
  Result := TIBSQL.Create(nil);
  Result.Database := Database;
  if ReadTransaction = nil then
    Result.Transaction := gdcBaseManager.ReadTransaction
  else
    Result.Transaction := ReadTransaction;
end;

function TgdcBase.CreateReadIBSQL(out DidActivate: Boolean): TIBSQL;
begin
  Result := CreateReadIBSQL;
  DidActivate := ActivateReadTransaction;
end;

class function TgdcBase.CreateSingularByID(AnOwner: TComponent;
  const AnID: TID; const ASubType: String): TgdcBase;
begin
  Result := Self.CreateSubType(AnOwner, ASubType, 'ByID');
  Result.ParamByName(Result.GetKeyField(ASubType)).AsInteger := AnID;
  Result.Open;
  Result.Next;
  if Result.RecordCount = 0 then
  begin
    Result.Free;
    raise EgdcIDNotFound.Create(Self.ClassName + ': ID not found (' + IntToStr(AnID) + ')');
  end else
    Result.First;
end;

procedure TgdcBase.SetTransaction(Value: TIBTransaction);
var
  OldTr: TIBTransaction;
  I: Integer;
begin
  if Transaction <> Value then
  begin
    // если мы пытаемся присвоить другую транзакцию взамен
    // внутренней и внутренняя транзакция используется только
    // у нас и она открыта, то выдадим ошибку.
    // такая ситуация говорит о том, что программист начал
    // сложную операцию, вовлекающую несколько датасетов,
    // открыл вручную транзакцию и, не закрыв ее, т.е. не
    // завершив сложной операции пытается переприсвоить
    // транзакцию
    if Assigned(Transaction) and (Transaction = FInternalTransaction)
      and Transaction.InTransaction
      and (Transaction.SQLObjectCount = 1) then
    begin
      if Transaction <> ReadTransaction then
        raise Exception.Create(GetGsException(Self, 'Transaction active'))
      else
        Transaction.Commit;
    end;

    OldTr := Transaction;

    inherited;

    for I := 0 to FDetailLinks.Count - 1 do
    begin
      if (FDetailLinks[I] is TIBCustomDataSet)
        and (TIBCustomDataSet(FDetailLinks[I]).Transaction = OldTr) then
      begin
        TIBCustomDataSet(FDetailLinks[I]).Transaction := Value;
      end;
    end;
  end;
end;

procedure TgdcBase.InternalSetParamsFromCursor;
var
  i: Integer;
  cur_param: TIBXSQLVAR;
  cur_field: TField;
  s: TStream;
begin
  if FQSelect.SQL.Text = '' then
    IBError(ibxeEmptyQuery, [nil]);
  {if not FInternalPrepared then
    InternalPrepare;}
  if (SQLParams.Count > 0) and (FgdcDataLink <> nil) and (FgdcDataLink.DataSet <> nil) then
  begin
    for I := 0 to FgdcDataLink.FMasterField.Count - 1 do
    begin
      cur_field := FgdcDataLink.DataSet.FindField(FgdcDataLink.FMasterField[I]);
      cur_param := ParamByName(FgdcDataLink.FDetailField[I]);
      if (cur_field <> nil) then
      begin
        if (cur_field.IsNull) then
        begin
          {
          если мастер документ, а дитэйл позиция документа, то
          если в мастере не будет ни одной записи
          то стандартно датасет попытается открыть дитэйл
          используя значение параметра НИЛ, но такой
          селет из таблицы документов приведет к селекту
          огромного количества записей.
          надо присваивать -1.
          }
          { TODO : может это перенести на уровень документа? }
          if FgdcDataLink.DataSet.IsEmpty and (cur_field.DataType = ftInteger) then
            cur_param.AsLong := -1
          else
            cur_param.IsNull := True;
        end
        else case cur_field.DataType of
          ftString:
            cur_param.AsString := cur_field.AsString;
          ftBoolean, ftSmallint, ftWord:
            cur_param.AsShort := cur_field.AsInteger;
          ftInteger:
          {begin
            if FgdcDataLink.DataSet.IsEmpty then
              cur_param.AsLong := -1
            else}
              cur_param.AsLong := cur_field.AsInteger;
          {end;}
          ftLargeInt:
            cur_param.AsInt64 := TLargeIntField(cur_field).AsLargeInt;
          ftFloat, ftCurrency:
           cur_param.AsDouble := cur_field.AsFloat;
          ftBCD:
            cur_param.AsCurrency := cur_field.AsCurrency;
          ftDate:
            cur_param.AsDate := cur_field.AsDateTime;
          ftTime:
            cur_param.AsTime := cur_field.AsDateTime;
          ftDateTime:
            cur_param.AsDateTime := cur_field.AsDateTime;
          ftBlob, ftMemo:
          begin
            s := nil;
            try
              s := DataSource.DataSet.
                     CreateBlobStream(cur_field, DB.bmRead);
              cur_param.LoadFromStream(s);
            finally
              s.free;
            end;
          end;
          else
            IBError(ibxeNotSupported, [nil]);
        end;
      end;
    end;

    {
    for i := 0 to SQLParams.Count - 1 do
    begin
      cur_field := DataSource.DataSet.FindField(SQLParams[i].Name);
      cur_param := SQLParams[i];
      if (cur_field <> nil) then
      begin
        if (cur_field.IsNull) then
          cur_param.IsNull := True
        else case cur_field.DataType of
          ftString:
            cur_param.AsString := cur_field.AsString;
          ftBoolean, ftSmallint, ftWord:
            cur_param.AsShort := cur_field.AsInteger;
          ftInteger:
            cur_param.AsLong := cur_field.AsInteger;
          ftLargeInt:
            cur_param.AsInt64 := TLargeIntField(cur_field).AsLargeInt;
          ftFloat, ftCurrency:
           cur_param.AsDouble := cur_field.AsFloat;
          ftBCD:
            cur_param.AsCurrency := cur_field.AsCurrency;
          ftDate:
            cur_param.AsDate := cur_field.AsDateTime;
          ftTime:
            cur_param.AsTime := cur_field.AsDateTime;
          ftDateTime:
            cur_param.AsDateTime := cur_field.AsDateTime;
          ftBlob, ftMemo:
          begin
            s := nil;
            try
              s := DataSource.DataSet.
                     CreateBlobStream(cur_field, bmRead);
              cur_param.LoadFromStream(s);
            finally
              s.free;
            end;
          end;
          else
            IBError(ibxeNotSupported, [nil]);
        end;
      end;
    end;
    }
  end;
end;

procedure TgdcBase.RefreshParams;
var
  DataSet: TDataSet;

  function NeedsRefreshing : Boolean;
  var
    i : Integer;
    cur_param: TIBXSQLVAR;
    cur_field: TField;
  begin
    Result := true;
    i := 0;
    while (i < FgdcDataLink.FMasterField.Count) and (Result) do
    begin
      cur_field := MasterSource.DataSet.FindField(FgdcDataLink.FMasterField[I]);
      try
        cur_param := ParamByName(FgdcDataLink.FDetailField[I]);
      except
        MessageBox(0,
          'Вероятно, в детальном объекте отсутствует параметр, который используется в связи мастер-дитэйл.',
          'Ошибка',
          MB_OK or MB_ICONSTOP or MB_TASKMODAL);
        raise;
      end;
      if (cur_field <> nil) then
      begin
        if (cur_field.IsNull) then
          Result := Result and cur_param.IsNull
        else
        case cur_field.DataType of
          ftString:
            Result := Result and (cur_param.AsString = cur_field.AsString);
          ftBoolean, ftSmallint, ftWord:
            Result := Result and (cur_param.AsShort = cur_field.AsInteger);
          ftInteger:
            Result := Result and (cur_param.AsLong = cur_field.AsInteger);
          ftLargeInt:
            Result := Result and (cur_param.AsInt64 = TLargeIntField(cur_field).AsLargeInt);
          ftFloat, ftCurrency:
            Result := Result and (cur_param.AsDouble = cur_field.AsFloat);
          ftBCD:
            Result := Result and (cur_param.AsCurrency = cur_field.AsCurrency);
          ftDate:
            Result := Result and (cur_param.AsDate = cur_field.AsDateTime);
          ftTime:
            Result := Result and (cur_param.AsTime = cur_field.AsDateTime);
          ftDateTime:
            Result := Result and (cur_param.AsDateTime = cur_field.AsDateTime);
          else
            Result := false;
        end;
      end;
      Inc(i);
    end;
    Result := not Result;
  end;

begin
  DisableControls;
  try
    if Assigned(FgdcDataLink) and (FgdcDataLink.DataSource <> nil) then
    begin
      DataSet := FgdcDataLink.DataSource.DataSet;
      if DataSet <> nil then
        if DataSet.Active and (DataSet.State <> dsSetKey) and NeedsRefreshing then
        begin
          Close;
          Open;
        end;
    end;
  finally
    EnableControls;
  end;
end;

function TgdcBase.OnInvoker(const Name: WideString; AnParams: OleVariant): OleVariant;
var
  LBuff: Pointer;
  LSender: TObject;
begin
  // проверка имени метода
  if  AnsiUpperCase(Name) = GDC_CUSTOMINSERT then
  begin
   {преобразование параметров для метода Делфи:
    параметры по значению:
    Param := приведение_к_типу(AnParams[...]);
    параметры по ссылке
    Param := приведение_к_типу(getVarParam(AnParams[...]));}

    LBuff := Pointer(Integer(AnParams[1]));
    // вызов метода Делфи с актуальными параметрами
    // если это фунция, то вызов: Result  := Метод_Делфи, если нет, то Метод_Делфи
    CustomInsert(LBuff);
    // если есть var-параметры обратное передача параметров из метода в вариантнвй массив AnParams
    { EventControl.GetParamInInterface(IDispatch(AnParams[...]), Param);
      ....
    }
  end else
  if  AnsiUpperCase(Name) = GDC_CUSTOMDELETE then
  begin
    LBuff := Pointer(Integer(AnParams[1]));
    CustomDelete(LBuff);
  end else
  if  AnsiUpperCase(Name) = GDC_CUSTOMMODIFY then
  begin
    LBuff := Pointer(Integer(AnParams[1]));
    CustomModify(LBuff);
  end else
  if  AnsiUpperCase(Name) = GDC_DoAfterDelete then
  begin
    DoAfterDelete;
  end else
  if  AnsiUpperCase(Name) = GDC_DOAFTERINSERT then
  begin
    DoAfterInsert;
  end else
  if  AnsiUpperCase(Name) = GDC_DOAFTEROPEN then
  begin
    DoAfterOpen;
  end else
  if  AnsiUpperCase(Name) = GDC_DOAFTERPOST then
  begin
    DoAfterPost;
  end else
  if  AnsiUpperCase(Name) = GDC_DOAFTERTRANSACTIONEND then
  begin
    LSender := InterfaceToObject(AnParams[1]);

    DoAfterTransactionEnd(LSender);
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFORECLOSE then
  begin
    DoBeforeClose;
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFOREDELETE then
  begin
    DoBeforeDelete;
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFOREEDIT then
  begin
    DoBeforeEdit;
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFOREINSERT then
  begin
    DoBeforeInsert;
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFOREPOST then
  begin
    DoBeforePost;
  end else
{ if  AnsiUpperCase(Name) = GDC_DOONNEWRECORD then
  begin
    DoOnNewRecord;
  end else}
  if  AnsiUpperCase(Name) = GDC_GETNOTCOPYFIELD then
  begin
    Result := GetNotCopyField;
  end else
  if  AnsiUpperCase(Name) = 'DOBEFOREOPEN' then
  begin
    DoBeforeOpen;
  end else
  if  AnsiUpperCase(Name) = '_DOONNEWRECORD' then
  begin
    _DoOnNewRecord;
  end else
  if  AnsiUpperCase(Name) = 'DOFIELDCHANGE' then
  begin
    DoFieldChange(InterfaceToObject(AnParams[1]) as TField);
  end else
  if  AnsiUpperCase(Name) = 'DOONREPORTLISTCLICK' then
  begin
    DoOnReportListClick(InterfaceToObject(AnParams[1]));
  end else
  if  AnsiUpperCase(Name) = 'DOAFTEREXTRACHANGED' then
  begin
    DoAfterExtraChanged(InterfaceToObject(AnParams[1]));
  end else
  if  AnsiUpperCase(Name) = 'DOONREPORTCLICK' then
  begin
    DoOnReportClick(InterfaceToObject(AnParams[1]));
  end else
  if  AnsiUpperCase(Name) = 'DOONFILTERCHANGED' then
  begin
    DoOnFilterChanged(InterfaceToObject(AnParams[1]), Integer(AnParams[2]));
//    procedure (Sender: TObject; const AnCurrentFilter: Integer);
  end else
  if  AnsiUpperCase(Name) = 'DOAFTERCUSTOMPROCESS' then
  begin
    LBuff := Pointer(Integer(AnParams[1]));
    DoAfterCustomProcess(LBuff, TgsCustomProcess(AnParams[2]));
//    procedure (Buff: Pointer; Process: TgsCustomProcess); virtual;
  end else
  if  AnsiUpperCase(Name) = 'DOBEFORESHOWDIALOG' then
  begin
    DoBeforeShowDialog(InterfaceToObject(AnParams[1]) as TCreateableForm);
//    procedure (DlgForm: ); virtual;
  end else
  if  AnsiUpperCase(Name) = 'DOAFTERSHOWDIALOG' then
  begin
    DoAfterShowDialog(InterfaceToObject(AnParams[1]) as TCreateableForm,
      Boolean(AnParams[2]));
//    procedure (DlgForm: TCreateableForm; IsOk: Boolean); virtual;
  end else
  if  AnsiUpperCase(Name) = 'CREATEDIALOGFORM' then
  begin
    Result := GetGdcInterface(CreateDialogForm) as IgsCreateableForm;
  end else
  if  AnsiUpperCase(Name) = 'EDITDIALOG' then
  begin
    Result := EditDialog(String(AnParams[1]));
//    function (const ADlgClassName: String = ''): Boolean;
  end else
  if  AnsiUpperCase(Name) = 'CREATEDIALOG' then
  begin
    Result := CreateDialog(String(AnParams[1]));
  end else
  if  AnsiUpperCase(Name) = 'COPYDIALOG' then
  begin
    Result := CopyDialog;
//    function CopyDialog: Boolean;
  end else
  if  AnsiUpperCase(Name) = 'GETSELECTCLAUSE' then
  begin
    Result := GetSelectClause;
  end else
  if  AnsiUpperCase(Name) = 'GETFROMCLAUSE' then
  begin
    Result := GetFromClause(Boolean(AnParams[1]));
  end else
  if  AnsiUpperCase(Name) = 'GETWHERECLAUSE' then
  begin
    Result := GetWhereClause;
  end else
  if  AnsiUpperCase(Name) = 'GETORDERCLAUSE' then
  begin
    Result := GetOrderClause;
  end else
  if  AnsiUpperCase(Name) = 'GETGROUPCLAUSE' then
  begin
    Result := GetGroupClause;
  end else
  if  AnsiUpperCase(Name) = 'CHECKTHESAMESTATEMENT' then
  begin
    Result := CheckTheSameStatement;
  end else
  if  AnsiUpperCase(Name) = GDC_GETNOTCOPYFIELD then
  begin
    ValidateField(InterfaceToObject(AnParams[1]) as TField);
  end else
  if  AnsiUpperCase(Name) = 'CREATEFIELDS' then
  begin
    CreateFields;
  end else
  ;

end;

class procedure TgdcBase.RegisterMethod;
begin
  // При регистрации все параметры делятся на два типа:
  // объект - Object и необъект - Variable.

  // !!! ДЛЯ VAR-параметров - var-параметр описывается с ключевым словом
  // var и его тип объект. ВСЕГДА!!!
  // пример RegisterClassMethod(TgdcBase, 'VarMethod', 'Self: Object; var Param: Object', '');

  RegisterGDCClassMethod(TgdcBase, 'CustomInsert', 'Self: Object; Buff: Variable', '');
  RegisterGDCClassMethod(TgdcBase, 'CustomModify', 'Self: Object; Buff: Variable', '');
  RegisterGDCClassMethod(TgdcBase, 'CustomDelete', 'Self: Object; Buff: Variable', '');

  RegisterGDCClassMethod(TgdcBase, 'DoAfterDelete', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoAfterInsert', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoAfterOpen', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoAfterPost', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoBeforeClose', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoBeforeDelete', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoBeforeEdit', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoBeforeInsert', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoBeforePost', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoAfterTransactionEnd', 'Self: Object; Field: Object', '');
//  RegisterGDCClassMethod(TgdcBase, 'DoOnNewRecord', 'Self: Object', '');

  RegisterGDCClassMethod(TgdcBase, 'DoOnReportListClick', 'Self: Object; Sender: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoAfterExtraChanged', 'Self: Object; Sender: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoOnReportClick', 'Self: Object; Sender: Object', '');

  RegisterGDCClassMethod(TgdcBase, 'DoBeforeOpen', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, '_DoOnNewRecord', 'Self: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'CopyDialog', 'Self: Object', 'Variable');

  RegisterGDCClassMethod(TgdcBase, 'DoOnFilterChanged',
    'Self: Object; Sender: Object; AnCurrentFilter: Variable', '');
  RegisterGDCClassMethod(TgdcBase, 'DoAfterCustomProcess',
    'Self: Object; Buff: Variable; Process: Variable', '');
  RegisterGDCClassMethod(TgdcBase, 'DoBeforeShowDialog',
    'Self: Object; DlgForm: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'DoAfterShowDialog',
    'Self: Object; DlgForm: Object; IsOk: Variable', '');
  RegisterGDCClassMethod(TgdcBase, 'CreateDialogForm', 'Self: Object', 'Object');
  RegisterGDCClassMethod(TgdcBase, 'EditDialog',
    'Self: Object; ADlgClassName: Variable', 'Variable');
  RegisterGDCClassMethod(TgdcBase, 'CreateDialog',
    'Self: Object; ADlgClassName: Variable', 'Variable');
  RegisterGDCClassMethod(TgdcBase, 'DoFieldChange', 'Self: Object; Field: Object', '');

  RegisterGDCClassMethod(TgdcBase, 'GetSelectClause',
    'Self: Object', 'Variable');
  RegisterGDCClassMethod(TgdcBase, 'GetFromClause',
    'Self: Object; ARefresh: Variable', 'Variable');
  RegisterGDCClassMethod(TgdcBase, 'GetWhereClause',
    'Self: Object', 'Variable');
  RegisterGDCClassMethod(TgdcBase, 'GetOrderClause',
    'Self: Object', 'Variable');
  RegisterGDCClassMethod(TgdcBase, 'GetGroupClause',
    'Self: Object', 'Variable');

  RegisterGDCClassMethod(TgdcBase, 'ValidateField',
    'Self: Object; Field: Object', '');
  RegisterGDCClassMethod(TgdcBase, 'CheckTheSameStatement',
    'Self: Object', 'Variable');

  RegisterGDCClassMethod(TgdcBase, 'CreateFields', 'Self: Object', '');

  RegisterGDCClassMethod(TgdcBase, 'GetNotCopyField', 'Self: Object', 'Variable');


end;

function TgdcBase.IsSubSetStored: Boolean;
begin
  Result := SubSet <> 'All';
end;

function TgdcBase.IsNameInScriptStored: Boolean;
begin
  Result := FNameInScript > '';
end;

function TgdcBase.IsReadTransactionStored: Boolean;
begin
  Result :=
    ((gdcBaseManager = nil) or (gdcBaseManager.ReadTransaction <> ReadTransaction));
end;

function TgdcBase.IsTransactionStored: Boolean;
begin
  Result := (Transaction <> FInternalTransaction);
end;

procedure TgdcBase.CheckCurrentRecord;
begin
  CheckActive;
  if IsEmpty then
    raise Exception.Create(GetGsException(Self, 'Record is not accessible'));
end;

{ TClassListForMethod }

{ TgdcTransactionGuard }

{
constructor TgdcTransactionGuard.Create(ATransaction: TIBTransaction);
begin
  FTransaction := ATransaction;
  if FTransaction.InTransaction then
    FDidActivate := False
  else begin
    FDidActivate := True;
    FTransaction.StartTransaction;
  end;
  FAction := taCommit;
end;

destructor TgdcTransactionGuard.Destroy;
begin
  if FDidActivate and FTransaction.InTransaction then
    case FAction of
      taCommit: FTransaction.Commit;
      taRollback: FTransaction.Rollback;
      taCommitRetaining: FTransaction.CommitRetaining;
      taRollbackRetaining: FTransaction.RollbackRetaining;
    end;
  inherited;
end;

function TgdcTransactionGuard.GetAction: TTransactionAction;
begin
  Result := FAction;
end;

function TgdcTransactionGuard.GetTransaction: TIBTransaction;
begin
  Result := FTransaction;
end;

procedure TgdcTransactionGuard.SetAction(AnAction: TTransactionAction);
begin
  FAction := AnAction;
end;
}

{ TgdcQTransactionGuard }

{
constructor TgdcQTransactionGuard.Create(ATransaction: TIBTransaction);
begin
  inherited Create(ATransaction);
  Fq := TIBSQL.Create(nil);
  Fq.Transaction := Transaction;
end;

destructor TgdcQTransactionGuard.Destroy;
begin
  FreeAndNil(Fq);
  inherited;
end;

function TgdcQTransactionGuard.GetQ: TIBSQL;
begin
  Result := Fq;
end;
}

function TgdcBase.GetReductionCondition: String;
begin
  Result := '';
end;

function TgdcBase.GetReductionTable: String;
begin
  Result := GetListTable(SubType);
end;

procedure TgdcBase.SetSelectedID(const Value: TgdKeyArray);
begin
  FSelectedID.Assign(Value);
  FSQLInitialized := False;
end;

{DoProcess указывает, вызывать ли метод для обработки выбранных записей}
//ChooseComponentName указывает из какого объекта на форме производить выборку
//ChooseSubSet указывает сабсет для объекта, из которого ведется выборка
//по умолчанию используется сабсет, заданный изначально на форме
function TgdcBase.ChooseItems(DoProcess: Boolean = True;
  const ChooseComponentName: String = ''; const ChooseSubSet: String = ''): Boolean;
var
  ChComponent: TComponent;
  F: TForm;
begin
  Result := False;
  if Self.Owner = nil then
    F := CreateViewForm(Application, '', SubType, True)
  else
    F := CreateViewForm(Self.Owner, '', SubType, True);

  if F <> nil then
    with F as Tgdc_frmG do
    try
      ChComponent := FindComponent(ChooseComponentName);
      if Assigned(ChComponent) and (ChComponent is TgdcBase) then
      begin
        gdcLinkChoose := (ChComponent as TgdcBase);
        {Если мы пришли сюда с открытой транзакцией, то присвоим ее на чтение в чуз.
         На изменение у нас будет идти другая транзакция.}
        if Self.Transaction.InTransaction then
        begin
          gdcObject.Close;
          gdcObject.ReadTransaction := Self.Transaction;
          gdcObject.Open;
        end;
      end;

      SetChoose(Self);
      if ChooseSubSet > '' then
      begin
        gdcLinkChoose.SubSet := gdcLinkChoose.SubSet + ',' + ChooseSubSet;
        gdcLinkChoose.Open;
      end;
      if ShowModal = mrOk then
      begin
        FSelectedID.Assign(gdcChooseObject.SelectedID);
        //Если выбран сабсет OnlySelected - переоткрываем объект
        if HasSubSet('OnlySelected') then
        begin
          FDSModified := True;
          CloseOpen;
        end;
        Result := True;
      end;
    finally
      Free;
    end;
end;

function TgdcBase.ChooseItems(Cl: CgdcBase; KeyArray: TgdKeyArray; DoProcess: Boolean = True;
  const ChooseComponentName: String = '';
  const ChooseSubSet: String = ''; const ChooseSubType: TgdcSubType = ''): Boolean;
var
  Obj: TgdcBase;
  C: TPersistentClass;
  ChComponent: TComponent;
  OwnerF: TComponent;
begin
  Result := False;
  Obj := Cl.CreateSubType(Owner, ChooseSubType);
  try
    Obj.Transaction := Obj.Transaction;
    Obj.Open;
    C := GetClass(Obj.GetViewFormClassName(ChooseSubType));
    if Self.Owner <> nil then
      OwnerF := Self.Owner
    else
      OwnerF := Application;
    if (C <> nil) and C.InheritsFrom(Tgdc_frmG) then
      with CgdcCreateableForm(C).CreateSubType(OwnerF, ChooseSubType) as Tgdc_frmG do
      begin
        try
          ChComponent := FindComponent(ChooseComponentName);
          if Assigned(ChComponent) and (ChComponent is TgdcBase) then
          begin
            gdcLinkChoose := (ChComponent as TgdcBase);
          end;
          if Assigned(KeyArray) then
            Obj.SelectedID.Assign(KeyArray);
          SetChoose(Obj);
          if ChooseSubSet > '' then
          begin
            gdcLinkChoose.SubSet := gdcLinkChoose.SubSet + ',' + ChooseSubSet;
            gdcLinkChoose.Open;
          end;
          if ShowModal = mrOk then
          begin
            Obj.SelectedID.Assign(gdcChooseObject.SelectedID);
            Obj.Close;
            Obj.SubSet := 'OnlySelected';
            Obj.Open;
            //Если выбран сабсет OnlySelected - переоткрываем объект
            if HasSubSet('OnlySelected') then
            begin
              FDSModified := True;
              CloseOpen;
            end;
            Result := True;
          end;
        finally
          Free;
        end;
      end;
    if Assigned(KeyArray) then
      KeyArray.Assign(Obj.SelectedID);
  finally
    Obj.Free;
  end;
end;

procedure TgdcBase.SetSetTable(const Value: String);
begin
  CheckDataSetClosed;
  if FSetTable <> Value then
  begin
    FSetTable := Value;
    if FSetTable > '' then
    begin
      MasterField := 'ID';
      DetailField := 'MASTER_RECORD_ID';
    end;
    FSetMasterField := '';
    FSetItemField := '';
    FSQLInitialized := False;
  end;
end;

procedure TgdcBase.SetExclude(const Reopen: Boolean);
var
  Bm: String;
  ibsql: TIBSQL;
  Buff: Pointer;
  DidActivate: Boolean;

  function GetWhereClauseForSet: String;
  var
    I: Integer;
    KFL: TStringList;
  begin
    Result := '';
    //проверяем есть ли у нас таблица-множество
    if (FSetTable = '') or (atDatabase = nil) then
      Exit;

    if Assigned(atDatabase.Relations.ByRelationName(FSetTable).PrimaryKey)
    then
    begin
      KFL := TStringList.Create;
      try
        with atDatabase.Relations.ByRelationName(FSetTable).PrimaryKey do
        for I := 0 to ConstraintFields.Count - 1 do
          KFL.Add(AnsiUpperCase(Trim(ConstraintFields[I].FieldName)));

        Result := '';
        for I := 0 to KFL.Count - 1 do
        begin
          if Result > '' then
            Result := Result + ' AND ';
          Result := Result + KFL[I] + ' = :OLD_' + cstSetPrefix + KFL[I];
        end;

      finally
        KFL.Free;
      end;
    end;
  end;
begin
  CheckBrowseMode;
  DidActivate := False;
  try
    DidActivate := ActivateTransaction;

    ibsql := TIBSQL.Create(nil);
    try
      ibsql.Transaction := Transaction;
      ibsql.SQl.Text := (Format('DELETE FROM %0:s WHERE %s', [FSetTable, GetWhereClauseForSet]));
      Buff := GetActiveBuf;
      SetInternalSQLParams(ibsql, Buff);
      ibsql.ExecQuery;
    finally
      ibsql.Free;
    end;

    FDSModified := True;

    if DidActivate and Transaction.InTransaction then
      Transaction.Commit;
  except
    if DidActivate and Transaction.InTransaction then
      Transaction.Rollback;
  end;

  if Reopen then
  begin
    FDataTransfer := True;
    try
      Bm := Bookmark;
      DisableControls;
      try
        Close;
        Open;
        if BookmarkValid(Pointer(Bm)) then
          Bookmark := Bm;
      finally
        EnableControls;
      end;
    finally
      FDataTransfer := False;
    end;
  end;

end;

procedure TgdcBase.SetInclude(const AnID: TID);
//var
//  q, OldQ: TIBSQL;
//  S: String;
begin
  { TODO : нужна проверка находимся ли мы в режиме множества. }
  CheckBrowseMode;

  try
    ExecSingleQuery(Format('INSERT INTO %s (%s, %s) VALUES (%d, %d)',
      [FSetTable, FSetMasterField, FSetItemField,
       ParamByName('MASTER_RECORD_ID').AsInteger, AnID]));

    FDSModified := True;

    {
    q := TIBSQL.Create(nil);
    try
      if Transaction.InTransaction then
        q.Transaction := Transaction
      else
        q.Transaction := ReadTransaction;
      q.GoToFirstRecordOnExecute := False;
      q.SQL.Text := GetRefreshSQLText;
      q.ParamByName('MASTER_RECORD_ID').AsInteger :=
        ParamByName('MASTER_RECORD_ID').AsInteger;
      q.ParamByName('NEW_' + cstSetPrefix + FSetItemField).AsInteger := AnID;
      q.ExecQuery;
      OldQ := FQSelect;
      try
        FQSelect := q;
        GetNextRecord;
      finally
        FQSelect := OldQ;
      end;
      Resync([]);
    finally
      q.Free;
    end;
    }


    DisableControls;
    try
      Close;
      Open;
      Locate(cstSetPrefix + FSetItemField, AnID, []);
    finally
      EnableControls;
    end;

  except
    on E: EIBError do
    begin
      // при попытке добавить элемент второй раз
      // будет исключение
      // подавим его
      if E.IBErrorCode <> 335544665 then
        raise;
    end;
  end;
end;

function TgdcBase.GetMethodControl: IMethodControl;
begin
  if (not Assigned(MethodControl)) or UnMethodMacro or (not UseScriptMethod) then
    Result := nil
  else
    Result := MethodControl;
end;

function TgdcBase.GetGdcInterface(Source: TObject): IDispatch;
begin
  Result := GetGdcOLEObject(Source) as IDispatch;
end;

function TgdcBase.GetClassName: String;
begin
  Result := Self.ClassName;
end;

procedure TgdcBase.DoFieldChange(Field: TField);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  tmpStrings: TStackStrings;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_DOFIELDCHANGE('TGDCBASE', 'DOFIELDCHANGE', KEYDOFIELDCHANGE)}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstMethodAssoc('TGDCBASE', KEYDOFIELDCHANGE);
  {M}      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEYDOFIELDCHANGE]);
  {M}      if (tmpStrings = nil) or (tmpStrings.IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(Field)]);
  {M}        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'TGDCBASE',
  {M}          'DOFIELDCHANGE', KEYDOFIELDCHANGE, Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        if tmpStrings.LastClass.gdClassName <> 'TGDCBASE' then
  {M}        begin
  {M}          Inherited;
  {M}          Exit;
  {M}        end;
  {M}    end;
  {END MACRO}
  //
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOFIELDCHANGE', KEYDOFIELDCHANGE)}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}      ClearMacrosStack2('TGDCBASE', 'DOFIELDCHANGE', KEYDOFIELDCHANGE);
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DataEvent(Event: TDataEvent; Info: Integer);
begin
  inherited;
{  if Event = DB.deFieldChange then}

end;

function TgdcBase.GetInterfaceToObject(Source: IDispatch): TObject;
begin
  Result := InterfaceToObject(Source);
end;

function TgdcBase.GetIDForBookmark(const Bm: TBookmarkStr): TID;
var
  Accept: Boolean;
begin
  Result := -1;
  FPeekBuffer := FBufferCache + PInteger(Bm)^ * _RecordBufferSize;
  try
    if PRecordData(FPeekBuffer)^.rdUpdateStatus = usDeleted then
      exit;

    if Filtered and Assigned(OnFilterRecord) then
    begin
      Accept := True;
      OnFilterRecord(Self, Accept);
      if not Accept then
        exit;
    end;

    Result := FieldByName(GetKeyField(SubType)).AsInteger;
  finally
    FPeekBuffer := nil;
  end;
end;

procedure TgdcBase.AddToSelectedID(BL: TBookmarkList);
var
  I: Integer;
begin
  if Assigned(BL) then
    BL.Refresh;

  if (BL = nil) or (BL.Count = 0) then
    AddToSelectedID(-1)
  else
    for I := 0 to BL.Count - 1 do
      AddToSelectedID(GetIDForBookmark(BL[I]));
end;

procedure TgdcBase.RemoveFromSelectedID(BL: TBookmarkList);
var
  I: Integer;
begin
  if Assigned(BL) then
    BL.Refresh;

  if (BL = nil) or (BL.Count = 0) then
    RemoveFromSelectedID(-1)
  else
    for I := 0 to BL.Count - 1 do
      RemoveFromSelectedID(GetIDForBookmark(BL[I]));
end;

procedure TgdcBase.SetBaseState(const ABaseState: TgdcStates);
begin
  FBaseState := ABaseState;
end;

procedure TgdcBase.SetFirstMethodAssoc(const AClass: String;
  const AMethodKey: Byte);
begin
  if Length(FClassMethodAssoc.StrByKey[AMethodKey]) = 0 then
    FClassMethodAssoc.StrByKey[AMethodKey] := AClass;
end;

class function TgdcBase.QGetNameForID(const AnID: TID; const ASubType: String = ''): String;
var
  q: TIBSQL;
  DidActivate: Boolean;
begin
  Assert(Assigned(gdcBaseManager));
  Assert(Assigned(gdcBaseManager.ReadTransaction));

  DidActivate := False;
  q := TIBSQL.Create(nil);
  try
    q.Database := gdcBaseManager.Database;
    q.Transaction := gdcBaseManager.ReadTransaction;

    DidActivate := not q.Transaction.InTransaction;
    if DidActivate then
      q.Transaction.StartTransaction;

    q.SQL.Text := Format('SELECT %s FROM %s WHERE %s = %d',
      [GetListField(ASubType), GetListTable(ASubType), GetKeyField(ASubType), AnID]);
    q.ExecQuery;

    if q.EOF then
      Result := ''
    else
      Result := q.Fields[0].AsTrimString;

    q.Close;
  finally
    if DidActivate and q.Transaction.InTransaction then
      q.Transaction.Commit;

    q.Free;
  end;
end;

procedure TgdcBase.ClearMacrosStack2(const AClass, AMethod: String;
  const AMethodKey: Byte);
var
  Index: Integer;
begin
  if FClassMethodAssoc.StrByKey[AMethodKey] = AClass then
  begin
    Index := FClassMethodAssoc.IndexOf(AMethodKey);
    FClassMethodAssoc.StrByIndex[Index] := '';
    if FClassMethodAssoc.IntByIndex[Index] > 0 then
      TStackStrings(FClassMethodAssoc.IntByIndex[Index]).Clear;
  end;
end;

class function TgdcBase.QGetNameForID2(const AnID: TID;
  const ASubType: TgdcSubType): String;
begin
  Result := QGetNameForID(AnID, ASubType);
end;

procedure TgdcBase.CreateKeyList;
begin
  FClassMethodAssoc.Add(keyCustomInsert);
  FClassMethodAssoc.Add(keyCustomModify);
  FClassMethodAssoc.Add(keyCustomDelete);
  FClassMethodAssoc.Add(keyDoAfterDelete);
  FClassMethodAssoc.Add(keyDoAfterInsert);
  FClassMethodAssoc.Add(keyDoAfterOpen);
  FClassMethodAssoc.Add(keyDoAfterPost);
  FClassMethodAssoc.Add(keyDoBeforeClose);
  FClassMethodAssoc.Add(keyDoBeforeDelete);
  FClassMethodAssoc.Add(keyDoBeforeEdit);
  FClassMethodAssoc.Add(keyDoBeforeInsert);
  FClassMethodAssoc.Add(keyDoBeforePost);
  FClassMethodAssoc.Add(keyDoAfterTransactionEnd);
//  FClassMethodAssoc.Add(keyDoOnNewRecord);
  FClassMethodAssoc.Add(keyDoOnReportListClick);
  FClassMethodAssoc.Add(keyDoAfterExtraChanged);
  FClassMethodAssoc.Add(keyDoOnReportClick);
  FClassMethodAssoc.Add(keyDoBeforeOpen);
  FClassMethodAssoc.Add(key_DoOnNewRecord);
  FClassMethodAssoc.Add(keyCopyDialog);
  FClassMethodAssoc.Add(keyDoOnFilterChanged);
  FClassMethodAssoc.Add(keyDoAfterCustomProcess);
  FClassMethodAssoc.Add(keyDoBeforeShowDialog);
  FClassMethodAssoc.Add(keyDoAfterShowDialog);
  FClassMethodAssoc.Add(keyCreateDialogForm);
  FClassMethodAssoc.Add(keyEditDialog);
  FClassMethodAssoc.Add(keyCreateDialog);
  FClassMethodAssoc.Add(keyDoFieldChange);

  FClassMethodAssoc.Add(keyGetSelectClause);
  FClassMethodAssoc.Add(keyGetFromClause);
  FClassMethodAssoc.Add(keyGetWhereClause);
  FClassMethodAssoc.Add(keyGetOrderClause);
  FClassMethodAssoc.Add(keyGetGroupClause);
  FClassMethodAssoc.Add(keyValidateField);
  FClassMethodAssoc.Add(keyCheckTheSameStatement);
  FClassMethodAssoc.Add(keyCreateFields);
  FClassMethodAssoc.Add(keyGetNotCopyField);
end;

class procedure TgdcBase.GetClassImage(const ASizeX, ASizeY: Integer;
  AGraphic: TGraphic);
begin
  if (ASizeX = 16) and (ASizeY = 16) and (AGraphic is TBitmap) then
    dmImages.il16x16.GetBitmap(0, TBitmap(AGraphic));
end;

function TgdcBase.GetFieldValueForID(const AnID: TID;
  const AFieldName: String): Variant;
var
  Accept: Boolean;
  S: String;
  I: Integer;
begin
  S := GetKeyField(SubType);

  if FieldByName(S).AsInteger = AnID then
  begin
    Result := FieldByName(AFieldName).Value;
  end else
  begin
    Result := Unassigned;

    try
      for I := 0 to FRecordCount - 1 do
      begin
        FPeekBuffer := FBufferCache + _RecordBufferSize * I;

        if PRecordData(FPeekBuffer)^.rdUpdateStatus <> usDeleted then
        begin
          if FieldByName(S).AsInteger = AnID then
          begin
            Accept := True;

            if Filtered and Assigned(OnFilterRecord) then
              OnFilterRecord(Self, Accept);

            if Accept then
            begin
              Result := FieldByName(AFieldName).Value;
              exit;
            end;
          end;
        end;
      end;
    finally
      FPeekBuffer := nil;
    end;
  end;
end;

function TgdcBase.GetFieldValueForBookmark(const ABookmark: TBookmarkStr;
  const AFieldName: String): Variant;
var
  Accept: Boolean;
begin
  Result := Unassigned;
  FPeekBuffer := FBufferCache + PInteger(ABookmark)^ * _RecordBufferSize;
  try
    if PRecordData(FPeekBuffer)^.rdUpdateStatus = usDeleted then
      exit;

    if Filtered and Assigned(OnFilterRecord) then
    begin
      Accept := True;
      OnFilterRecord(Self, Accept);
      if not Accept then
        exit;
    end;

    Result := FieldByName(AFieldName).Value;
  finally
    FPeekBuffer := nil;
  end;
end;

function TgdcBase.GetVarInterface(const AnValue: Variant): OleVariant;
begin
  if Assigned(FVarParam) then
    Result := FVarParam(AnValue)
  else
    Result := AnValue;
end;

function TgdcBase.GetVarParam(const AnValue: Variant): OleVariant;
begin
  if Assigned(FReturnVarParam) then
    Result := FReturnVarParam(AnValue)
  else
    Result := AnValue;
end;

class function TgdcBase.GetListFieldExtended(
  const ASubType: TgdcSubType): String;
begin
  Result := '';
end;

function TgdcBase.CreateBlobStream(Field: TField;
  Mode: TBlobStreamMode): TStream;
begin
  Result := inherited CreateBlobStream(Field, Mode);
  if (State = dsEdit) and (Mode in [DB.bmWrite, DB.bmReadWrite]) then
    FDSModified := True;
end;

class function TgdcBase.NeedModifyFromStream(
  const SubType: String): Boolean;
begin
//В общем случае обновлять данными из потока не нужно
//Это свойство понадобится скорее всего только для настроек
  Result := False;
end;

procedure TgdcBase.LoadSelectedFromStream(S: TStream);
begin
  FSelectedID.LoadFromStream(S);
end;

procedure TgdcBase.SaveSelectedToStream(S: TStream);
begin
  FSelectedID.SaveToStream(S);
end;

procedure TgdcBase.CopyEventHandlers(Dest, Source: TgdcBase);
begin
  if Assigned(EventControl) then
    EventControl.AssignEvents(TComponent(Source), Dest);

  // обязательно надо сохранить мастера!
  //Dest.MasterField := Source.MasterField;
  //Dest.DetailField := Source.DetailField;
  Dest.MasterSource := Source.MasterSource;

  Dest.AfterCancel := Source.AfterCancel;
  Dest.AfterClose := Source.AfterClose;
  Dest.AfterDelete := Source.AfterDelete;
  Dest.AfterEdit := Source.AfterEdit;
  Dest.AfterInsert := Source.AfterInsert;
  Dest.AfterInternalDeleteRecord := Source.AfterInternalDeleteRecord;
  Dest.AfterInternalPostRecord := Source.AfterInternalPostRecord;
  Dest.AfterOpen := Source.AfterOpen;
  Dest.AfterPost := Source.AfterPost;
  Dest.AfterRefresh := Source.AfterRefresh;
  Dest.AfterScroll := Source.AfterScroll;
  Dest.AfterShowDialog := Source.AfterShowDialog;
  Dest.BeforeCancel := Source.BeforeCancel;
  Dest.BeforeClose := Source.BeforeClose;
  Dest.BeforeDelete := Source.BeforeDelete;
  Dest.BeforeEdit := Source.BeforeEdit;
  Dest.BeforeInsert := Source.BeforeInsert;
  Dest.BeforeInternalDeleteRecord := Source.BeforeInternalDeleteRecord;
  Dest.BeforeInternalPostRecord := Source.BeforeInternalPostRecord;
  Dest.BeforeOpen := Source.BeforeOpen;
  Dest.BeforePost := Source.BeforePost;
  Dest.BeforeRefresh := Source.BeforeRefresh;
  Dest.BeforeScroll := Source.BeforeScroll;
  Dest.BeforeShowDialog := Source.BeforeShowDialog;
  Dest.OnCalcFields := Source.OnCalcFields;
  Dest.OnDeleteError := Source.OnDeleteError;
  Dest.OnEditError := Source.OnEditError;
  Dest.OnNewRecord := Source.OnNewRecord;
  Dest.OnPostError := Source.OnPostError;
  Dest.OnUpdateError := Source.OnUpdateError;
  Dest.OnUpdateRecord := Source.OnUpdateRecord;
end;

procedure TgdcBase.ResetEventHandlers(Obj: TgdcBase);
begin
  Obj.AfterCancel := nil;
  Obj.AfterClose := nil;
  Obj.AfterDelete := nil;
  Obj.AfterEdit := nil;
  Obj.AfterInsert := nil;
  Obj.AfterInternalDeleteRecord := nil;
  Obj.AfterInternalPostRecord := nil;
  Obj.AfterOpen := nil;
  Obj.AfterPost := nil;
  Obj.AfterRefresh := nil;
  Obj.AfterScroll := nil;
  Obj.AfterShowDialog := nil;
  Obj.BeforeCancel := nil;
  Obj.BeforeClose := nil;
  Obj.BeforeDelete := nil;
  Obj.BeforeEdit := nil;
  Obj.BeforeInsert := nil;
  Obj.BeforeInternalDeleteRecord := nil;
  Obj.BeforeInternalPostRecord := nil;
  Obj.BeforeOpen := nil;
  Obj.BeforePost := nil;
  Obj.BeforeRefresh := nil;
  Obj.BeforeScroll := nil;
  Obj.BeforeShowDialog := nil;
  Obj.OnCalcFields := nil;
  Obj.OnDeleteError := nil;
  Obj.OnEditError := nil;
  Obj.OnNewRecord := nil;
  Obj.OnPostError := nil;
  Obj.OnUpdateError := nil;
  Obj.OnUpdateRecord := nil;
end;

procedure TgdcBase.SetValueForBookmark(const ABookmark: TBookmarkStr;
  const AFieldName: String; const AValue: Variant);
var
  Accept: Boolean;
  OldDS, DS: TDataSetState;
begin
  FPeekBuffer := FBufferCache + PInteger(ABookmark)^ * _RecordBufferSize;
  try
    if PRecordData(FPeekBuffer)^.rdUpdateStatus = usDeleted then
      exit;

    if Filtered and Assigned(OnFilterRecord) then
    begin
      Accept := True;
      OnFilterRecord(Self, Accept);
      if not Accept then
        exit;
    end;

    Move(PChar(Self)[(1+8+26) * SizeOf(Integer) + SizeOf(TFilterOptions)], OldDS, SizeOf(OldDS));
    DS := dsEdit;
    Move(DS, PChar(Self)[(1+8+26) * SizeOf(Integer) + SizeOf(TFilterOptions)], SizeOf(DS));
    FieldByName(AFieldName).Value := AValue;
    Move(OldDS, PChar(Self)[(1+8+26) * SizeOf(Integer) + SizeOf(TFilterOptions)], SizeOf(OldDS));
  finally
    FPeekBuffer := nil;
  end;
end;

function TgdcBase.GetCanChangeRights: Boolean;
begin
  Result := TestUserRights([tiAFull]);
end;

function TgdcBase.GetCanCreate: Boolean;
begin
  Result := True;
end;

function TgdcBase.GetCanDelete: Boolean;
begin
  Result := TestUserRights([tiAFull]);
end;

function TgdcBase.GetCanEdit: Boolean;
begin
  if State = dsInsert then
    Result := True
  else
    Result := TestUserRights([tiAFull, tiAChag]);
end;

function TgdcBase.GetCanPrint: Boolean;
begin
  Result := TestUserRights([tiAView, tiAChag, tiAFull]);
end;

function TgdcBase.GetCanView: Boolean;
begin
  Result := TestUserRights([tiAView, tiAChag, tiAFull]);
end;

procedure TgdcBase.SetUseScriptMethod(const Value: Boolean);
begin
  FUseScriptMethod := Value;
end;

class function TgdcBase.NeedDeleteTheSame(const SubType: String): Boolean;
begin
//для большинства объектов удаления не потребуется!!!!!!
  Result := False;
end;

function TgdcBase.DeleteTheSame(AnID: Integer; AName: String): Boolean;
begin
  Result := False;
  //Стандартные записи мы удалять не будем
  if AnID < cstUserIDStart then
    Exit;
  if not (sLoadFromStream in BaseState) then
    raise EgdcException.Create('Объект должен быть в состоянии загрузки из потока!');

  ID := AnID;
  Delete;

  ExecSingleQuery(Format('DELETE FROM gd_ruid WHERE id = %s',
    [IntToStr(AnID)]));
  Result := True;

end;

class function TgdcBase.SelectObject(const AMessage: String = '';
  const ATitle: String = '';
  const AHelpCtxt: Integer = 0): TID;
begin
  with Tgdc_dlgSelectObject.Create(Application) do
  try
    if ATitle > '' then
      Caption := ATitle;

    if AMessage > '' then
      lMessage.Caption := AMessage;

    if AHelpCtxt > 0 then
      HelpContext := AHelpCtxt;    

    IBTransaction.DefaultDatabase := gdcBaseManager.Database;
    lkup.Database := gdcBasemanager.Database;
    lkup.gdClassName := Self.ClassName;
    if ShowModal = mrOk then
      Result := lkup.CurrentKeyInt
    else
      Result := -1;
  finally
    Free;
  end;
end;

{ EgdcException }

constructor EgdcException.CreateObj(const AMessage: String;
  AnObj: TgdcBase);
begin
  Assert(AnObj is TgdcBase);
  CreateFmt('%s'#13#10#13#10'Class: %s'#13#10'Object: %s'#13#10'SubType: %s'#13#10'SubSet: %s'#13#10'ID: %d'#13#10,
    [AMessage, AnObj.ClassName, AnObj.Name, AnObj.SubType, AnObj.SubSet, AnObj.ID]);
end;

procedure TgdcBase.DoAfterInternalPostRecord;
begin
  if Assigned(AfterInternalPostRecord) then
    AfterInternalPostRecord(Self);
end;

procedure TgdcBase.DoBeforeInternalPostRecord;
begin
  if Assigned(BeforeInternalPostRecord) then
    BeforeInternalPostRecord(Self);
end;

function TgdcBase.TestUserRights(const SS: TgdcTableInfos): Boolean;
var
  M: Integer;
begin
  if (RecordCount > 0)
    and Assigned(IBLogin)
    and ((FgdcTableInfos * [tiAFull, tiAChag, tiAView]) <> []) then
  begin
    M := 1;
    if tiAFull in FgdcTableInfos then
      M := M or FieldByName('afull').AsInteger;
    if (tiAChag in FgdcTableInfos) and
      ((tiAChag in SS) or (not (tiAFull in FgdcTableInfos))) then
      M := M or FieldByName('achag').AsInteger;
    if (tiAView in FgdcTableInfos) and
      ((tiAView in SS) or ((FgdcTableInfos * [tiAChag, tiAFull]) = [])) then
      M := M or FieldByName('aview').AsInteger;
    Result := (M and IBLogin.InGroup) <> 0;
  end else
    Result := True;

//  Result := Result and Class_TestUserRights(SS, Self.SubType);
end;

class function TgdcBase.Class_TestUserRights(
  const SS: TgdcTableInfos; const ST: String): Boolean;
var
  q: TIBSQL;
  M: Integer;
begin
  Result := True;

  if Assigned(gdcBaseManager) and Assigned(IBLogin) then
  begin
    if Assigned(gdcBaseManager.Explorer)
      and (VarType(gdcBaseManager.Explorer.GetFieldByNameValue('classname')) = varString)
      and (AnsiCompareText(gdcBaseManager.Explorer.GetFieldByNameValue('classname'), Self.ClassName) = 0)
      and
      (
        ((VarType(gdcBaseManager.Explorer.GetFieldByNameValue('subtype')) = varString) and (AnsiCompareText(gdcBaseManager.Explorer.GetFieldByNameValue('subtype'), ST) = 0))
        or
        ((VarType(gdcBaseManager.Explorer.GetFieldByNameValue('subtype')) = varNull) and (ST = ''))
      ) then
    begin
      M := 1;
      M := M or gdcBaseManager.Explorer.GetFieldByNameValue('afull');
      if tiAChag in SS then
        M := M or gdcBaseManager.Explorer.GetFieldByNameValue('achag');
      if tiAView in SS then
        M := M or gdcBaseManager.Explorer.GetFieldByNameValue('aview');
      Result := (M and IBLogin.InGroup) <> 0;
    end else
    begin
      if gdcBaseManager.ReadTransaction.Active then
      begin
        q := TIBSQL.Create(nil);
        try
          q.Transaction := gdcBaseManager.ReadTransaction;
          q.SQL.Text := 'SELECT afull, achag, aview ' +
            'FROM gd_command WHERE UPPER(classname)=:CN ';
          if ST > '' then
          begin
            q.SQL.Text := q.SQL.Text + 'AND UPPER(subtype)=:ST';
            q.ParamByName('ST').AsString := UpperCase(ST);
          end;
          q.ParamByName('CN').AsString := UpperCase(Self.ClassName);
          q.ExecQuery;
          if not q.EOF then
          begin
            M := 1;
            M := M or q.FieldByName('afull').AsInteger;
            if tiAChag in SS then
              M := M or q.FieldByName('achag').AsInteger;
            if tiAView in SS then
              M := M or q.FieldByName('aview').AsInteger;
            Result := (M and IBLogin.InGroup) <> 0;
          end;
        finally
          q.Free;
        end;
      end;
    end;
  end;
end;


procedure TgdcBase.SetExtraConditions(const Value: TStrings);
begin
  FExtraConditions.Assign(Value);
end;

function TgdcBase.GetObject: TObject;
begin
  Result := Self;
end;

function TgdcBase.GetFieldByNameValue(const AField: String): Variant;
begin
  Result := FieldByName(AField).Value;
end;

procedure TgdcBase.SetOnGetSelectClause(const Value: TgdcOnGetSQLClause);
begin
  FOnGetSelectClause := Value;
end;

procedure TgdcBase.SetOnGetFromClause(const Value: TgdcOnGetSQLClause);
begin
  FOnGetFromClause := Value;
end;

procedure TgdcBase.SetOnGetGroupClause(const Value: TgdcOnGetSQLClause);
begin
  FOnGetGroupClause := Value;
end;

procedure TgdcBase.SetOnGetOrderClause(const Value: TgdcOnGetSQLClause);
begin
  FOnGetOrderClause := Value;
end;

procedure TgdcBase.SetOnGetWhereClause(const Value: TgdcOnGetSQLClause);
begin
  FOnGetWhereClause := Value;
end;

procedure TgdcBase.SetQueryFiltered(const Value: Boolean);
begin
  FQueryFiltered := Value;
  if not (csDesigning in ComponentState) then
  begin
    Assert(Assigned(FFilter));
    if not FQueryFiltered then
      FFilter.IBDataSet := nil
    else
      FFilter.IBDataSet := Self;
  end;
end;

procedure TgdcBase.StreamSQLInitialize;
begin
  FibSQL_InsertToRUID := TIBSQL.Create(Self);
  FibSQL_InsertToRUID.Database := Database;
  FibSQL_InsertToRUID.Transaction := Transaction;
  FibSQL_InsertToRUID.SQL.Text := 'INSERT INTO gd_ruid(id, xid, dbid, modified, editorkey) ' + 
    ' VALUES (:id, :xid, :dbid, :modified, :editorkey)';
  FibSQL_InsertToRUID.Prepare;

  FibSQL_SelectRUID := TIBSQL.Create(Self);
  FibSQL_SelectRUID.Database := Database;
  FibSQL_SelectRUID.Transaction := Transaction;
  FibSQL_SelectRUID.SQL.Text := 'SELECT *  FROM gd_ruid WHERE id=:id';
  FibSQL_SelectRUID.Prepare;

  FibSQL_UpdateRUID := TIBSQL.Create(Self);
  FibSQL_UpdateRUID.Database := Database;
  FibSQL_UpdateRUID.Transaction := Transaction;
  FibSQL_UpdateRUID.SQL.Text := 'UPDATE gd_ruid SET xid=:xid, dbid=:dbid, modified=:modified WHERE id=:id';
  FibSQL_UpdateRUID.Prepare;

  FStreamSQLInitialised := True;
end;

{ TgdcPropertySet }

procedure TgdcPropertySet.Add(APropertyName: String;
  Value: Variant);
var
  ACount: Integer;
begin
  ACount := Count;
  FPropertyList.Add(AnsiUpperCase(APropertyName) + '=' + IntToStr(ACount));
  VarArrayRedim(FValueArray, Count);
  if VarType(Value) = varBoolean then
  begin
    if Boolean(Value) then
      FValueArray[Count] := 1
    else
      FValueArray[Count] := 0;
  end
  else
    FValueArray[Count] := Value;
end;

procedure TgdcPropertySet.Clear;
begin
  FPropertyList.Clear;
  FValueArray := VarArrayOf([]);
end;

constructor TgdcPropertySet.Create(const ARUIDSt: String;
  AgdClass: CgdcBase; ASubType: TgdcSubType);
begin
  inherited Create;
  FgdClass := AgdClass;
  FSubType := ASubType;
  FPropertyList := TStringList.Create;
  (FPropertyList as TStringList).Sorted := True;
  FValueArray := VarArrayOf([]);
end;

destructor TgdcPropertySet.Destroy;
begin
  FPropertyList.Free;
  inherited;
end;

function TgdcPropertySet.Find(APropertyName: String): Integer;
begin
  Result := FPropertyList.IndexOfName(AnsiUpperCase(APropertyName));
end;

function TgdcPropertySet.GetCount: Integer;
begin
  Result := FPropertyList.Count;
end;

function TgdcPropertySet.GetIndexValue(APropertyName: String): Integer;
var
  Index: Integer;
begin
  Index := Find(APropertyName);
  if Index = -1 then
    raise EgdcException.Create('Свойство ' +  APropertyName + ' не найдено!');

  Result := StrToInt(FPropertyList.Values[FPropertyList.Names[Index]]) + 1;
end;

function TgdcPropertySet.GetName(Index: Integer): String;
begin
  Result := FPropertyList.Names[Index];
end;

function TgdcPropertySet.GetValue(APropertyName: String): Variant;
begin
  Result := FValueArray[GetIndexValue(APropertyName)];
end;

procedure TgdcPropertySet.LoadFromStream(S: TStream);
var
  Reader: TReader;

  procedure _ReadVariant(var FValue: Variant);
  const
    ValTtoVarT: array[TValueType] of Integer = (varNull, varError, varByte,
      varSmallInt, varInteger, varDouble, varString, varError, varBoolean,
      varBoolean, varError, varError, varString, varEmpty, varError, varSingle,
      varCurrency, varDate, varOleStr, varError);
  var
    ValType: TValueType;
  begin
    ValType := Reader.NextValue;
    case ValType of
      vaNil, vaNull:
      begin
        if Reader.ReadValue = vaNil then
          VarClear(FValue) else
          FValue := NULL;
      end;
      vaInt8: TVarData(FValue).VByte := Byte(Reader.ReadInteger);
      vaInt16: TVarData(FValue).VSmallint := Smallint(Reader.ReadInteger);
      vaInt32: TVarData(FValue).VInteger := Reader.ReadInteger;
      vaExtended: TVarData(FValue).VDouble := Reader.ReadFloat;
      vaSingle: TVarData(FValue).VSingle := Reader.ReadSingle;
      vaCurrency: TVarData(FValue).VCurrency := Reader.ReadCurrency;
      vaDate: TVarData(FValue).VDate := Reader.ReadDate;
      vaString, vaLString: FValue := Reader.ReadString;
      vaWString: FValue := Reader.ReadWideString;
      vaFalse, vaTrue: TVarData(FValue).VBoolean := Reader.ReadValue = vaTrue;
    else
      raise EgdcException.Create('Невозможно считать свойство!');
    end;
    TVarData(FValue).VType := ValTtoVarT[ValType];
  end;

var
  I: Integer;
  FClassName: String;
  FName: String;
  FValue: Variant;
  FCount: Integer;
begin
  Clear;
  Reader := TReader.Create(S, 1024);
  try
    FRUIDSt := Reader.ReadString;
    FClassName := Reader.ReadString;
    FgdClass := CgdcBase(GetClass(FClassName));
    FSubType := Reader.ReadString;
    FCount := Reader.ReadInteger;
    for I := 0 to FCount - 1 do
    begin
      FName := Reader.ReadString;
      _ReadVariant(FValue);
      Add(FName, FValue);
    end;
  finally
    Reader.Free;
  end;
end;

procedure TgdcPropertySet.SaveToStream(S: TStream);
var
  Writer: TWriter;

  procedure _WriteVariant(Value: Variant);
  begin
    case VarType(Value) of
      varEmpty: Writer.WriteIdent('Nil');
      varNull: Writer.WriteIdent('Null');
      varOleStr: Writer.WriteWideString(Value);
      varString: Writer.WriteString(Value);
      varByte, varSmallInt, varInteger: Writer.WriteInteger(Value);
      varSingle: Writer.WriteSingle(Value);
      varDouble: Writer.WriteFloat(Value);
      varCurrency: Writer.WriteCurrency(Value);
      varDate: Writer.WriteDate(Value);
      varBoolean: Writer.WriteBoolean(Value);
      else
        try
          Writer.WriteString(Value);
        except
          raise EgdcException.Create('Невозможно сохранить свойство!');
        end;
    end;
  end;
var
  I: Integer;
begin
  Writer := TWriter.Create(S, 1024);
  try
    Writer.WriteString(FRUIDSt);
    Writer.WriteString(FgdClass.ClassName);
    Writer.WriteString(FSubType);
    Writer.WriteInteger(Count);
    for I := 0 to Count - 1 do
    begin
      Writer.WriteString(Name[I]);
      _WriteVariant(Value[Name[I]]);
    end;
  finally
    Writer.Free;
  end;
end;

procedure TgdcPropertySet.SetValue(APropertyName: String;
  Value: Variant);
begin
  if VarType(Value) = varBoolean then
  begin
    if Boolean(Value) then
      FValueArray[GetIndexValue(APropertyName)] := 1
    else
      FValueArray[GetIndexValue(APropertyName)] := 0;
  end
  else
    FValueArray[GetIndexValue(APropertyName)] := Value;
end;

{ TgdcPropertySets }

function TgdcPropertySets.Add(const ARUIDSt: String;
  AgdClassName: String; ASubType: TgdcSubType): Integer;
var
  Obj: TgdcPropertySet;
begin
  if IndexOf(ARuidSt) > -1 then
    raise EgdcException.Create('TgdcPropertSets: Дублирование руидов!');
  Obj := TgdcPropertySet.Create(ARuidSt, CgdcBase(GetClass(AgdClassName)), ASubType);
  Result := AddObject(ARuidSt, Obj);
end;

function TgdcPropertySets.AddObject(const S: string;
  AObject: TgdcPropertySet): Integer;
begin
  if (AObject = nil) or not(AObject.InheritsFrom(TgdcPropertySet)) then
    raise EgdcException.Create('TgdcPropertySets: передан неккоректный объект!');
  Result := inherited AddObject(S, AObject);
end;

procedure TgdcPropertySets.Clear;
var
  I: Integer;
begin
  if FOwnsObjects then
    for I := 0 to Count - 1 do
      Objects[I].Free;
  inherited;
end;

constructor TgdcPropertySets.Create;
begin
  inherited;
  FOwnsObjects := True;
  Sorted := True;
end;

destructor TgdcPropertySets.Destroy;
var
  I: Integer;
begin
  if FOwnsObjects then
    for I := 0 to Count - 1 do
      Objects[I].Free;
  inherited;
end;

function TgdcPropertySets.GetObject(Index: Integer): TgdcPropertySet;
begin
  Result := (inherited GetObject(Index)) as TgdcPropertySet;
end;

procedure TgdcPropertySets.LoadFromStream(S: TStream);
var
  I, J: Integer;
  FCount: Integer;
  FRUID: String;
  Obj: TgdcPropertySet;
begin
  Clear;
  S.Read(FCount, SizeOf(FCount));

  for I := 0 to FCount - 1 do
  begin
    S.Read(J, SizeOf(J));
    SetLength(FRUID, J);
    S.Read(FRUID[1], J);
    Obj := TgdcPropertySet.Create(FRUID, nil, '');
    Obj.LoadFromStream(S);
    AddObject(FRUID, Obj);
  end;
end;

procedure TgdcPropertySets.PutObject(Index: Integer;
  const Value: TgdcPropertySet);
begin
  inherited PutObject(Index, Value);
end;

function TgdcBase.GetPropertiesForStream(
  const ASubType: TgdcSubType): String;
begin
  Result := 'ModifyFromStream';
end;

procedure TgdcPropertySets.SaveToStream(S: TStream);
var
  I, J: Integer;
begin
  I := Count;
  S.Write(I, Sizeof(I));
  for I := 0 to Count - 1 do
  begin
    J := Length(Strings[I]);
    S.Write(J, SizeOf(J));
    S.Write(Strings[I][1], J);
    Objects[I].SaveToStream(S);
  end;
end;

procedure TgdcBase.AddObjectItem(const Name: String);
begin
  if FObjects = nil then
    FObjects := TgdObjects.Create;
  FObjects.AddObject(Name);
end;

procedure TgdcBase.AddVariableItem(const Name: String);
begin
  if FVariables = nil then
    FVariables := TgdVariables.Create;
  FVariables.AddVariable(Name)
end;

function TgdcBase.GetObjects(Name: String): IDispatch;
begin
  if FObjects = nil then
    FObjects := TgdObjects.Create;
  Result := FObjects.Objects[Name];
end;

function TgdcBase.GetVariables(Name: String): OleVariant;
begin
  if FVariables = nil then
    FVariables := TgdVariables.Create;
  Result := FVariables[Name];
end;

procedure TgdcBase.SetObjects(Name: String; const Value: IDispatch);
begin
  if FObjects = nil then
    FObjects := TgdObjects.Create;
  FObjects.Objects[Name] := Value;
end;

procedure TgdcBase.SetVariables(Name: String; const Value: OleVariant);
begin
  if FVariables = nil then
    FVariables := TgdVariables.Create;
  FVariables[Name] := Value;
end;

{function TgdcBase.GetRecord(Buffer: PChar; GetMode: TGetMode;
  DoCheck: Boolean): TGetResult;
begin
  if (FgdcDataLink <> nil) and (FgdcDataLink.DataSet <> nil)
    and (FgdcDataLink.DataSet.IsEmpty) then
  begin
    Result := grEOF;
    CopyRecordBuffer(FModelBuffer, Buffer);
    PRecordData(Buffer)^.rdBookmarkFlag := bfEOF;
  end else
    Result := inherited GetRecord(Buffer, GetMode, DoCheck);
end;}

procedure TgdcBase.SetReadTransaction(const Value: TIBTransaction);
var
  OldTr: TIBTransaction;
  I: Integer;
begin
  if ReadTransaction <> Value then
  begin
    OldTr := ReadTransaction;

    inherited;

    for I := 0 to FDetailLinks.Count - 1 do
    begin
      if (FDetailLinks[I] is TIBCustomDataSet)
        and (TIBCustomDataSet(FDetailLinks[I]).ReadTransaction = OldTr) then
      begin
        TIBCustomDataSet(FDetailLinks[I]).ReadTransaction := Value;
      end;
    end;
  end;
end;

function TgdcBase.ObjectExists(const Name: String): Boolean;
begin
  if FObjects = nil then
    Result := False
  else
    Result := FObjects.ObjectExists(Name);
end;

function TgdcBase.VariableExists(Name: String): Boolean;
begin
  if FVariables = nil then
    Result := False
  else
    Result := FVariables.VariableExists(Name);
end;

procedure TgdcBase.BeforeDestruction;
  {@CALL MACRO Inh_Orig_Params(var)}
begin
  {@CALL MACRO INH_ORIG_WITHOUTPARAM('TgdcBase', 'BEFOREDESTRUCTION', keyBEFOREDESTRUCTION)}
  inherited;

  {@CALL MACRO Inh_Orig_Finally('TgdcBase', 'BEFOREDESTRUCTION', keyBEFOREDESTRUCTION)}
end;

initialization
  gdcClipboardFormat := RegisterClipboardFormat(gdcClipboardFormatName);

  RegisterGDCClasses([TgdcBase]);

  // Регистрация методов TgdcBase для перекрытия их из макросов
  TgdcBase.RegisterMethod;

  CacheDBID := -1;
  CacheList := nil;
  CacheBaseClassForRel := nil;

finalization
  if Assigned(CacheList) then
    FreeAndNil(CacheList);
  if Assigned(CacheBaseClassForRel) then
    FreeAndNil(CacheBaseClassForRel);
  UnRegisterGDCClass(TgdcBase);

{***@DECLARE MACRO Inh_Params (%Var%)
%Var%
  Params, LResult: Variant;
  Index: Integer;
  InheritedFlag: Boolean;
END MACRO}

{***@DECLARE MACRO Inh_Body(%ClassName%, %MethodName%)
  try
    if Assigned(MethodControl) then
    begin
      InheritedFlag := False;
      SetFirstClassMethod(%ClassName%, %MethodName%);
      Index := LastCallClass.IndexOf(%MethodName%);
      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcOLEObject(Self) as IDispatch]);
        if MethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, Params, LResult) then exit;
      end else
        if (TStrings(LastCallClass.Objects[Index]).IndexOf(%ClassName%) > -1) and
          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
          <> %ClassName%) then
        begin
          InheritedFlag := True;
        end;
    end else
      InheritedFlag := True;

    if InheritedFlag then
    begin
END MACRO}

{***@DECLARE MACRO Inh_Finally (%ClassName%, %MethodName%)
    end;
  finally
    if Assigned(MethodControl) then
      ClearMacrosStack(%ClassName%, %MethodName%);
  end;
END MACRO}


//For methods without parameters
{
    procedure DoAfterDelete; override;
    procedure DoAfterInsert; override;
    procedure DoAfterOpen; override;
    procedure DoAfterPost; override;
    procedure DoBeforeClose; override;
    procedure DoBeforeDelete; override;
    procedure DoBeforeEdit; override;
    procedure DoBeforeInsert; override;
    procedure DoBeforePost; override;
    procedure DoOnNewRecord; override;
    procedure DoBeforeOpen; override;
    procedure _DoOnNewRecord; virtual;

}
{@DECLARE MACRO INH_ORIG_WITHOUTPARAM(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then exit;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Inherited;
          Exit;
        end;
    end;
END MACRO}


{FOR
    procedure CustomInsert(Buff: Pointer); virtual;
    procedure CustomModify(Buff: Pointer); virtual;
    procedure CustomDelete(Buff: Pointer); virtual;
}
{@DECLARE MACRO Inh_Orig_CustomInsert(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self), Integer(Buff)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          exit;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Inherited;
          Exit;
        end;
    end;
END MACRO}

// For methods with Sender
{
    procedure DoOnReportListClick(Sender: TObject);
    procedure DoAfterTransactionEnd(Sender: TObject); override;
    procedure DoAfterExtraChanged(Sender: TObject);
    procedure DoOnReportClick(Sender: TObject); virtual;
}

{@DECLARE MACRO Inh_Orig_Sender(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(Sender)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          exit;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Inherited;
          Exit;
        end;
    end;
END MACRO}

//     procedure DoFieldChange(Field: TField); virtual;
{@DECLARE MACRO Inh_Orig_DoFieldChange(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(Field)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          exit;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Inherited;
          Exit;
        end;
    end;
END MACRO}

//     procedure ValidateField(Field: TField); virtual;
{@DECLARE MACRO Inh_Orig_ValidateField(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(Sender)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          exit;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Inherited;
          Exit;
        end;
    end;
END MACRO}

//     procedure DoOnFilterChanged(Sender: TObject; const AnCurrentFilter: Integer);
{@DECLARE MACRO Inh_Orig_DoOnFilterChanged(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self),
          GetGdcInterface(Sender), AnCurrentFilter]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          exit;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Inherited;
          Exit;
        end;
    end;
END MACRO}

//     procedure DoAfterCustomProcess(Buff: Pointer; Process: TgsCustomProcess); virtual;
{@DECLARE MACRO Inh_Orig_DoAfterCustomProcess(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self),
          Integer(Buff), TgsCustomProcess(Process)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          exit;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Inherited;
          Exit;
        end;
    end;
END MACRO}

//    procedure DoBeforeShowDialog(DlgForm: TCreateableForm); virtual;
{@DECLARE MACRO Inh_Orig_DoBeforeShowDialog(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self), GetGdcInterface(DlgForm)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          exit;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Inherited;
          Exit;
        end;
    end;
END MACRO}

//    procedure DoAfterShowDialog(DlgForm: TCreateableForm; IsOk: Boolean); virtual;
{@DECLARE MACRO Inh_Orig_DoAfterShowDialog(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self),
          GetGdcInterface(DlgForm), IsOk]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          exit;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Inherited;
          Exit;
        end;
    end;
END MACRO}

//    function CreateDialogForm: TCreateableForm; virtual;
{@DECLARE MACRO Inh_Orig_funcCreateDialogForm(%ClassName%, %MethodName%, %MethodKey%)
  try
    Result := nil;
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            Result := nil;
            if VarType(LResult) <> varDispatch then
              raise Exception.Create('Скрипт-функция: ' + Self.ClassName +
                TgdcBase(Self).SubType + %MethodName% + #13#10 + 'Для метода ''' +
                %MethodName% + ' ''' + 'класса ' + Self.ClassName +
                TgdcBase(Self).SubType + #10#13 + 'Из макроса возвращен не объект.')
            else
              if IDispatch(LResult) = nil then
                raise Exception.Create('Скрипт-функция: ' + Self.ClassName +
                  TgdcBase(Self).SubType + %MethodName% + #13#10 + 'Для метода ''' +
                  %MethodName% + ' ''' + 'класса ' + Self.ClassName +
                  TgdcBase(Self).SubType + #10#13 + 'Из макроса возвращен пустой (null) объект.');
            Result := GetInterfaceToObject(LResult) as TCreateableForm;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited CreateDialogForm;
          Exit;
        end;
    end;
END MACRO}

//    function EditDialog(const ADlgClassName: String = ''): Boolean;
{@DECLARE MACRO Inh_Orig_EditDialog(%ClassName%, %MethodName%, %MethodKey%)
  Result := False;
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self), ADlgClassName]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            Result := False;
            if VarType(LResult) = varBoolean then
              Result := Boolean(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не булевый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
          Exit;
    end;
END MACRO}


//    function CreateDialog(const ADlgClassName: String = ''): Boolean; overload; virtual;
{@DECLARE MACRO Inh_Orig_CreateDialog(%ClassName%, %MethodName%, %MethodKey%)
  Result := False;
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self), ADlgClassName]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            Result := False;
            if VarType(LResult) = varBoolean then
              Result := Boolean(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не булевый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited CreateDialog(ADlgClassName);
          Exit;
        end;
    end;
END MACRO}

//    class function CreateViewForm(AnOwner: TComponent;
//      const AClassName: String = '';
//      const ASubType: String = ''): TForm; virtual;
{@DECLARE MACRO Inh_Orig_CreateViewForm(%ClassName%, %MethodName%, %MethodKey%)
  Result := nil;
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self),
          GetGdcInterface(AnOwner), AClassName, ASubType]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            Result := False;
            if VarType(LResult) = varBoolean then
              Result := GetInterfaceToObject(LResult) as TForm
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не объект');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited;
          Exit;
        end;
    end;
END MACRO}

//    function CopyDialog: Boolean;
{@DECLARE MACRO Inh_Orig_CopyDialog(%ClassName%, %MethodName%, %MethodKey%)
  Result := False;
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            Result := False;
            if VarType(LResult) = varBoolean then
              Result := Boolean(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не булевый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited CopyDialog;
          Exit;
        end;
    end;
END MACRO}

//    function CopyDialog: Boolean;
{@DECLARE MACRO Inh_Orig_CopyDialog(%ClassName%, %MethodName%, %MethodKey%)
  Result := False;
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            Result := False;
            if VarType(LResult) = varBoolean then
              Result := Boolean(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не булевый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited;
          Exit;
        end;
    end;
END MACRO}

//    function: String;
{@DECLARE MACRO Inh_Orig_OutString(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
              Result := String(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не строковый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited;
          Exit;
        end;
    end;
END MACRO}


{@DECLARE MACRO Inh_Orig_GetSelectClause(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
              Result := String(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не строковый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited GetSelectClause;
          Exit;
        end;
    end;
END MACRO}

{@DECLARE MACRO Inh_Orig_GetWhereClause(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
              Result := String(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не строковый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited GetWhereClause;
          Exit;
        end;
    end;
END MACRO}

{@DECLARE MACRO Inh_Orig_GetGroupClause(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
              Result := String(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не строковый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited GetGroupClause;
          Exit;
        end;
    end;
END MACRO}

{@DECLARE MACRO Inh_Orig_GetOrderClause(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
              Result := String(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не строковый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited GetOrderClause;
          Exit;
        end;
    end;
END MACRO}

{@DECLARE MACRO Inh_Orig_CheckTheSameStatement(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
              Result := String(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не строковый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited CheckTheSameStatement;
          Exit;
        end;
    end;
END MACRO}

//    function GetFromClause(const ARefresh: Boolean = False): String;
{@DECLARE MACRO Inh_Orig_GetFromClause(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self), ARefresh]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
              Result := String(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не строковый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited GetFromClause(ARefresh);
          Exit;
        end;
    end;
END MACRO}

//    function GetNotCopyField: String;
{@DECLARE MACRO Inh_Orig_GetNotCopyField(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            if (VarType(LResult) = varOleStr) or (VarType(LResult) = varString) then
              Result := String(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не строковый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited GetNotCopyField;
          Exit;
        end;
    end;
END MACRO}


//    function OutBoolean: Boolean;
{@DECLARE MACRO Inh_Orig_OutBoolean(%ClassName%, %MethodName%, %MethodKey%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstMethodAssoc(%ClassName%, %MethodKey%);
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[%MethodKey%]);
      if (tmpStrings = nil) or (tmpStrings.IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, %ClassName%,
          %MethodName%, %MethodKey%, Params, LResult) then
          begin
            if VarType(LResult) = varBoolean then
              Result := Boolean(LResult)
            else
              begin
                raise Exception.Create('Для метода ''' + %MethodName% + ' ''' +
                  ' класса ' + Self.ClassName + TgdcBase(Self).SubType + #10#13 +
                  'Из макроса возвращен не булевый тип');
              end;
            exit;
          end;
      end else
        if tmpStrings.LastClass.gdClassName <> %ClassName% then
        begin
          Result := Inherited;
          Exit;
        end;
    end;
END MACRO}

{@DECLARE MACRO Inh_Orig_Params(%Var%)
%Var%
  Params, LResult: Variant;
  tmpStrings: TStackStrings;
END MACRO}

{@DECLARE MACRO Inh_Orig_Finally(%ClassName%, %MethodName%, %MethodKey%)
  finally
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
      ClearMacrosStack2(%ClassName%, %MethodName%, %MethodKey%);
  end;
END MACRO}



// болванка для перекрытия методов
(*
// CURR_CLASS - текущий класс
// CURR_METHOD - текущий метод
// KEY_CURR_METHOD - ключ для текущего метода
VAR
  // переменные необходимые для перекрытия
  Params, LResult: Variant;
  tmpStrings: TStackStrings;
begin
  try
    // Начало обработки перекрытия метода
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      // установка первого вызова
      SetFirstMethodAssoc('CURR_CLASS', KEY_CURR_METHOD);
      // получаем из стека хранилище типа TStackStrings для текущего метода
      tmpStrings := TStackStrings(ClassMethodAssoc.IntByKey[KEY_CURR_METHOD]);
      // если хранилище отсутствует или данного классы в нем нет, то вызываем
      // макрос, иначе то метод вызван из инхирит макроса
      if (tmpStrings = nil) or (tmpStrings.IndexOf('CURR_CLASS') = -1) then
      begin
        // формирование вариантного массива параметров для вызова макроса
        // Self передается всегда, далее параметры метода, если они есть
        // !!! Для Var-параметров передача через метод GetVarInterface
        // пример: Params := VarArrayOf([GetGdcInterface(Self), GetVarInterface(Var_Param)]);
        Params := VarArrayOf([GetGdcInterface(Self), Integer(Buff)]);
        if gdcBaseMethodControl.ExecuteMethodNew(ClassMethodAssoc, Self, 'CURR_CLASS',
          'CURR_METHOD', KEY_CURR_METHOD, Params, LResult) then
        begin
          // Если есть Var-параметр, то возврат его из макроса
          // пример: Var_Param := приведение_к_типу(getVarParam(Params[...]));
          exit;
        end;
      end else
        // если текущий класс не последний в хранилище значит этот Делфи-метод
        // уже выполнялся - переходим по Inherited к следующему методу иерархии
        if tmpStrings.LastClass.gdClassName <> 'CURR_CLASS' then
        begin
          Inherited;
          Exit;
        end;
    end;

// !!!_Делфи-метод_!!!
   ...
// !!!Конец_Делфи-метод_!!!

  finally
    // !!! очистка стека обязательна, т.к.
    // если стек не обнулится, то при следующем вызове метода он не отработает.
    // Весь код метода включается в блок try finally, где в finally ClearMacrosStack2
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
      ClearMacrosStack2('CURR_CLASS', 'CURR_METHOD', KEY_CURR_METHOD);
  end;
*)
end.

