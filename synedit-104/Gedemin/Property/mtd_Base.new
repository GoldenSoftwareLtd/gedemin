
unit mtd_Base;

interface

uses
  evt_Base, evt_i_Base, mtd_i_Base, SysUtils, TypInfo, IBDatabase, Classes,
  Contnrs, rp_BaseReport_unit, scr_i_FunctionList, gdcBase, gd_DebugLog,
  gd_KeyAssoc;

const
  strStartClass = 'SCS';
  strEndClass = 'ECS';
  strStartClassList = 'SCLS';
  strEndClassList = 'ECLS';

//const
{  cCloseMethodName = 'Close1';
  cTileMethodName = 'Tile';}

type
  TAddrMethod = procedure of object;

  TMethodClass = class;
  TMethodClassList = class;

  TMethodItem = class(TCustomFunctionItem)
  private
    FOldMethod: TMethod;
    FIsOldMethodSet: Boolean;
    FClass: TMethodClass;
    FDisable: Boolean;
    FMethodId: Integer;

    function GetDelphiParamString(const LocParamCount: Integer;
      const LocParams: array of Char; const AnLang: TFuncParamLang;
      out AnResultParam: String): String;
    //TipTop: Возвращает имя параметра
    function GetDelphiParamName(const Index: Integer;
      const LocParams: array of Char; const AnLang: TFuncParamLang;
      out AnResultParam: String): String;
    // Возращает тип результата - объект или нет
    function GetResultType(const Index: Integer;
      const LocParams: array of Char): String;
    procedure SetOldMethod(const Value: TMethod);
    procedure SetDisable(const Value: Boolean);
    procedure SetMethodId(const Value: Integer);
  protected
    FMethodData: PTypeData;
    function GetParams(const AnLang: TFuncParamLang): String; override;
    function GetParamCount: Integer; override;
    function GetComplexParams(const AnLang: TFuncParamLang): String; override;
    property IsOldMethodSet: Boolean read FIsOldMethodSet default False;
    function GetObjectName: String; override;
  public
    constructor Create; overload;
    procedure Assign(ASource: TMethodItem);
    procedure Reset;
    function AutoFunctionName: String;

    // Старый м-д
    property OldMethod: TMethod read FOldMethod write SetOldMethod;
    // Указатель на стуктуру TTypeData метода
    property MethodData: PTypeData read FMethodData write FMethodData;
    property MethodClass: TMethodClass read FClass write FClass;
    // поле указывает используется скрипт-метод для метода или нет
    property Disable: Boolean read FDisable write SetDisable;
    property MethodId: Integer read FMethodId write SetMethodId;
  end;

  TMethodList = class;

  TCustomMethodClass = class
  private
    FMethodList: TMethodList;
    FClass_Key: Integer;
    FName: string;
    FClass_Reference: TClass;

    FSpecMethodCount: Integer;
    FSpecDisableMethod: Integer;
    FSubType: String;
    FSubTypeComment: String;

    procedure SetSpecMethodCount(const Value: Integer);
    procedure SetSpecDisableMethod(const Value: Integer);
    procedure SetSubType(const Value: String);
    procedure SetSubTypeComment(const Value: String);
  public
    constructor Create; overload;
    destructor Destroy; override;

    procedure Assign(Source: TCustomMethodClass); virtual;

    property MethodList: TMethodList read FMethodList write FMethodList;
    property SpecMethodCount: Integer read FSpecMethodCount write SetSpecMethodCount;
    property SpecDisableMethod: Integer read FSpecDisableMethod write setSpecDisableMethod;
    //Ключ класса в базе данных (табл. evt_object)
    property Class_Key: Integer read FClass_Key write FClass_Key;
    //Указатель на класс
    property Class_Reference: TClass read FClass_Reference write FClass_Reference;
    //имя класса или подтипа
    property Class_Name: string read FName write FName;
    // подпит
    property SubType: String read FSubType write SetSubType;
    property SubTypeComment: String read FSubTypeComment write SetSubTypeComment;
  end;

  // Класс хранит данные по одному классу
  TMethodClass = class(TCustomMethodClass)
  private
    FSubTypeMethodList: TStringList;

//    FMethodList: TMethodList;
//    FClass_Key: Integer;
//    FClass_Name: string;
//    FClass_Reference: TClass;

//    FSpecMethodCount: Integer;
//    FSpecDisableMethod: Integer;
//    procedure SetSpecMethodCount(const Value: Integer);
//    procedure SetSpecDisableMethod(const Value: Integer);
  public
    constructor Create; overload;
    constructor Create(AnClassKey: Integer; AnClass: TClass;
      SubType: string = ''); overload;
    destructor Destroy; override;

//    procedure Assign(Source: TMethodClass);

    function AddSubType({const AnClassKey: Integer; }const AnSubType: string): Integer;

    function  GetSubTypeItemByIndex(const Index: Integer): TCustomMethodClass;
    function  GetSubTypeMethodItem(const SubType: String): TCustomMethodClass;
  end;

  // Класс для хранения списка методов
  TMethodList = class(TObjectList)
  private
    function GetMethodName(Index: Integer): String;
    function GetFunc(Index: Integer): Integer;
    function GetItem(Index: Integer): TMethodItem;
    function GetMethod(Index: Integer): TMethod;
    procedure SetMethodName(Index: Integer; const Value: String);
    procedure SetFunc(Index: Integer; const Value: Integer);
    procedure SetMethod(Index: Integer; const Value: TMethod);
    function GetNameItem(const AName: String): TMethodItem;
  public
    function Add(const ASource: TMethodItem): Integer; overload;
    function Add(const AName: String; const AFuncKey: Integer;
      const ADisable: Boolean): Integer; overload;
    function Last: TMethodItem;
    procedure Assign(ASource: TMethodList);
    function Find(const AName: String): TMethodItem;

    property Items[Index: Integer]: TMethodItem read GetItem;
    property ItemByName[const AName: String]: TMethodItem read GetNameItem;
    property Name[Index: Integer]: String read GetMethodName write SetMethodName;
    property OldMethod[Index: Integer]: TMethod read GetMethod write SetMethod;
    property MethodFunctionKey[Index: Integer]: Integer read GetFunc write SetFunc;
  end;

  //Список классав
  TMethodClassList = class(TObject)
  private
    FMethodClassList: TStringList;
//    FSubTypeClassList: TMethodClassList;
//    FInitCount: Integer;
    function GetMethodClass(Index: Integer): TMethodClass;
//    function AddClass(const AnClass: TMethodClass): Integer; overload;
    function AddClassByName({const AnClassKey: Integer;}
      const AnClassName, AnSubType: String): TCustomMethodClass;
    function GetCount: Integer;
  public
    constructor Create;
    destructor Destroy; override;

//    procedure Assign(Source: TMethodClassList);
    function AddClass(const AnClassKey: Integer; const AnClassName: String;
      const AnClassReference: TClass; const AnSubType: string = ''): Integer; overload;

    procedure LoadFromDatabase(AnDatabase: TIBDatabase;
     AnTransaction: TIBTransaction; const AnParent: Variant);

    procedure MethodClassListClear;
    function FindClass(const AnName: String): TMethodClass;

    property Count: Integer read GetCount;
//    property InitCount: Integer read FInitCount write FInitCount;
    property MethodClass[Index: Integer]: TMethodClass read GetMethodClass;
  end;

  // Класс используется для организации элемента кэша
  // поиска и вызова перекрытых методов
  TmtdCacheItem = class(TObject)
  private
    FOwnerItem: TmtdCacheItem;
    FMethodPresent: Boolean;
    FFullClassName: String;
    FIsRealize: Boolean;
    FDisable: Boolean;
    FScriptFunction: TrpCustomFunction;
    procedure SetOwnerItem(const Value: TmtdCacheItem);
    procedure SetMethodPresent(const Value: Boolean);
    procedure SetFullClassName(const Value: String);
    procedure SetDisable(const Value: Boolean);
    procedure SetScriptFunction(const Value: TrpCustomFunction);
  public

    // Указатель на объект TrpCustomFunction для данного класса
    property ScriptFunction: TrpCustomFunction read FScriptFunction write SetScriptFunction;
    // Полное имя класса
    property FullClassName: String read FFullClassName write SetFullClassName;
    // Указатель на элемент кэша родителя данного класса
    property OwnerItem: TmtdCacheItem read FOwnerItem write SetOwnerItem;
    // Истина, если для данного класса имеется метод в Делфи и нет скрипт-метода
    property MethodPresent: Boolean read FMethodPresent write SetMethodPresent default False;
    // Указывает отключен метод или нет
    property Disable: Boolean read FDisable write SetDisable;
  end;

  // Класс для организации кэша быстрого вызова перекрытых методов.
  // Хранит инф-цию для классов с подтипами для одного метода.
  TmtdCache = class(TObject)
  private
    FCacheItemList: TStringList;
    FMethodListName: String;

    function  GetCacheItem(const AFullClassName: string): TmtdCacheItem;
    function  GetCacheItemByIndex(const Index: Integer): TmtdCacheItem;
  public
    constructor Create(const AMethodName: String);
    destructor Destroy; override;

    // Добавляет информацию о классе в кэш
    // (AChildClassName - имя предыдущего класса в стеке вызавов объекта)
    function  AddClass(const AFullClassName, AChildClassName: String;
      AScriptFuncion: TrpCustomFunction; const MethodPresent: Boolean): Integer;
    // Имя кэшировонного метода.
    property MethodListName: String read FMethodListName;
  end;

  TMethodControl = class(TComponent, IMethodControl)
  private
    // хранит список классов с методами
    FMethodClassList: TMethodClassList;         // Список -//-

    FDatabase: TIBDatabase;                     // Датабэйз. Задается из вне
    FTransaction: TIBTransaction;               // Транзакция. Создается внутри
    FLocState: Integer;
    FLocStateDB: Boolean;
    FLocStateTR: Boolean;
    // Хранит кэш для быстрого вызова перекрытых методов
    // Ключ - соответстует ключу метода,
    // объект списка - объект класса TmtdCache
    FmtdCacheList: TgdKeyObjectAssoc;

    // Методы для организации кэша быстрых вызавов перекрытых методов
    function  GetmtdCacheIndex(const AnMethodKey: Integer; const AMethodName: String): Integer;
    function  GetmtdCacheByIndex(const Index: Integer): TmtdCache;
    function  GetmtdCacheItem(const ACurrentName: String;
      const mtdCacheIndex: Integer): TmtdCacheItem;
    // Добавляет в кэш данные о классе и методе
    function AddClassInmtdCache(const AFullName, AChildName: String;
      const mtdCacheIndex: Integer; AScriptFunction: TrpCustomFunction; const MethodPresent: Boolean): TmtdCacheItem;
    // Очищает кэш для данного метода
    // Должно вызываться при удалении и добавлении скрипт-методов
    procedure  ClearMacroCache;

    procedure SetDatabase(const AnDatabase: TIBDatabase);

    // Функция для реализации Inherited Method
    // ALastCallClass - стек вызава методов; AgdcBase - бизнес-объект;
    // AClassName, AnMethodName - имя класса и метода, откуда вызван ExecuteMethod
    // AnParams, AnResult - массивы вариантных параметров для выполнения
    // макроса и результат
    function ExecuteMethodNew(AClassMethodAssoc: TgdKeyIntAndStrAssoc;
      AgdcBase: TObject; const AClassName, AMethodName: String; const AnMethodKey: Integer;
      var AnParams, AnResult: Variant): Boolean;

    procedure PrepareSourceDatabase;
    procedure UnPrepareSourceDatabase;
    procedure SaveDisableFlag(AMethodItem: TMethodItem);
    function  GetMethodClass(Index: Integer): TObject;
  protected
    // Инициализация
    procedure LoadLists;
    function  FindMethodClass(const AFullClassName: String): TObject;
    function AddClass(const AnClassKey: Integer; const AnClassName: String;
      const AnClassReference: TClass; const AnSubType: string = ''): Integer; overload;
  public
    constructor Create(AOwner: TComponent); override;
    destructor  Destroy; override;

    property MethodClassList: TMethodClassList read FMethodClassList
      write FMethodClassList;
    property  MethodClass[Index: Integer]: TObject read GetMethodClass;
  published
    property Database: TIBDatabase read FDatabase write SetDatabase;
    // Известные м-ды
//    procedure Close1;
//    procedure Tile;
  end;

procedure Register;

const
  MSG_WRONG_SREAM_DATA = 'Wrong stream data';

implementation

uses
  IBSQL, {prp_dlgViewProperty_unit,} gd_SetDatabase, gdcOLEClassList,
  rp_ReportScriptControl, gd_i_ScriptFactory, gd_ClassList, prp_dlgScriptError_unit,
  Controls, gs_Exception, gdc_createable_form, Windows, prp_dlgViewProperty_unit,
  gd_Security;

{ TMethodItem }

procedure Register;
begin
  RegisterComponents('gsReport', [TMethodControl]);
end;

procedure TMethodItem.Assign(ASource: TMethodItem);
begin
  FCustomName := ASource.Name;
  FMethodData := ASource.MethodData;
  FFunctionKey := ASource.FunctionKey;
  FOldMethod := ASource.OldMethod;
  FDisable := ASource.Disable;
  FMethodId := ASource.MethodId;
end;

function TMethodItem.AutoFunctionName: String;
begin
  Result := ObjectName + Name;
end;

constructor TMethodItem.Create;
begin
  inherited;

  FDisable := False;
end;

function TMethodItem.GetComplexParams(const AnLang: TFuncParamLang): String;
var
  LFN, LFR, LFB, LFE, LFP: String;
  LResultParam: String;
  InheritedDim, InheritedSender: String;
  InheritedParam, InheritedArray: String;
  CallInherited: String;
  Comment, EndComment: String;
  I: Integer;
const
  InheritedComment = '%s*** Данный код необходим для вызова кода определенного в gdc-классе.***'#13#10 +
                     '%s*** При его удаления  возможно нарушение  правильной работы системы.***';
  InheritedEndComment =
                     '%s***               Конец кода поддержки gdc-класса.                  ***';
begin
  Result := '';
  if not Assigned(FMethodData) then
    Exit;

  LFR := '';
  LFP := GetDelphiParamString(FMethodData^.ParamCount, FMethodData^.ParamList,
   AnLang, LResultParam);
  case FMethodData^.MethodKind of
    mkSafeFunction, mkFunction:
    begin
      LFN := 'function';
      case AnLang of
        fplDelphi: LFR := ': ' + LResultParam + ';';
        fplJScript, fplVBScript: LFR := '';
      else
        raise Exception.Create(GetGsException(Self, 'Unknown language type.'));
      end;
    end;
    mkSafeProcedure, mkProcedure:
      case AnLang of
        fplDelphi:
        begin
          LFN := 'procedure';
          LFR := ';';
        end;
        fplJScript: LFN := 'function';
        fplVBScript: LFN := 'sub';
      else
        raise Exception.Create(GetGsException(Self, 'Unknown language type.'));
      end;
  else
    raise Exception.Create(GetGsException(Self, 'This kind of method isn''t supported.'));
  end;
  InheritedDim := '';
  InheritedSender := '';
  InheritedParam := '';
  InheritedDim := '';
  CallInherited := '';
  Comment := '';
  EndComment := '';
  case AnLang of
    fplDelphi:
    begin
      LFB := 'begin';
      LFE := 'end;';
    end;
    fplJScript:
    begin
      LFB := '{'#13#10;
      LFE := '}';
//      InheritedDim := '  InheritedDim = new Array(' + IntToStr(FMethodData^.ParamCount - 1) + ');'#13#10;
//      InheritedSender := '  InheritedDim[0] = ' + GetDelphiParamName(0, FMethodData^.ParamList,
//        AnLang, LResultParam) + ';'#13#10;
      InheritedArray := 'Array(' +
        GetDelphiParamName(0, FMethodData^.ParamList, AnLang, LResultParam);

      for I := 1 to FMethodData^.ParamCount - 1 do
      begin
        InheritedArray := InheritedArray + ', ' +
          GetDelphiParamName(i, FMethodData^.ParamList, AnLang, LResultParam);
//        InheritedParam := InheritedParam + '  InheritedDim[' + IntToStr(I) + '] = ' +
//          GetDelphiParamName(I, FMethodData^.ParamList, AnLang, LResultParam) + ';'#13#10;
      end;
      InheritedArray := InheritedArray + ')';

      case FMethodData^.MethodKind of
        mkSafeFunction, mkFunction:
          CallInherited := '  ' + AutoFunctionName + ' = _'#13#10 + '    ';
        mkSafeProcedure, mkProcedure:
          CallInherited := '  ';
      end;

      CallInherited := CallInherited + 'Inherited(' + GetDelphiParamName(0, FMethodData^.ParamList,
        AnLang, LResultParam) + ', ' + '"' + Name + '", ' + InheritedArray + ')';
//      CallInherited := '  Inherited(' + GetDelphiParamName(0, FMethodData^.ParamList,
//        AnLang, LResultParam) + ', ' + '"' + Name + '", InheritedDim)';
      Comment := Format(InheritedComment, ['//', '//', '//']);
      EndComment := Format(InheritedEndComment, ['//']);
    end;
    fplVBScript:
    begin
      LFB := '';
      LFE := 'end ' + LFN;
//      InheritedDim := '  dim InheritedDim(' + IntToStr(FMethodData^.ParamCount - 1) + ')'#13#10;
//      InheritedSender := '  set InheritedDim(0) = ' + GetDelphiParamName(0, FMethodData^.ParamList,
//        AnLang, LResultParam) + #13#10;
//      InheritedDim := '  dim InheritedDim(' + IntToStr(FMethodData^.ParamCount - 1) + ')'#13#10;
      InheritedArray := 'Array(' +
        GetDelphiParamName(0, FMethodData^.ParamList, AnLang, LResultParam);

      for I := 1 to FMethodData^.ParamCount - 1 do
      begin
        InheritedArray := InheritedArray + ', ' +
          GetDelphiParamName(i, FMethodData^.ParamList, AnLang, LResultParam);
       { if UpperCase(GetParamType(I, FMethodData^.ParamList)) = 'OBJECT' then
          InheritedParam := InheritedParam + '  set' + ' InheritedDim(' + IntToStr(I) + ') = ' +
            GetDelphiParamName(I, FMethodData^.ParamList, AnLang,
            LResultParam) + #13#10
        else
          InheritedParam := InheritedParam + '  InheritedDim(' + IntToStr(I) + ') = ' +
            GetDelphiParamName(I, FMethodData^.ParamList, AnLang,
            LResultParam) + #13#10;
            }
      end;
      InheritedArray := InheritedArray + ')';

      case FMethodData^.MethodKind of
        mkSafeFunction, mkFunction:
        begin
          if AnsiUpperCase(GetResultType(FMethodData^.ParamCount,
            FMethodData^.ParamList)) = 'OBJECT' then
              CallInherited := '  set ' + AutoFunctionName + ' = _'#13#10 + '    '
          else
            CallInherited := '  ' + AutoFunctionName + ' = _'#13#10 + '    ';
        end;
        mkSafeProcedure, mkProcedure:
          CallInherited := '  call ';
      end;
//      CallInherited := CallInherited + 'Inherited(' + GetDelphiParamName(0, FMethodData^.ParamList,
//            AnLang, LResultParam) + ', ' + '"' + Name + '", InheritedDim)';
      CallInherited := CallInherited + 'Inherited(' + GetDelphiParamName(0, FMethodData^.ParamList,
        AnLang, LResultParam) + ', ' + '"' + Name + '", ' + InheritedArray + ')';

      Comment := Format(InheritedComment, ['''', '''', '''']);
      EndComment := Format(InheritedEndComment, ['''']);
    end;
  else
    raise Exception.Create(GetGsException(Self, 'Unknown language type.'));
  end;
  Result := LFN + ' ' + AutoFunctionName + '(' + LFP +
    ')' + LFR + #13#10 + LFB + Comment + #13#10 + InheritedDim +
    InheritedSender + InheritedParam + CallInherited + #13#10 +
    EndComment + #13#10 + LFE;
end;

function TMethodItem.GetDelphiParamName(const Index: Integer;
  const LocParams: array of Char; const AnLang: TFuncParamLang;
  out AnResultParam: String): String;
var
  L: Integer;
  I: Integer;
begin
  Result := '';
  L := 1;
  for I := 0 to Index - 1 do
  begin
    L := L + Byte(LocParams[L]) + 1;
    L := L + Byte(LocParams[L]) + 1;
    Inc(L);
  end;
  // Copy Param Name
  Result := Copy(PChar(@LocParams[L + 1]), 1, Byte(LocParams[L]));
end;

function TMethodItem.GetDelphiParamString(const LocParamCount: Integer;
 const LocParams: array of Char; const AnLang: TFuncParamLang;
 out AnResultParam: String): String;
var
  K, L: Integer;
begin
  Result := '';
  K := 0;
  L := 0;
  while K < LocParamCount do
  begin
    // Check param type
    //pfVar, pfConst, pfArray, pfAddress, pfReference, pfOut
    case Byte(LocParams[L]) and 39 of
      1:
      case AnLang of
        fplDelphi:
          Result := Result + 'var ';
        fplVBScript:
          Result := Result + 'ByRef ';
      end;
      2:
      case AnLang of
        fplDelphi:
          Result := Result + 'const ';
      end;
      4:
      case AnLang of
        fplDelphi:
          Result := Result + 'array of ';
      end;
      32:
      case AnLang of
        fplDelphi:
          Result := Result + 'out ';
        fplVBScript:
          Result := Result + 'ByRef ';
      end;
    else
      case AnLang of
        fplVBScript:
          Result := Result + 'ByVal ';
      end;
    end;

    // Copy Param Name
    Inc(L);
    Result := Result + Copy(PChar(@LocParams[L + 1]), 1, Byte(LocParams[L]));

    // Copy Param Type
    L := L + Byte(LocParams[L]) + 1;
    if AnLang = fplDelphi then
      Result := Result + ': ' + Copy(PChar(@LocParams[L + 1]), 1, Byte(LocParams[L]));

    // Add ';' if needed
    if K < LocParamCount - 1 then
      case AnLang of
        fplDelphi:
          begin
            Result := Result + '; ';
          end;
        fplVBScript, fplJScript:
          begin
            Result := Result + ', ';
          end;
      end;

    // Set position
    L := L + Byte(LocParams[L]) + 1;

    Inc(K);
  end;
  AnResultParam := Copy(PChar(@LocParams[L + 1]), 1, Byte(LocParams[L]));
end;

function TMethodItem.GetObjectName: String;
begin
  Result := '';
  if Assigned(FClass) then
    Result := FClass.Class_Name;
end;

function TMethodItem.GetParamCount: Integer;
begin
  Result := FMethodData^.ParamCount;
end;

function TMethodItem.GetParams(const AnLang: TFuncParamLang): String;
var
  LResultParam: String;
begin
  Result := GetDelphiParamString(FMethodData^.ParamCount, FMethodData^.ParamList,
   AnLang, LResultParam);
end;

{function TMethodItem.GetParamType(const Index: Integer;
  const LocParams: array of Char): String;
var
  L: Integer;
  I: Integer;
begin
  Result := '';
  L := 1;
  for I := 0 to Index - 1 do
  begin
    L := L + Byte(LocParams[L]) + 1;
    L := L + Byte(LocParams[L]) + 1;
    Inc(L);
  end;
  Result := Copy(PChar(@LocParams[L + 1]),
      Byte(LocParams[L]) + 2, Byte(LocParams[L + Byte(LocParams[L]) + 1]));;
end;}

function TMethodItem.GetResultType(const Index: Integer;
  const LocParams: array of Char): String;
var
  L: Integer;
  I: Integer;
begin
  Result := '';
  L := 1;
  for I := 0 to Index - 1 do
  begin
    L := L + Byte(LocParams[L]) + 1;
    L := L + Byte(LocParams[L]) + 1;
    Inc(L);
  end;
  Result := PChar(@LocParams[L]);
end;

procedure TMethodItem.Reset;
begin
  FOldMethod.Code := nil;
  FOldMethod.Data := nil;
  FIsOldMethodSet := False;
end;

procedure TMethodItem.SetDisable(const Value: Boolean);
begin
  FDisable := Value;
end;

procedure TMethodItem.SetMethodId(const Value: Integer);
begin
  FMethodId := Value
end;

procedure TMethodItem.SetOldMethod(const Value: TMethod);
begin
  if not FIsOldMethodSet then
  begin
    FOldMethod := Value;
    FIsOldMethodSet := True;
  end else
    raise Exception.Create(GetGsException(Self, 'Значение старого метода уже присвоено!!!'));
end;

{ TMethodClass }

{procedure TMethodClass.Assign(Source: TMethodClass);
begin
  inherited Assign(Source);
//  FClass_Key := Source.Class_Key;
//  FClass_Name := Source.Class_Name;
//  FClass_Reference := Source.Class_Reference;
  FSubType := Source.FSubType;
  FSubTypeComment := Source.FSubTypeComment;

//  FMethodList.Assign(Source.MethodList);
end;}

constructor TMethodClass.Create;
begin
  inherited;

//  FChildClasses := TMethodClassList.Create;
  FMethodList := TMethodList.Create;
  FClass_Key := 0;
//  FHasSpecMethod := False;
  FSubType := '';
  FSpecDisableMethod := 0;
end;

destructor TMethodClass.Destroy;
begin
//  FChildClasses.Free;
//  FMethodList.Free;
  if Assigned(FSubTypeMethodList) then
    FSubTypeMethodList.Free;
  inherited;
end;

{procedure TMethodClass.LoadFromStream(AnStream: TStream);
begin

end;

procedure TMethodClass.SaveToStream(AnStream: TStream);
begin

end;
}
constructor TMethodClass.Create(AnClassKey: Integer; AnClass: TClass;
  SubType: string = '');
begin
  Create;

  FClass_Key := AnClassKey;
  Class_Name := AnClass.ClassName;
  FClass_Reference := AnClass;
  FSubType := SubType;
end;


{procedure TMethodClass.SetSpecMethodCount(const Value: Integer);
begin
  FSpecMethodCount := Value;
end;}

{procedure TMethodClass.SetSpecDisableMethod(const Value: Integer);
begin
  FSpecDisableMethod := Value;
end;}

function TMethodClass.GetSubTypeMethodItem(
  const SubType: String): TCustomMethodClass;
var
  i: Integer;
begin
  Result := nil;
  i := FSubTypeMethodList.IndexOf(SubType);
  if i > -1 then
    Result := GetSubTypeItemByIndex(i);
end;

function TMethodClass.GetSubTypeItemByIndex(
  const Index: Integer): TCustomMethodClass;
begin
  Result := TCustomMethodClass(FSubTypeMethodList.Objects[Index]);
end;

{ TMethodList }

function TMethodList.Add(const ASource: TMethodItem): Integer;
begin
  Result := inherited Add(TMethodItem.Create);
  if Assigned(ASource) then
    Last.Assign(ASource);
end;

function TMethodList.Add(const AName: String;
  const AFuncKey: Integer; const ADisable: Boolean): Integer;
begin
  Result := Add(nil);
  Last.Name := AName;
  Last.FunctionKey := AFuncKey;
  Last.Disable := ADisable;
end;

procedure TMethodList.Assign(ASource: TMethodList);
var
  I: Integer;
begin
  Clear;
  for I := 0 to ASource.Count - 1 do
    Add(ASource.Items[I]);
end;

function TMethodList.Find(const AName: String): TMethodItem;
begin
  Result := ItemByName[AName];
end;

function TMethodList.GetMethodName(Index: Integer): String;
begin
  Result := Items[Index].Name;
end;

function TMethodList.GetFunc(Index: Integer): Integer;
begin
  Result := Items[Index].FunctionKey;
end;

function TMethodList.GetItem(Index: Integer): TMethodItem;
begin
  Result := TMethodItem(inherited Items[Index]);
end;

function TMethodList.GetMethod(Index: Integer): TMethod;
begin
  Result := Items[Index].OldMethod;
end;

function TMethodList.GetNameItem(const AName: String): TMethodItem;
var
  I: Integer;
begin
{!!!}
  Result := nil;
  for I := 0 to Count - 1 do
    if AnsiUpperCase(Name[I]) = AnsiUpperCase(AName) then
    begin
      Result := Items[I];
      Break;
    end;
end;

function TMethodList.Last: TMethodItem;
begin
  Result := TMethodItem(inherited Last);
end;

procedure TMethodList.SetMethodName(Index: Integer; const Value: String);
begin
  Items[Index].Name := Value;
end;

procedure TMethodList.SetFunc(Index: Integer; const Value: Integer);
begin
  Items[Index].FunctionKey := Value;
end;

procedure TMethodList.SetMethod(Index: Integer; const Value: TMethod);
begin
  Items[Index].OldMethod := Value;
end;

constructor TMethodControl.Create(AOwner: TComponent);
//var
//  AddrMethod: TAddrMethod;
begin
  Assert(MethodControl = nil, 'This component can be only one.');

  inherited Create(AOwner);

//  FKnownMethodList := nil;
  FMethodClassList := nil;
  FTransaction := nil;
  FLocState := 0;

  if not (csDesigning in ComponentState) then
  begin
    FmtdCacheList := TgdKeyObjectAssoc.Create;
    FmtdCacheList.OwnsObjects := True;

    FTransaction := TIBTransaction.Create(Self);
    FTransaction.Params.Add('read_committed');
    FTransaction.Params.Add('rec_version');
    FTransaction.Params.Add('nowait');

    FMethodClassList := TMethodClassList.Create;

//    FKnownMethodList := TStringList.Create;

    // Регистрация известных ...
{    AddrMethod := Close1;
    FKnownMethodList.AddObject('Close1', @AddrMethod);
 }
{    AddrMethod := Tile;
    FKnownMethodList.AddObject('Tile', @AddrMethod);}

//    TStringList(FKnownMethodList).Sorted := True;
  end;

  MethodControl := Self;

end;

destructor TMethodControl.Destroy;
begin
  FmtdCacheList.Free;
//  FreeAndNil(FKnownMethodList);
  FreeAndNil(FMethodClassList);
  if Assigned(FTransaction) then
    FreeAndNil(FTransaction);

//  if (MethodControl.Get_Self = Self) then
    MethodControl := nil;

  inherited Destroy;
end;

{procedure TMethodControl.EditObject(const AnComponent: TComponent;
  const AnShowMode: TShowModeSet = smAll; const AnName: String = '');
var
  F: TdlgViewProperty;
begin
{  F := TdlgViewProperty.Create(nil);
  try
    gd_SetDatabase.SetDatabase(F, FDatabase);
    F.Execute(AnComponent, AnShowMode, AnName);
    LoadLists;
  finally
    F.Free;
  end;}
{end;}
{
procedure TMethodControl.ExecuteMethod(const AnFunctionKey: Integer;
  var AnParams: Variant);
var
  LFunction: TrpCustomFunction;
begin
  if Assigned(ScriptFactory) then
  begin
    LFunction := glbFunctionList.FindFunction(AnFunctionKey);
    if Assigned(LFunction) then
    try
      ScriptFactory.ExecuteFunction(LFunction, AnParams)
    finally
      glbFunctionList.ReleaseFunction(LFunction);
    end
    else
      raise Exception.Create('Класс glbFunctionList не создан');
  end else
    raise Exception.Create('Класс ScriptFactory не создан');
end;
}
{function TMethodControl.Get_KnownMethodList: TStrings;
begin
//  Result := FKnownMethodList;
end;                          }

{function TMethodControl.Get_Self: TObject;
begin
  Result := Self;
end;}

procedure TMethodControl.LoadLists;
begin
  FMethodClassList.LoadFromDatabase(FDatabase, FTransaction, NULL);
end;

procedure TMethodControl.SetDatabase(const AnDatabase: TIBDatabase);
begin
  if AnDatabase <> FDatabase then
  begin
    FDatabase := AnDatabase;
    if Assigned(FTransaction) then
      FTransaction.DefaultDatabase := FDatabase;
  end;
end;

function TMethodClassList.AddClass(const AnClassKey: Integer; const AnClassName: String;
  const AnClassReference: TClass; const AnSubType: string = ''): Integer;
var
  mcTemp: TMethodClass;
  FullClassName: String;
begin
  FullClassName := Trim(AnClassName) + Trim(AnSubType);
  Result := FMethodClassList.IndexOf(FullClassName);
  if Result = -1 then
    Result := FMethodClassList.AddObject(FullClassName, TMethodClass.Create);

  mcTemp := GetMethodClass(Result);

  mcTemp.Class_Key := AnClassKey;
  mcTemp.Class_Name := FullClassName;
  mcTemp.Class_Reference := AnClassReference;
  mcTemp.SubType := AnSubType;
end;

function TMethodClassList.AddClassByName({const AnClassKey: Integer;}
  const AnClassName, AnSubType: String): TCustomMethodClass;
var
  i: Integer;
  LMethodClass: TMethodClass;
begin
  i := FMethodClassList.IndexOf(AnClassName);
  if i = -1 then
  begin
    Result := TMethodClass.Create;
    i := FMethodClassList.AddObject(AnClassName, Result);
  end;

  if Trim(AnSubType) <> '' then
  begin
    LMethodClass := GetMethodClass(i);
    i := LMethodClass.AddSubType({AnClassKey,} AnSubType);
    Result := LMethodClass.GetSubTypeItemByIndex(i);
  end else
    Result := GetMethodClass(i);
end;

constructor TMethodClassList.Create;
begin
  inherited;

  FMethodClassList := TStringList.Create;
  FMethodClassList.Sorted := True;
end;

destructor TMethodClassList.Destroy;
begin
  MethodClassListClear;
  FMethodClassList.Free;

  inherited;
end;

function TMethodClassList.FindClass(const AnName: String): TMethodClass;
var
  I: Integer;
  TempStr, LName: String;
begin
  // если в сабтайпе знак $, то меняем его на _
  // т.к. в ДБ в сабтайпах хранится _ вместо %
  LName := AnName;
  for I := 0 to Length(LName) - 1 do
    if LName[I] = '$' then
      LName[I] := '_';

  Result := nil;
  TempStr := AnsiUpperCase(LName);
  i := FMethodClassList.IndexOf(TempStr);
  if i > -1 then
    Result := MethodClass[i];
end;

function TMethodClassList.GetCount: Integer;
begin
  Result := FMethodClassList.Count;
end;

function TMethodClassList.GetMethodClass(Index: Integer): TMethodClass;
begin
  Result := TMethodClass(FMethodClassList.Objects[Index]);
end;

procedure TMethodClassList.LoadFromDatabase(AnDatabase: TIBDatabase;
  AnTransaction: TIBTransaction; const AnParent: Variant);
var
  ibsqlClass: TIBSQL;
  ibsqlMethod: TIBSQL;
  FlagTr: Boolean;
  i: Integer;
//  LMethodClass: TMethodClass;
  LMethodClass: TCustomMethodClass;
  LClassName, LSubType: String;
  N, E: Integer;
begin
  MethodClassListClear;
  FlagTr := AnTransaction.InTransaction;
  if not FlagTr then
    AnTransaction.StartTransaction;
  try
    ibsqlClass := TIBSQL.Create(nil);
    try
      ibsqlMethod := TIBSQL.Create(nil);
      try
        ibsqlClass.Database := AnDatabase;
        ibsqlClass.Transaction := AnTransaction;
        {Сволочь такая не работает с NULL параметром} {gs}

        ibsqlClass.SQL.Text :=
          'SELECT obj.name, obj.id, prnt.name as owner FROM evt_object obj LEFT JOIN '#13#10 +
          'evt_object prnt ON '#13#10 +
          'obj.parent = prnt.id WHERE obj.objecttype = 1 ORDER BY obj.id DESC';

        ibsqlClass.ExecQuery;

        ibsqlMethod.Database := AnDatabase;
        ibsqlMethod.Transaction := AnTransaction;
        ibsqlMethod.SQL.Text := 'SELECT * FROM evt_objectevent WHERE objectkey = :id ' +
          'ORDER BY eventname';
        ibsqlMethod.Prepare;

        while not ibsqlClass.Eof do
        begin
          LClassName := AnsiUpperCase(ibsqlClass.FieldByName('name').AsString);
          Val(LClassName[Length(LClassName)], N, E);
          if ((E = 0) or (Pos('USR_', LClassName) > 0)) and
            (Pos(AnsiUpperCase(ibsqlClass.FieldByName('owner').AsString), LClassName) = 1) then
          begin
            LSubType := Copy(ibsqlClass.FieldByName('name').AsString,
              Length(ibsqlClass.FieldByName('owner').AsString) + 1,
              Length(ibsqlClass.FieldByName('name').AsString));
            LClassName := Copy(ibsqlClass.FieldByName('name').AsString,
              1, Length(ibsqlClass.FieldByName('owner').AsString));
          end;


//          i := AddClassByName(ibsqlClass.FieldByName('name').AsString, LSubType);
//          LMethodClass := TMethodClass(FMethodClassList.Objects[i]);
          LMethodClass := AddClassByName(ibsqlClass.FieldByName('name').AsString, LSubType);
          LMethodClass.Class_Name :=
            ibsqlClass.FieldByName('name').AsString;
          LMethodClass.Class_Key :=
            ibsqlClass.FieldByName('id').AsInteger;
          LMethodClass.Class_Reference :=
            GetClass(LMethodClass.Class_Name);
          LMethodClass.SubType := LSubType;

          //Если мы не нашли среди ранее зарегестрированных то
          //делаем попытку найти класс среди зарегестрированных классов
          { TODO :
саша! не надо сливать класс нэйм и саб тайп в одну строку.
они должны всегда идти как два поля!
я подставил пустую строку и возможно весь твой код ляснется }

          ibsqlMethod.Close;
          ibsqlMethod.Params[0].AsInteger := LMethodClass.Class_Key;
          ibsqlMethod.ExecQuery;
          while not ibsqlMethod.Eof do
          begin
            LMethodClass.MethodList.Add(
              ibsqlMethod.FieldByName('eventname').AsString,
              ibsqlMethod.FieldByName('FunctionKey').AsInteger,
              (ibsqlMethod.FieldByName('Disable').AsInteger <> 0));
            LMethodClass.MethodList.Last.MethodClass :=
              TMethodClass(FMethodClassList.Objects[i]);
            LMethodClass.MethodList.Last.MethodId :=
              ibsqlMethod.FieldByName('id').AsInteger;
            ibsqlMethod.Next;
          end;
          ibsqlClass.Next;
        end;
      finally
        ibsqlMethod.Free;
      end;
    finally
      ibsqlClass.Free;
    end;
  finally
    if not FlagTr then
      AnTransaction.Commit;
  end;
//  InitCount := Count;
end;

{procedure TMethodClassList.LoadFromStream(AnStream: TStream);
var
  I, J: Integer;
  strTemp: array[0..SizeOf(strStartClassList)] of Char;
begin
  MethodClassListClear;
  AnStream.ReadBuffer(strTemp, SizeOf(strStartObjList));
  if strTemp <> strStartClassList then
    raise Exception.Create(GetGsException(Self, MSG_WRONG_SREAM_DATA));

  AnStream.ReadBuffer(J, SizeOf(J));
  for I := 0 to J - 1 do
    MethodClass[AddClass(TMethodClass.Create)].LoadFromStream(AnStream);

  AnStream.ReadBuffer(strTemp, SizeOf(strStartClassList));
  if strTemp <> strEndClassList then
    raise Exception.Create(GetGsException(Self, MSG_WRONG_SREAM_DATA));
end;}

procedure TMethodClassList.MethodClassListClear;
var
  I: Integer;
begin
  for I := 0 to FMethodClassList.Count - 1 do
    MethodClass[I].Free;

  FMethodClassList.Clear;
end;

function TMethodControl.ExecuteMethodNew(
  AClassMethodAssoc: TgdKeyIntAndStrAssoc; AgdcBase: TObject;
  const AClassName, AMethodName: String; const AnMethodKey: Integer; var AnParams,
  AnResult: Variant): Boolean;
var
  LMethodClass: TMethodClass;
  LMethodItem: TMethodItem;

  LFunction: TrpCustomFunction;
  LCurrentClass, LChildName, AnObjectClassName: string;
  Index, k, mtdCacheIndex: Integer;
  SubTypeList, tmpStrings: TStrings;
  ObjectSubType: String;
  SubTypePresent, IsGdcBase: Boolean;
  LClassName: String;
  LmtdCacheItem: TmtdCacheItem;
  // указывает, что информации для данного класса нет в
  // кэше и надо сделать поиск скрипт-методов.
  FullFindFlag: Boolean;
const
  LMsgMethodUserError =
                  'Метод %s для класса %s вызвал ошибку.'#13#10 +
                  'Ключ скрипт-функции - %d.'#13#10 +
                  'Обратитесь к администратору.';
  LMsgMethodOffAdmin =
                  'Метод %s для класса %s, вызвавший ошибку, не исправлен.'#13#10 +
                  'Ключ скрипт-функции - %d.'#13#10 +
                  'Отключить метод?';

  function GetSubTypeFromStr(const FullSubTypeStr: String): String;
  begin
    Result := Trim(Copy(FullSubTypeStr, Pos('=', FullSubTypeStr) + 1,
      Length(FullSubTypeStr)));
  end;

begin
  // !!! ПОЛНЫЙ КЛАСС - имя класса с подтипом
  Result := False;
  LFunction := nil;
  LClassName := AnsiUpperCase(Trim(AClassName));

  mtdCacheIndex := GetmtdCacheIndex(AnMethodKey, AMethodName);

  if AgdcBase.InheritsFrom(TgdcBase) then
    IsGdcBase := True
  else
    IsGdcBase := False;

  AnObjectClassName := AnsiUpperCase(AgdcBase.ClassName);
  // стек есть всегда, но он может быть пустой
  Index := AClassMethodAssoc.IndexOf(AnMethodKey);
  if AClassMethodAssoc.IntByKey[AnMethodKey] = 0 then
  begin
    { TODO :
еще раз! нельзя сливать класснэйм в одну строку!
должно быть два параметра! }
    if IsGdcBase then
    begin
      if gdcClassList.IndexOfByName(AnObjectClassName, '') = -1 then
        exit;
    end else
      if frmClassList.IndexOfByName(AnObjectClassName, '') = -1 then
        exit;

    AClassMethodAssoc.IntByIndex[Index] := Integer(TStringList.Create);
    // добавляем список для классов (удаляться он будет вместе объектом)
    tmpStrings := TStrings(AClassMethodAssoc.IntByIndex[Index]);
    LCurrentClass := '';
  end else
    begin
      tmpStrings := TStrings(AClassMethodAssoc.IntByIndex[Index]);
      if tmpStrings.Count = 0 then
        LCurrentClass := ''
      else
        LCurrentClass := tmpStrings[tmpStrings.Count - 1];
    end;

  LMethodItem := nil;

  // в цикле поиск скрипт-метода, согласно принципу Inherited, или, если макрос
  // не найден, возврат в метод Делфи
  // если класс без подтипа, то и ищем без подтипа и наоборот
  if IsGdcBase then
    ObjectSubType := TgdcBase(AgdcBase).SubType
  else
    ObjectSubType := TgdcCreateableForm(AgdcBase).SubType;

  FullFindFlag := True;
  // проверяем наличие кэша быстрого вызова для данного класса
  if LCurrentClass = '' then
    LmtdCacheItem := GetmtdCacheItem(AnsiUpperCase(AgdcBase.ClassName + ObjectSubType), mtdCacheIndex)
  else
    begin
      LmtdCacheItem := TmtdCacheItem(tmpStrings.Objects[tmpStrings.Count - 1]);
      if Assigned(LmtdCacheItem) then
        LmtdCacheItem := LmtdCacheItem.OwnerItem;
    end;

  // если есть кэш, то поиск не осуществяем
  if Assigned(LmtdCacheItem) then
  begin
    FullFindFlag := False;
    LFunction := nil;
    repeat
      // добавляем инфомацию о полном классе и методе в стек
      LCurrentClass := LmtdCacheItem.FullClassName;
      tmpStrings.AddObject(LCurrentClass, LmtdCacheItem);
      if Assigned(LmtdCacheItem.ScriptFunction) and (not LmtdCacheItem.Disable) then
      begin
        // если для полного класса определена скрипт-функция и она не отключена,
        // то идем на выполнение скрипт-метода
        LFunction := LmtdCacheItem.ScriptFunction;
        Break;
      end else
        // если скрипт-метод не определен, проверяем определен ли для класса
        // метод в Делфи, если да, то идем на выход.
        if LmtdCacheItem.MethodPresent then
        begin
          Break;
        end;
      // получаем следующий элемент кэша для данного объекта в иерархии класс
      LmtdCacheItem := LmtdCacheItem.OwnerItem;
    until (LmtdCacheItem = nil);
  end;

  if (LmtdCacheItem = nil) and (LCurrentClass <> LClassName) then
  begin
    FullFindFlag := True;
  end;

  if FullFindFlag then
  begin
      // поиск скрипт-метода для объекта без подтипа
    repeat
      LChildName := '';
      if ObjectSubType = '' then
      begin
        // получаем текущее полное имя класса для объекта без подтипа
        // Если LCurrentClass = '', то текущей класс - это класс объекта,
        // иначе это родительский класс последнего класса в стеку вызовов.
        if LCurrentClass = '' then
        begin
          LCurrentClass := AnObjectClassName;
        end else
          begin
            if IsGdcBase then
            begin
              
//              LCurrentClass := AnsiUpperCase(gdcClassList.GetGDCClass(tmpStrings[tmpStrings.Count - 1], '').ClassParent.ClassName);
              LChildName := LCurrentClass;
              LCurrentClass := AnsiUpperCase(gdcClassList.GetGDCClass(LCurrentClass, '').ClassParent.ClassName);
//              LChildName := AnsiUpperCase(tmpStrings[tmpStrings.Count - 1]);
            end else
              begin
                LChildName := LCurrentClass;
                LCurrentClass := AnsiUpperCase(frmClassList.GetFRMClass(LCurrentClass, '').ClassParent.ClassName);
//                LCurrentClass := AnsiUpperCase(frmClassList.GetFRMClass(tmpStrings[tmpStrings.Count - 1], '').ClassParent.ClassName);
//                LChildName := AnsiUpperCase(tmpStrings[tmpStrings.Count - 1]);
              end;
          end;
      end else
        begin
          // получаем текущее полное имя класса для объекта с подтипом
          if LCurrentClass = '' then
          begin
            // полное имя класса
            LCurrentClass := AnObjectClassName + ObjectSubType;
          end else
            begin
              if Pos(ObjectSubType, LCurrentClass) > 0 then
              begin
                LChildName := LCurrentClass;
                // Если в последнем в стеке полном имени класса есть подтип, то
                // текущий полный класс - это тот-же полный класс без подтипа
                LCurrentClass := Copy(LCurrentClass, 1, Pos(ObjectSubType, LCurrentClass) - 1);
              end else
                begin
                  // Если последний обработанный класс без подтипа, то получаем
                  // класс родителя, проверяем для него наличия подтипа объект.
                  // Если подтип для класса родителя определен, то текущий
                  // полный класс - класс родителя + подтип, иначе только класс
                  // родителя
                  if IsGdcBase then
                  begin
                    
                    LChildName :=  LCurrentClass;
                    LCurrentClass := AnsiUpperCase(gdcClassList.GetGDCClass(LCurrentClass, '').ClassParent.ClassName);
//                    LCurrentClass := AnsiUpperCase(gdcClassList.GetGDCClass(tmpStrings[tmpStrings.Count - 1], '').ClassParent.ClassName);
//                    LChildName :=  AnsiUpperCase(tmpStrings[tmpStrings.Count - 1]);
                  end else
                    begin
                      LChildName :=  LCurrentClass;
                      LCurrentClass := AnsiUpperCase(frmClassList.GetFRMClass(LCurrentClass, '').ClassParent.ClassName);
//                      LCurrentClass := AnsiUpperCase(frmClassList.GetFRMClass(tmpStrings[tmpStrings.Count - 1], '').ClassParent.ClassName);
//                      LChildName :=  AnsiUpperCase(tmpStrings[tmpStrings.Count - 1]);
                    end;
                  SubTypeList := TStringList.Create;
                  try
                    if AgdcBase.InheritsFrom(TgdcBase) then

                      SubTypePresent :=
                        CgdcBase(gdcClassList.GetGDCClass(tmpStrings[tmpStrings.Count - 1], '').ClassParent).GetSubTypeList(SubTypeList)
                    else
                      SubTypePresent :=
                        CgdcCreateableForm(frmClassList.GetFRMClass(tmpStrings[tmpStrings.Count - 1], '').ClassParent).GetSubTypeList(SubTypeList);

                    if SubTypePresent then
                      begin
                        for k := 0 to SubTypeList.Count - 1 do
                          if ObjectSubType =
                            AnsiUpperCase(GetSubTypeFromStr(SubTypeList[k])) then
                          begin
                            LCurrentClass := LCurrentClass + ObjectSubType;
                            break;
                          end;
                      end;
                  finally
                    SubTypeList.Free;
                  end;
                end;
            end;
        end;

      try
        // Получаем элемент кэша быстрого вывова для полного класса.
        // Далее по мере поступления информации для данного полного класса
        // заносим ее в этот элемент.
        LmtdCacheItem := AddClassInmtdCache(LCurrentClass, LChildName,
          mtdCacheIndex, nil, False);
        // Добавляем информацию об обработке в срек вызовов объекта.
        tmpStrings.AddObject(LCurrentClass, LmtdCacheItem);
      except
        {$IFDEF DEBUG}
        Beep(1000, 100);
        {$ELSE}
        raise;
        {$ENDIF}
      end;

      // Получаем объек, хранящий информацию о скрипт-методах, объявленных для
      // данного полного класса
      LMethodClass := FMethodClassList.FindClass(LCurrentClass);

      try
        if not Assigned(LMethodClass) then
          // Если данная проверка истина, то для данного класса определен
          // метод в Делфи. Прекращаем поиск.
          if LCurrentClass = LClassName then
          begin
            LmtdCacheItem.MethodPresent := True;
            Exit;
          end else
            Continue;
      except
        {$IFDEF DEBUG}
        Beep(1000, 100);
        {$ELSE}
        raise;
        {$ENDIF}
      end;

      // Если данная проверка истина, то для данного класса определен
      // метод в Делфи. Прекращаем поиск.
      if LCurrentClass = LClassName then
      begin
        LmtdCacheItem.MethodPresent := True;
      end;
      // Получаем объект, хранящий инф-цию для данного метода
      LMethodItem := LMethodClass.MethodList.Find(AMethodName);
      try
        if Assigned(LMethodItem) then
        begin
          LmtdCacheItem.ScriptFunction := glbFunctionList.FindFunction(LMethodItem.FunctionKey);
          LmtdCacheItem.Disable := LMethodItem.Disable;
        end;
      except
        Beep(1000, 100);
      end;

      // Если нет инф-ции для данного метода и ключ скрипт-метода = 0 или
      // скрипт-метод отключен, а для данного класса метод определен в Делфи,
      // то прекращаем поиск.
      if ((not Assigned(LMethodItem)) or (LMethodItem.FunctionKey = 0) or
        (LMethodItem.Disable)) and (LCurrentClass = LClassName) then
        begin
          Exit;
        end;
    until Assigned(LMethodItem) and (LMethodItem.FunctionKey <> 0) and (not LMethodItem.Disable);
  end;

  // выполнение скрипт-метода, если он обнаружен
  if (Assigned(LMethodItem)) or (Assigned(LFunction)) then
    if Assigned(ScriptFactory) then
    begin
      if LFunction = nil then
        LFunction := glbFunctionList.FindFunction(LMethodItem.FunctionKey);
      if Assigned(LFunction) then
      try
        if Assigned(Log) and UseLog then
          Log.LogLn(DateTimeToStr(Now) + ': Запущен метод ' + LFunction.Name +
            '  ИД функции ' + IntToStr(LFunction.FunctionKey));
        try
          ScriptFactory.ExecuteFunction(LFunction, AnParams, AnResult)
        except
          on E: EErrorScript do
          begin
            // Если возникла ошибка
            // админу возможность отключения, другому пользователю только сообщение об ошибке
            if Not IBLogin.IsUserAdmin then
            begin
              MessageBox(0, PChar(Format(LMsgMethodUserError, [AMethodName,
                LCurrentClass, LFunction.FunctionKey])),
                'Ошибка', MB_OK + MB_ICONERROR + MB_TOPMOST);
            end else
              if (MessageBox(0, PChar(Format(LMsgMethodOffAdmin, [AMethodName,
                LCurrentClass, LFunction.FunctionKey])),
                'Внимание', MB_YESNO + MB_ICONWARNING + MB_TOPMOST) = IDYES) then
                begin
                  LMethodItem.Disable := True;
                  SaveDisableFlag(LMethodItem);
                  if Assigned(dlgViewProperty) then
                    dlgViewProperty.SetMethodView(LMethodItem);
                end;
            Log.LogLn(DateTimeToStr(Now) + ': Ошибка во время выполнения метода ' + LFunction.Name +
              '  ИД функции ' + IntToStr(LFunction.FunctionKey));
            raise EAbort.Create('Ошибка в перекрытом методе ' + LFunction.Name);
          end else
            begin
              Log.LogLn(DateTimeToStr(Now) + ': Ошибка во время выполнения метода ' + LFunction.Name +
                '  ИД функции ' + IntToStr(LFunction.FunctionKey));
              raise;
            end;
        end;
        Result := True;
      finally
        glbFunctionList.ReleaseFunction(LFunction);
      end
      else
        Result := False;
    end
    else
      raise Exception.Create(GetGsException(Self, 'Класс ScriptFactory не создан'));
end;

procedure TMethodControl.SaveDisableFlag(AMethodItem: TMethodItem);
var
  LIBSQL: TIBSQL;
begin
  LIBSQL := TIBSQL.Create(nil);
  try
    LIBSQL.Database := FDatabase;
    LIBSQL.Transaction := FTransaction;
    PrepareSourceDatabase;
    try
      LIBSQL.SQL.Text := 'UPDATE evt_objectevent ' +
        'SET disable = :disable WHERE ' +
        'objectkey = :objectkey AND eventname = :eventname';
      if AMethodItem.Disable then
        LIBSQL.Params[0].AsInteger := 1
      else
        LIBSQL.Params[0].AsInteger := 0;
      LIBSQL.Params[1].AsInteger := AMethodItem.MethodClass.FClass_Key;
      LIBSQL.Params[2].AsString := AnsiUpperCase(AMethodItem.Name);
      LIBSQL.ExecQuery;
    finally
      UnPrepareSourceDatabase;
    end;
  finally
    LIBSQL.Free;
  end;
end;

procedure TMethodControl.PrepareSourceDatabase;
begin
  if FLocState = 0 then
  begin
    FLocStateDB := FDatabase.Connected;
    FLocStateTR := FTransaction.InTransaction;
    if not FLocStateDB then
      FDatabase.Connected := True;
    if not FLocStateTR then
      FTransaction.StartTransaction;
  end;
  Inc(FLocState);
end;

procedure TMethodControl.UnPrepareSourceDatabase;
begin
  Dec(FLocState);
  if FLocState = 0 then
  begin
    if not FLocStateTR then
      FTransaction.Commit;
    if not FLocStateDB then
      FDatabase.Connected := False;
  end;
end;

{ TmtdCacheItem }

procedure TmtdCacheItem.SetDisable(const Value: Boolean);
begin
  FDisable := Value;
end;

procedure TmtdCacheItem.SetFullClassName(const Value: String);
begin
  FFullClassName := Trim(AnsiUpperCase(Value));
end;

procedure TmtdCacheItem.SetMethodPresent(const Value: Boolean);
begin
  FMethodPresent := Value;
end;

procedure TmtdCacheItem.SetOwnerItem(const Value: TmtdCacheItem);
begin
  FOwnerItem := Value;
end;

function TMethodControl.AddClassInmtdCache(const AFullName,
  AChildName: String;const mtdCacheIndex{, AFunctionKey}: Integer; AScriptFunction: TrpCustomFunction;
  const MethodPresent: Boolean): TmtdCacheItem;
var
  LmtdCache: TmtdCache;
  i: Integer;
begin
  LmtdCache := GetmtdCacheByIndex(mtdCacheIndex);
//  i := LmtdCache.AddClass(AFullName, AChildName, AFunctionKey, MethodPresent);
  i := LmtdCache.AddClass(AFullName, AChildName, AScriptFunction, MethodPresent);
  Result := LmtdCache.GetCacheItemByIndex(i);
end;

function TMethodControl.GetmtdCacheByIndex(const Index: Integer): TmtdCache;
begin
  Result := TmtdCache(FmtdCacheList.ObjectByIndex[Index]);
end;

procedure TmtdCacheItem.SetScriptFunction(const Value: TrpCustomFunction);
begin
  FScriptFunction := Value;
end;

{ TmtdCache }

function TmtdCache.AddClass(const AFullClassName,
  AChildClassName: String; {const AFunctionKey: Integer}AScriptFuncion: TrpCustomFunction;
  const MethodPresent: Boolean): Integer;
var
  LCacheItem{, LChildItem}: TmtdCacheItem;

  procedure AddOwnerItem(const LOwnerItem: TmtdCacheItem);
  var
    LChildItem: TmtdCacheItem;
  begin
    LChildItem := GetCacheItem(AChildClassName);
    if Assigned(LChildItem) then
      LChildItem.OwnerItem := LOwnerItem;
  end;

begin
  Result := FCacheItemList.IndexOf(AFullClassName);
  if Result > -1 then
  begin
//    if not GetCacheItemByIndex(Result).FIsRealize then
    begin
      AddOwnerItem(TmtdCacheItem(FCacheItemList.Objects[Result]));
      GetCacheItemByIndex(Result).FIsRealize := True;
    end;
    Exit;
  end;

  LCacheItem := TmtdCacheItem.Create;
  LCacheItem.FullClassName := AFullClassName;
  LCacheItem.ScriptFunction := AScriptFuncion;
  LCacheItem.MethodPresent := MethodPresent;
  LCacheItem.OwnerItem := nil;
{  LChildItem := GetCacheItem(AChildClassName);
  if Assigned(LChildItem) then
    LChildItem.OwnerItem := LCacheItem;}
  AddOwnerItem(LCacheItem);
  Result := FCacheItemList.AddObject(AFullClassName, LCacheItem);
end;

constructor TmtdCache.Create(const AMethodName: String);
begin
  Inherited Create;

  FCacheItemList := TStringList.Create;
  FCacheItemList.Sorted := True;
  FMethodListName := AMethodName;
end;

destructor TmtdCache.Destroy;
var
  i: Integer;
begin
  for i := 0 to FCacheItemList.Count - 1 do
    FCacheItemList.Objects[i].Free;
  FCacheItemList.Free;

  inherited;
end;

function TmtdCache.GetCacheItem(const AFullClassName: string): TmtdCacheItem;
var
  i: Integer;
begin
  Result := nil;
  i := FCacheItemList.IndexOf(AFullClassName);
  if i > -1 then
    Result := TmtdCacheItem(FCacheItemList.Objects[i]);
end;

function TMethodControl.GetmtdCacheIndex(
  const AnMethodKey: Integer; const AMethodName: String): Integer;
begin
  Result := FmtdCacheList.IndexOf(AnMethodKey);
  if Result = -1 then
  begin
    Result := FmtdCacheList.Add(AnMethodKey);
    FmtdCacheList.ObjectByIndex[Result] := TmtdCache.Create(AMethodName);
  end;
end;

function TMethodControl.GetmtdCacheItem(const ACurrentName: String;
  const mtdCacheIndex: Integer): TmtdCacheItem;
var
  LmtdCache: TmtdCache;
begin
  Result := nil;
  LmtdCache := GetmtdCacheByIndex(mtdCacheIndex);
  if not Assigned(LmtdCache) then
    Exit;

  Result := LmtdCache.GetCacheItem(ACurrentName);
end;

function TmtdCache.GetCacheItemByIndex(
  const Index: Integer): TmtdCacheItem;
begin
  Result := TmtdCacheItem(FCacheItemList.Objects[Index]);
end;

procedure TMethodControl.ClearMacroCache;
begin
  FmtdCacheList.Clear;
end;

{procedure TMethodControl.FixedCache(const AClassName, SubType: String;
  const MethodKey: Byte);
begin

end;}

function TMethodControl.FindMethodClass(
  const AFullClassName: String): TObject;
begin
  Result := FMethodClassList.FindClass(AFullClassName);
end;

function TMethodControl.AddClass(const AnClassKey: Integer;
  const AnClassName: String; const AnClassReference: TClass;
  const AnSubType: string): Integer;
begin
  Result := FMethodClassList.AddClass(AnClassKey, AnClassName,
    AnClassReference, AnSubType);
end;

function TMethodControl.GetMethodClass(Index: Integer): TObject;
begin
  Result := FMethodClassList.MethodClass[index];
end;

{ TCustomMethodClass }

procedure TCustomMethodClass.Assign(Source: TCustomMethodClass);
begin
  FClass_Key := Source.Class_Key;
  FName := Source.Class_Name;
  FClass_Reference := Source.Class_Reference;

  FMethodList.Assign(Source.MethodList);
end;

constructor TCustomMethodClass.Create;
begin
  inherited;

  FMethodList := TMethodList.Create;
  FMethodList.OwnsObjects := True;
  FClass_Key := 0;
  FName := '';
  FSpecDisableMethod := 0;
  FSpecDisableMethod := 0;
end;

destructor TCustomMethodClass.Destroy;
begin
  FMethodList.Free;
  
  inherited;
end;

procedure TCustomMethodClass.SetSpecDisableMethod(const Value: Integer);
begin
  FSpecDisableMethod := Value;
end;

procedure TCustomMethodClass.SetSpecMethodCount(const Value: Integer);
begin
  FSpecMethodCount := Value;
end;

procedure TCustomMethodClass.SetSubType(const Value: String);
begin
  FSubType := Value;
end;

function TMethodClass.AddSubType({const AnClassKey: Integer;}
  const AnSubType: string): Integer;
begin
  if FSubTypeMethodList = nil then
  begin
    FSubTypeMethodList := TStringList.Create;
    FSubTypeMethodList.Sorted := True;
  end;

  Result := FSubTypeMethodList.AddObject(AnSubType, TMethodList.Create);
//  GetSubTypeItemByIndex(Result).Class_Key := AnClassKey;
end;

procedure TCustomMethodClass.SetSubTypeComment(const Value: String);
begin

end;

end.
