
(*
  Для департамента.
  При выводе меню (печать, макросы) идет проверка на права доступа.
  Если это не администратор, то изменение макросов (отчетов)
  не доступно.
  Julie
*)

(*
 Временно добавлено событие для макросов на изменение поля.
 Оно вызывается в DataEvent, в него передается имя поля, которое изменяется
 По идее вредности ни какой не должно быть.
 Michael.
*)


(*

Безопасность.

не выводить записи, если есть поле aview и нет прав у пользователя
на просмотр записи.

если есть поле achag и у пользователя нет прав на изменение, то не давать
редактировать, копировать, удалять.

если есть поле afull и у пользователя нет прав, то не давать возможность
удалять.

программист обязан вставить в СКЛ текст проверку на права. он должен
использовать метапеременную, которая будет заменена на права пользователя.

разделение прав по операциям.

мы вводим следующие мета-операции для базового класса:

создание объекта, просмотр/изменение, удаление, смена прав доступа и печать.
Все остальные можно свести
к предыдущим трем. тогда прежде чем выполнить операцию мы проверим:
не отключена ли она, есть ли права у пользователя на нее, есть ли
права у пользователя на выполнение заданной операции над текущей записью.

в таблице гд_оператион мы заводим ветку GDC.
для всех объектов отводим интервал: 7000000-7999999
для каждого объекта заводится подветка с определенным идентификатором.
ИД. у этой ветки пять подветвей, соответственно с кодами
ИД + 2, + 4 и т.п.
эти подветки -- команды на доступ, создание, изменение, удаление, смену прав,
печать.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~
при копировании записи-накладной мы должны скопировать все записи-позиции.
получается, что объект-накладная должен знать класс объекта позиции.
тогда при копировании он сможет создать соответствующий объект,
и сделать копию всех, входящих в него записей.

для того, чтобы создав объект-детаил сделать его копию необходимо знать
какие поля в этом объекте отвечают за связь с мастер объектом.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

управление транзакциями. мы хотели бы сделать свое. для того чтобы каждый программист
не изобретал велосипед.

1. каждый бизнес объект получает свою транзакцию.
2. связанные через мастер-детайл объекты имеют общую транзакцию.
3. транзакция открывается автоматически при открытии датасета.
4. при закрытии датасета транзакция не закрывается сразу, а через некоторое время.
5. не связанные связью мастер-дитэйл объекты имеют разные транзакции.
   Например, если для редактирования записи вызывается диалоговое окно, а
   в нем есть лукапы, связанные с бизнес объектами, то для редактирования
   тех объектов открываются свои транзакции. Т.е. мы зашли в диалог, открыли
   лукап, выделили в нем объект. Затем решили этот объект немного подправить.
   Внесли изменение. А из диалогового окна решили выйти по Отмене. В этом случае
   в нашем бизнес-объекте изменения не сохранятся, а в том, что был в лукапе --
   сохранятся. Они на разных транзакциях.   

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Интересную штуку мы хотим добавить в базовый класс -- это размер датасета,
количество записей. Зачем это надо? Например, в лукапе выбора товара в прайс листе
стоит упорядочение по наименованию. Для большинства организаций это вполне приемлемо,
однако для компаний, у которых в справочнике товаров полмиллиона позиций
припопытке выбрать лукап и вывести список в выпадающем окне он просто подвиснет.
Надо, чтобы в этом случае сортировка не применялась. Т.е. лукап должен опросить
бизнес-объект и если тот сообщает ему, что справочник большой, то сортировку не применять.

Теперь, как БА будет знать, что справочник большой? Выполнять для этого запрос
нерационально и неэффективно. Объект должен, при случае, узнавать об этом и
запоминать. Переодически эта информация должна обновляться.

             01-11-2001  sai     1. Добавлены два класса для поиска и выбоки объектов
                                 TgdcFindObject, TgdcFindObjectList
                                 2. Переделаны методы Find, Choose, ChooseElement
                                 3. Перделана форма поиска gdc_dlgFind
             17-11-2001 Michael  Добавлено событие OnAfterInitSQL - для возможности перекрыть
                                 запрос, который стандартно создан.

*)

unit gdcBase;

interface

uses
  Classes, Windows, Controls, DB, IB, IBHeader, IBDatabase, IBCustomDataSet,
  IBSQL, SysUtils, DBGrids, Forms, gdcBaseInterface, Contnrs, Clipbrd,
  MSScriptControl_TLB, menus, flt_sqlFilter, at_sql_setup, gd_createable_form,
  ActnList, gd_ClassList, gsStorage, RUID, gd_KeyAssoc, ExtCtrls,
  mtd_i_Base;//, mtd_Inherited;

const
  ////////////////////////////////////////////////////////////
  // константы смещения операций, относительно главной ветви
  GDC_OP_ACCESS          =  2;
  GDC_OP_CREATE          =  4;
  GDC_OP_CHANGE          =  6;
  GDC_OP_DELETE          =  8;
  GDC_OP_PRINT           = 10;
  GDC_OP_CHANGERIGHT     = 12;

  //
  CST_REPORTCAPTION      = 'Печать';
  CST_REPORTGROUPID      = -1;
  CST_REPORTREGISTRYLIST = 'Список форм ...';

  CST_MACROSMENU         = 'Макросы ...';

  // Название формы на которой добавляются глобальные макросы
  GDC_SC_MACROSMODULE    = 'frmExplorer';
  GDC_SC_TYPEEVENT       = 'E';
  GDC_SC_TYPEMACROS      = 'M';
  CST_ALL                = 'All';

  // Имена методов, для которых реализуется перекрытия макросами
  GDC_CUSTOMINSERT       = 'CUSTOMINSERT';
  GDC_CUSTOMMODIFY       = 'CUSTOMMODIFY';
  GDC_CUSTOMDELETE       = 'CUSTOMDELETE';
  GDC_DOAFTERDELETE      = 'DOAFTERDELETE';
  GDC_DOAFTERINSERT      = 'DOAFTERINSERT';
  GDC_DOAFTEROPEN        = 'DOAFTEROPEN';
  GDC_DOAFTERPOST        = 'DOAFTERPOST';
  GDC_DOBEFORECLOSE      = 'DOBEFORECLOSE';
  GDC_DOBEFOREDELETE     = 'DOBEFOREDELETE';
  GDC_DOBEFOREEDIT       = 'DOBEFOREEDIT';
  GDC_DOBEFOREINSERT     = 'DOBEFOREINSERT';
  GDC_DOBEFOREPOST       = 'DOBEFOREPOST';
  GDC_DOONNEWRECORD      = 'DOONNEWRECORD';  
  GDC_DOAFTERTRANSACTIONEND = 'DOAFTERTRANSACTIONEND';
  GDC_GETNOTCOPYFIELD    = 'GETNOTCOPYFIELD';
//  GDC_VALIDATEFIELD      = 'VALIDATEFIELD';

  // Имена классов, в которых перекрываюся методы макросами
  GDC_BASE               = 'TGDCBASE';

type
  TgdcClassName = String;
  TID = Integer;

{type
  // класс для организации стыка вызова перекрытых методов
  TClassListForMethod = class(TStringList)
  public
    // если строка уже есть в списке, то вернуть ее номер, иначе добавить
    function Add(const S: string): Integer; override;
  end;
 }
type
  /////////////////////////////////////////////////////////////
  // типы событий, поддерживаемые бизнес объектом
  TgdcEventTypes = (etAfterCancel, etAfterClose, etAfterDelete, etAfterEdit,
                 etAfterInsert, etAfterOpen, etAfterPost, etAfterRefresh,
                 etAfterScroll, etBeforeCancel, etBeforeClose, etBeforeDelete,
                 etBeforeEdit, etBeforeInsert, etBeforeOpen, etBeforePost,
                 etBeforeRefresh, etBeforeScroll, etOnCalcFields, etOnNewRecord,
                 etOnFieldChange);
const
  /////////////////////////////////////////////////////////////
  // наименования типов событий
  gdcEventTypesString: array[TgdcEventTypes] of String =
                ('AfterCancel', 'AfterClose', 'AfterDelete', 'AfterEdit',
                 'AfterInsert', 'AfterOpen', 'AfterPost', 'AfterRefresh',
                 'AfterScroll', 'BeforeCancel', 'BeforeClose', 'BeforeDelete',
                 'BeforeEdit', 'BeforeInsert', 'BeforeOpen', 'BeforePost',
                 'BeforeRefresh', 'BeforeScroll', 'OnCalcFields', 'OnNewRecord',
                 'OnFieldChange');

{type
  TgsDialogAction = (
    daOkNone,                // Post и все
    daOkCommit,              // Post & Commit, датасет будет закрыт
    daOkCommitReopen,        // Post & Commit, датасет будет переоткрыт
    daOkCommitRetaining,     // Post & Commit retaining, датасет переоткрываться принудительно не будет
    daCancelNone,            // Cancel only
    daCancelRollback,        // Cancel & Rollback
    daCancelRollbackReopen,  // Cancel & Rollback, dataset will be reopened
    daCancelRollbackRetaining// Cancel & Rollback reopening dataset
    );
  TgsDialogActions = set of TgsDialogAction;

const
  DefDialogActions = [daOkCommitRetaining, daCancelRollbackRetaining];}

// Тип для создания события которое вызывается после выполнения InitSQL
// SQLText - Текст запроса
// isReplaceSQL - Заменить созданный InitSQL запрос на SQLText или нет

type
  TgdcAfterInitSQL = procedure (Sender: TObject;
    var SQLText: String; var isReplaceSQL: Boolean) of object;

  // запускается перед появлением дилогового окна ввода нового
  // объекта или редактирования старого
  TgdcDoBeforeShowDialog = procedure (Sender: TObject;
    DlgForm: TCustomForm) of object;

  // запускается после закрытия дилогового окна ввода нового
  // объекта или редактирования старого
  TgdcDoAfterShowDialog = procedure (Sender: TObject;
    DlgForm: TCustomForm; IsOk: Boolean) of object;

    
type
  /////////////////////////////////////////////////////////////
  //  Состояние объекта
  TgdcState = (
    sNone,
    sView,        // объект подключен к форме
    sDialog,      // объект подключен к диалоговому окну
    sSubDialog,
    sSyncControls
  );
  TgdcStates = set of TgdcState;

  TgdcBase = class;

  CgdcBase = class of TgdcBase;

  //////////////////////////////////////////////////////////
  // подмножество
  TgdcSubSet = String;

  //////////////////////////////////////////////////////////
  // подтип 
  TgdcSubType = String;

  //////////////////////////////////////////////////////////
  // Поскольку полное задание класса бизнес объекта
  // подразумевает указание собственно класса объекта и
  // подтипа, введем запись, которая будет использоваться
  // для передачи/хранения такой информации
  TgdcFullClass = record
    gdClass: CgdcBase;
    SubType: TgdcSubType;
  end;

  //
  TgdcObjectSet = class
  private
    FgdClass: CgdcBase;
    FSubType: TgdcSubType;
    FArray: array of TID;
    FCount: Integer;

    function Get_gdClass: CgdcBase;
    function Get_gdClassName: String;
    function GetCount: Integer;
    function GetItems(Index: Integer): TID;
    procedure Set_gdClass(const Value: CgdcBase);
    function GetSize: Integer;
    function GetSubType: TgdcSubType;
    procedure SetSubType(const Value: TgdcSubType);

  public
    constructor Create(AgdClass: CgdcBase; const ASubType: TgdcSubType; const ASize: Integer = 32);
    destructor Destroy; override;

    function Add(const AnID: TID): Integer;
    function Find(const AnID: TID): Integer;
    procedure Remove(const AnID: TID);
    procedure Delete(const Index: Integer);

    procedure LoadFromStream(S: TStream);
    procedure SaveToStream(S: TStream);

    property gdClass: CgdcBase read Get_gdClass write Set_gdClass;
    property gdClassName: String read Get_gdClassName;
    property SubType: TgdcSubType read GetSubType write SetSubType;
    property Items[Index: Integer]: TID read GetItems; default;
    property Count: Integer read GetCount;
    property Size: Integer read GetSize;
  end;

  TgdcObjectSets = class(TObjectList)
  public
    constructor Create;

    function Find(C: TgdcFullClass): TgdcObjectSet;

    procedure SaveToStream(S: TStream);
    procedure LoadFromStream(S: TStream);
  end;

  TgdcFindObject = class(TObject)
  private
    FID: String;
    FValues: TStringList;

  public
    constructor Create; overload; virtual;
    constructor Create(const AnID: String; const Names: String); overload; virtual;
    constructor Create(const AnID: String; const Names: String;
      const AnValues: TStringList); overload; virtual;
    constructor Create(const AnID: String); overload; virtual;
    destructor Destroy; override;

    procedure SetValues(const AnValues: TStringList); overload;
    // Записывает в объект значения полей используется в gdc_dlgFind
    procedure SetValues(const gdcBase: TgdcBase); overload;

    property ID: String read FID write FID;
    property Values: TStringList read FValues write FValues;
  end;

  TgdcFindObjectList = class(TObjectList)
  private
    FNames: TStringList;

    function GetItem(Index: Integer): TgdcFindObject;

  public
    constructor Create(const Names: String); virtual;
    destructor Destroy; override;

    function Add(const AnID: String; Values: TStringList): Integer;

    property Items[Index: Integer]: TgdcFindObject read GetItem;
    property Names: TStringList read FNames write FNames;
  end;

  //////////////////////////////////////////////////////////
  // каб не прапісваць паўсюль датабэйз завядзем свой мэнэджэр,
  // адзін на праект і будзем праз яго вытасківаць датабэйз
  TgdcBaseManager = class(TComponent, IgdcBaseManager)
  private
    FIBBase: TIBBase;
    FReadTransaction: TIBTransaction;

    function GetDatabase: TIBDatabase;
    procedure SetDatabase(const Value: TIBDatabase);

    // пробегается по всем зарегистрированным в глобальном списке
    // объектам и присваивает им датабэйз
    //procedure InitObjects;
    function GetReadTransaction: TIBTransaction;

  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;

  public
    constructor Create(AnOwner: TComponent); override;
    destructor Destroy; override;

    property ReadTransaction: TIBTransaction read GetReadTransaction;

  published
    property Database: TIBDatabase read GetDatabase write SetDatabase;
  end;

  //////////////////////////////////////////////////////////
  // механізм, закладзены ў ТІБДатаСет не задавальняе нас
  // бо і ў масцер і ў детаіл датасеце могуць існаваць
  // паля з аднолькавамі назвамі (ІД -- часцей за ўсе)
  // мы ўводзім свой механізм сувязі масцер-дзітэйл
  TgdcDataLink = class(TDataLink)
  private
    FMasterField: TStringList;
    FDetailField: TStringList;
    FTimer: TTimer;
    FDetailObject: TgdcBase;

    procedure DoOnTimer(Sender: TObject);
    function GetDetailField: String;
    function GetMasterField: String;
    procedure SetDetailField(const Value: String);
    procedure SetMasterField(const Value: String);

  protected
    FLinkEstablished: Boolean;

    procedure ActiveChanged; override;
    procedure EditingChanged; override;
    procedure RecordChanged(F: TField); override;
    //procedure RefreshParams(const AnyWay: Boolean);

  public
    constructor Create(ADetailObject: TgdcBase);
    destructor Destroy; override;

    procedure CheckBrowseMode; override;

    property MasterField: String read GetMasterField write SetMasterField;
    property DetailField: String read GetDetailField write SetDetailField;
  end;

  //////////////////////////////////////////////////////////
  // аггрегаты -- значения, вычисляемые по группе записей
  //
  TgdcAggregate = class;
  TgdcAggregates = class;
  TgdcAggUpdateEvent = procedure(Agg: TgdcAggregate) of object;

  TgdcAggregate = class(TCollectionItem)
  private
    FVisible: Boolean;
    FActive: Boolean;
    FInUse: Boolean;
    FDataSize: Integer;
    FIndexName: String;
    FAggregateName: String;
    FExpression: String;
    FDataType: TFieldType;
    FOnUpdate: TgdcAggUpdateEvent;
    FDataSet: TgdcBase;

    procedure SetActive(const Value: Boolean);
    procedure SetExpression(const Value: String);
    procedure SetIndexName(const Value: String);
    procedure SetVisible(const Value: Boolean);

  public
    constructor Create(AnAggregates: TgdcAggregates; ADataSet: TgdcBase); reintroduce;
    destructor Destroy; override;

    function Value: Variant;
    function GetDisplayName: String; override;

    property Active: Boolean read FActive write SetActive;
    property AggregateName: String read FAggregateName write FAggregateName;
    property DataSet: TgdcBase read FDataSet;
    property DataSize: Integer read FDataSize;
    property DataType: TFieldType read FDataType;
    property Expression: String read FExpression write SetExpression;
    property IndexName: String read FIndexName write SetIndexName;
    property InUse: Boolean read FInUse;
    property OnUpdate: TgdcAggUpdateEvent read FOnUpdate write FOnUpdate;
    property Visible: Boolean read FVisible write SetVisible;
  end;

  TgdcAggregates = class(TCollection)
  private
    FOwner: TPersistent;

    function GetItem(Index: Integer): TgdcAggregate;
    procedure SetItem(Index: Integer; const Value: TgdcAggregate);

  protected
    function GetOwner: TPersistent; override;

  public
    constructor Create(Owner: TPersistent);

    function Add: TgdcAggregate;
    procedure Clear;
    function Find(const DisplayName: string): TgdcAggregate;
    function IndexOf(const DisplayName: string): Integer;
    property Items[Index: Integer]: TgdcAggregate read GetItem write SetItem; default;
  end;

  //////////////////////////////////////////////////////////
  // информация о структуре главной таблицы объекта
  TgdcTableInfo = (
    tiID,              // ёсць ідэнтыфікатар
    tiParent,          // ёсць спасылка на бацькоўскі запіс (дрававідная структура)
    tiLBRB,            // ёсць палі з межамі (інтэрвальнае дрэва)
    tiCreationInfo,    // інфармацыя аб тым, хто і калі стварыў аб'ект
    tiEditionInfo,     // інфармацыя аб тым, хто і калі выправіў аб'ект
    tiAFull,           // ёсць дэскрыптары бяспекі
    tiAChag,           // --//--
    tiAView            // --//--
  );
  TgdcTableInfos = set of TgdcTableInfo;

  //////////////////////////////////////////////////////////
  // for transferring gdc objects via clipboard
  // we register our own clipboard format
  TIDArr = array[0..0] of TID;
  TObjectNameChar = array[0..63] of Char;
  TObjectNameArr = array[0..0] of TObjectNameChar;
  PgdcClipboardData = ^TgdcClipboardData;
  TgdcClipboardData = record
    Signature: Longint;
    Version: Longint;
    ClassName: array[0..47] of Char;
    Obj: TgdcBase;
    Cut: Boolean;
    IDCount: Integer;
    ID: TIDArr;
    ObjectName: TObjectNameArr;
  end;

  /////////////////////////////////////////////////////////
  // тип комита и ролбэка для базового класса
{  TgsCommitType = (
    ctHard,            // commit, close dataset
    ctHardReopen,      // commit, reopen dataset if it were open
    ctRetaining,       // commit retaining, close dataset
    ctRetainingReopen  // commit retaining, reopen dataset if it were open
  );}

  /////////////////////////////////////////////////////////
  // если данные объекта хранятся в нескольких таблицах,
  // то мы должны перекрывать борландовские методы и
  // выполнять вставку, изменение, удаление по-свойму

  { TODO : 
фактически в КастомИнсерт и КастомМодифай нет никакого толку.
Только КастомДелете сейчас используется в удалении нескольких
одновременно. }
  TgsCustomProcess = (cpInsert, cpModify, cpDelete);
  TgsCustomProcesses = set of TgsCustomProcess;

  // используется для сохранения значений полей до редактирования
  // для того чтобы в последствии можно было отменить исправления
  TFieldValue = class(TObject)
  public
    FieldName: String;
    Value: String;
    IsNull: Boolean;
  end;

  /////////////////////////////////////////////////////////
  // базавы клас для бізнэс аб'ектаў
  TgdcBase = class(TIBCustomDataSet, IgdcBase)
  private
    FParentForm: TWinControl;
    FAggregatesActive: Boolean;
    FDetailLinks: TObjectList;
    FSubSets: TStringList;
    FSearchSubSet: TgdcSubSet;
    FgdcTableInfos: TgdcTableInfos;
    FNameInScript: String;
    FEventList: TStringList;
    FFindWhereSQL: String;
    FBaseState: TgdcStates;
    FpmReport: TPopupMenu;
    FFilter: TgsQueryFilter;
    FOnFilterChanged: TNotifyEvent;
    //FDialogActions: TgsDialogActions;
    FOldValues: TObjectList;
    FSubType: String;
    FCustomProcess: TgsCustomProcesses;
    FExecQuery: TIBSQL;
    FUpdateableFields: String;
    FExtraConditions: TStringList;
    FSelectedID: TgdKeyArray;
    FDlgStack: TObjectStack;
    FDeletingID: TID;
    FSavedParams: TObjectList;
    FSetMasterField, FSetItemField: String;

    FBeforeShowDialog: TgdcDoBeforeShowDialog;
    FAfterShowDialog: TgdcDoAfterShowDialog;

    FAfterInitSQL: TgdcAfterInitSQL;

    FGetDialogDefaultsFieldsCached: Boolean;
    FGetDialogDefaultsFieldsCache: String;
    FRefreshMaster: Boolean;

    // поля для перекрытия методов макросами
    FFunctionClassList: TClassListForMethod;
    FLastCallClass: TClassListForMethod;
    FMethodWithInherited: TStrings;
    FSetTable: String;

    function GetMethodControl: IMethodControl;

    function GetDetailField: String;
    function GetMasterField: String;
    function GetMasterSource: TDataSource;

    procedure SetDetailField(const Value: String);
    procedure SetMasterField(const Value: String);

    function GetID: Integer;
    procedure SetID(const Value: Integer);

    procedure SetAggregatesActive(const Value: Boolean);

    // Запуск на выполнение
    function GetNameInScript: String;
    procedure SetFindWhereSQL(const Value: String);

    // выводит список таблиц, и записей в этих таблицах, которые содержат
    // поля-ссылки, ссылающиеся на текущую запись. Выводит в диалоговом окне
    procedure IsUse;

    // Вызов списка отчетов
    procedure DoOnReportListClick(Sender: TObject);
    // Печать отчета по заданному ИД
    procedure PrintReport(const ID: Integer);
    function GetHasWhereClause: Boolean;

    // для заданного поля возвращает: подлегает это поле
    // копированию или нет
    function TestCopyField(const FieldName: String): Boolean;

    // формирование выпадающего меню со списком отчетов
    // доступных для данного объекта
    procedure MakeReportMenu;

    //
    procedure DoOnFilterChanged(Sender: TObject; const AnCurrentFilter: Integer);

    function GetDetailLinks(Index: Integer): TgdcBase;
    function GetDetailLinksCount: Integer;
    function GetObjectName: String;
    procedure SetObjectName(const Value: String);
    procedure SetSearchSubSet(const Value: TgdcSubSet);
    function GetCreationDate: TDateTime;
    function GetCreatorKey: TID;
    function GetCreatorName: String;
    function GetEditionDate: TDateTime;
    function GetEditorKey: TID;
    function GetEditorName: String;
    function GetExtraConditions: TStrings;
    procedure DoAfterExtraChanged(Sender: TObject);
    function GetDSModified: Boolean;
    function GetSelectedID: TgdKeyArray;
    function GetSubSet: TgdcSubSet;
    function GetSubSetCount: Integer;
    function GetSubSets(Index: Integer): TgdcSubSet;
    procedure SetSubSets(Index: Integer; const Value: TgdcSubSet);

    // Процедура для регистрации методов TgdcBase для перекрытия их из макросов
    class procedure RegisterMethod;

    function IsSubSetStored: Boolean;
    function IsNameInScriptStored: Boolean;
    function IsReadTransactionStored: Boolean;
    function IsTransactionStored: Boolean;
    procedure SetSelectedID(const Value: TgdKeyArray);
    procedure SetSetTable(const Value: String);

  protected
    FgdcDataLink: TgdcDataLink;
    FInternalTransaction: TIBTransaction;
    FID: Integer;
    FObjectName: String;
    //FIBSQL: TIBSQL;
    FSQLSetup: TatSQLSetup;
    FDSModified: Boolean;
    FSQLInitialized: Boolean;

    // Методы для перегрузки методов макросами
    // Метод вызывается по Inherited в макросе
    // В методе осуществляется передача параметров из макроса и
    // вызов  метода Делфи. Дальнейшая обработка идет в перекрытом методе Делфи
    // Name - имя перекрываемого метода, AnParams - вариантный массив параметров метода
    function OnInvoker(const Name: WideString; AnParams: OleVariant): OleVariant;
    // Метод очищает стек классов вызова перекрытого метода
    // AClass, AMethod - имя класса и метода, из которого вызывается процедура
    procedure ClearMacrosStack(const AClass, AMethod: String);
    // Метод устанавливает класс, из которого впервые вызван перекрытый метод
    // установка делается для того, чтобы знать, где очищатьстек
    procedure SetFirstClassMethod(const AClass, AMethod: String);

    //
    procedure SetSubSet(const Value: TgdcSubSet); virtual;

    // В некоторых классах поддерживаются не все варианты действий
    //procedure SetDialogActions(const Value: TgsDialogActions); virtual;

    // Печать отчета. OnClick - в PopupMenu
    procedure DoOnReportClick(Sender: TObject); virtual;

    // проверяет, является ли переданный класс потомком текущего класса
    // если нет -- вызывает исключение
    class procedure CheckClass(C: TClass);

    // Устанавливает DataBase и Transaction для FIBSQL
    //procedure SetIBSQL;

    // выполняет заданный СКЛ запрос
    // коммит не делает
    procedure ExecSingleQuery(const S: String); overload;
    procedure ExecSingleQuery(const S: String; Param: Variant); overload;

    // функция пытается удалить запись. Если ей это удается, то возвращает
    // Истину, если нет, то вызывает окно со списком ссылающихся таблиц
    // из-за которых не удается произвести удаление
    { TODO :
Сейчас не производится проверка на тип возникшей ошибки.
Так, если запись нельзя удалить из-за отсутствия прав
(на уровне ИБ), то все равно ситуация будет представлена так
будто идет нарушение ссылочной целостности. }
    function DeleteRecord: Boolean; virtual;

    procedure SetMasterSource(Value: TDataSource); virtual;

    // в зависимости от установленного СабСета программист
    // добавляет в этом методе в параметр С условия отбора записей.
    // каждое отдельное условие задается одной строкой и будет
    // связано в итоговом запросе через AND.
    // можно в одной строке указать несколько условий самостоятельно
    // связав их Эндами.
    // если надо несколько условий связать через логическое ИЛИ, то
    // их НАДО указать в одноу строке, связав ИЛИ.
    // концевые и лидирующие пробелы не требуются.
    // WHERE добавлять не надо!
    procedure GetWhereClauseConditions(S: TStrings); virtual;

    // запыт мы канструіруем "на лету", складаючы яго з
    // частак, якія вяртаюцца праз гэтыя функцыі
    function GetSelectClause: String; virtual;
    function GetFromClause: String; virtual;
    function GetWhereClause: String; virtual;
    function GetGroupClause: String; virtual;
    function GetOrderClause: String; virtual;

    // наступныя функцыі вяртаюць тэксты СКЛ запытаў
    // для адпаведных аб'ектаў ІБ Датасета
    function GetSelectSQLText: String; virtual;
    function GetModifySQLText: String; virtual;
    function GetInsertSQLText: String; virtual;
    function GetDeleteSQLText: String; virtual;
    function GetRefreshSQLText: String; virtual;

    // ініцыялізуе СКЛ кампанэнты
    procedure InitSQL;

    // напрыклад аб'ект рэпрэзентуюць у базе запісы ў некалькіх
    // табліцах, тады па Інсэрту мы мусім зрабіць некалькі
    // інсэртаў у базу дадзеных
    //
    // асобную ўвагу трэба звярнуць на вяртаньне базы
    // у першапачатковы стан, калі цягам складанага інсэрту
    // ці апдэйту ўзнікае памылка. Ніжэй аб'яуленыя метады
    // мусяць, альбо цалкам выканаць аперацыю, альбо, калі
    // ўзнікае памылка, вернуць базу ў зыходны стан, які
    // яна мела да таго як пачалася аперацыя кастам інсэрт,
    // альбо кастам модіфай і завершыцца з генерацыяй выключнай
    // сітуацыі.
    //
    // Трэ ведаць: хто стартаваў транзакцыю.
    procedure CustomInsert(Buff: Pointer); virtual;
    procedure CustomModify(Buff: Pointer); virtual;
    procedure CustomDelete(Buff: Pointer); virtual;

    //
    procedure _CustomInsert(Buff: Pointer); virtual;
    procedure _CustomModify(Buff: Pointer); virtual;
    procedure _CustomDelete(Buff: Pointer); virtual;

    // Метод вызывается после окончания одного из процессов по
    // добавлению, редактированию, удалению
    procedure DoAfterCustomProcess(Buff: Pointer; Process: TgsCustomProcess); virtual;

    // дапаможная функцыя, выкарыстоўваецца ў CustomInsert & CustomModify
    procedure CustomExecQuery(const ASQL: String; Buff: Pointer);

    //
    procedure RefreshParams;

    //
    function GetDialogDefaultsFields: String; virtual;
    procedure LoadDialogDefaults(F: TgsStorageFolder; Dlg: TForm); overload; virtual;
    procedure LoadDialogDefaults; overload; virtual;
    procedure SaveDialogDefaults(F: TgsStorageFolder; Dlg: TForm); overload; virtual;
    procedure SaveDialogDefaults; overload; virtual;

    // перекрываем метод для выполнения следующих действий:
    // 1. проверка прав на создания записи. Вообще, интерфейс должен быть
    //    построен таким образом, чтобы у пользователя не было возможности
    //    создать новую запись, если у него нет прав. Но если
    //    все-таки мы дошли до этого метода, то надо выкинуть Исключение.
    // 2. инициализация уникального идентификатора.
    // 3. инициализация прав доступа к записи.
    // 4. инициализация прочих полей значениями по-умолчанию.
    // 5. вызов макроса обработчика события
    // 6. инициализация полей последними введенными значениями,
    //    (если объект используется в диалоговом окне).
    procedure DoOnNewRecord; override;
    procedure _DoOnNewRecord; virtual;

    // для рэдактаваньня аднаго запісу мы выкарыстоўваем дыялогавае
    // акно. Перад тым як вывесці яго на экран яго трэба стварыць і
    // настроіць, чым і займаецца гэтая функцыя
    function CreateDialogForm: TCreateableForm; virtual;

    // !!!
    // крыху падпраўляем Борланд, каб яны падтрымлівалі нашыя аб'екты
    procedure InternalPostRecord(Qry: TIBSQL; Buff: Pointer); override;
    procedure InternalDeleteRecord(Qry: TIBSQL; Buff: Pointer); override;

    // на наш аб'ект звалілася нешта з драг-энд-дропу, ці кліпбоарду
    // мусім праверыць ці пасуе гэта нам, тады вернем Ісціна
    // калі не -- Ілжа
    function AcceptClipboard(CD: PgdcClipboardData): Boolean; virtual;

    //
    procedure ResetAllAggs(AnActive: Boolean);

    //
    function GetDetailClasses(Index: Integer): CgdcBase; virtual;
    function GetDetailClassesCount: Integer; virtual;

    // копирует для заданной главной таблицы все ссылающиеся записи в детальных
    // таблицах. AnOldID -- идентификатор исходной главной записи
    // ANewID -- идентификатор записи-копии в главной таблице
    procedure CopyDetailTable(const AMasterTableName: String;
      const AnOldID, ANewID: Integer);

    //
    procedure InternalDelete; override;

    //
    procedure Loaded; override;

    //
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;

    //
    procedure InternalOpen; override;
    procedure InternalSetParamsFromCursor; override;

    //
    procedure DoBeforeOpen; override;

    // перехватывая данный метод мы решаем следующие задачи:
    // 1. заполняем внутреннюю переменную информацией о структуре
    //    датасета (есть ли лескрипторы безопасности и пр.)
    // 2. локализуем назавания полей, присваиваем DisplayLabel
    procedure CreateFields; override;

    //наследованные события для запуска скриптов
    procedure DoAfterDelete; override;
    procedure DoAfterInsert; override;
    procedure DoAfterOpen; override;
    procedure DoAfterPost; override;
    procedure DoBeforeClose; override;
    procedure DoBeforeDelete; override;
    procedure DoBeforeEdit; override;
    procedure DoBeforeInsert; override;
//    procedure DoBeforeOpen; override;
    procedure DoBeforePost; override;
//    procedure DoOnNewRecord; override;

    procedure DoAfterTransactionEnd(Sender: TObject); override;

    procedure LoadEventList; virtual;
    function GetGroupID: Integer; virtual;

    procedure ChooseElement(F: TgdcFindObject); virtual;

    // Для Copy и Past
    function GetCopyFieldName: String; virtual;
    function GetCopyValue: Variant; virtual;

    // Список полей, которые не надо копировать
    // при копировании объекта
    // наименования полей разделены запятой
    // строка запятой не заканчивается!
    function GetNotCopyField: String; virtual;

    // две функции для добавления и удаления из списка
    // детальных объектов
    procedure AddDetailLink(AnObject: TgdcBase);
    procedure RemoveDetailLink(AnObject: TgdcBase);

    //
    procedure ValidateField(Sender: TField); virtual;

    // возвращает список классов, являющихся потомками
    // для данного класса. Используется в диалоге выбора
    // класса при создании потомка
    function GetChildrenClass(CL: TClassList): Boolean; virtual;

    // при вызове диалогового окна на редактирование из другого
    // диалогового окна мы должны запомнить какие поля были изменены
    // в этом диалоговом окне, для того, чтобы при нажатии на кнопку Ок
    // вернуть их в исходное состояние
    // использовать Cancel мы не можем, так как объект у нас один на
    // два окна
    procedure InternalSetFieldData(Field: TField; Buffer: Pointer); override;

    //
    procedure SetSubType(const Value: String); virtual;
    function GetSubType: String; virtual;

    // если бизнес-объект представляет собой объединение данных из
    // нескольких таблиц, то может возникнуть следующая ситуация:
    // для примера, возьмем объект Товар, который объединяет данные
    // из таблицы Товары и Единицы измерения. Бизнес объект
    // выводит следующие данные: Наименование товара, наименование ед.
    // измерения, Коэффициент пересчета этой единицы измерения в базовую.
    // Для редактирования данных объекта создано диалоговое окно
    // в котором используется Эдит для вывода/редактирования наименования
    // товара, выпадающий список для просмотра/выбора единицы измерения
    // Метку для вывода коэффициента пересчета. Если в выпадающем списке
    // выбрать другую единицу измерения, то надо обновить поле
    // коэффициент пересчета. Рефреш записи тут невозможен так как
    // объект (датасет) находится в состоянии редактирования.
    // Для решения данной проблемы используется метод SyncField
    // он вызывается сразу после изменения данных поля. Если
    // при изменении некоторого поля (в нашем примере это будет поле,
    // хранящее ссылку на запись в таблице единиц измерения) необходимо
    // обновить значение другого поля бизнес-объекта, физически
    // являющегося полем таблицы, на которую идет ссылка, то
    // этот метод должен быть перекрыт и в нем должен быть создан
    // и выполнен запрос, который бы вытаскивал данные из связанной
    // таблицы.
    //
    // ...кроме этого вызывается SyncControls у диалогового окна.
    procedure SyncField(Field: TField); virtual;

    // возвращает истина, если значение поля было изменено
    // в процессе редактирования текущей записи
    function FieldChanged(const AFieldName: String): Boolean;

    //
    procedure SetCustomProcess(const Value: TgsCustomProcesses);
    function GetCustomProcess: TgsCustomProcesses; virtual;

    //
    //procedure _CommitRollback(const ACommit: Boolean; const AType: TgsCommitType);

    // вспомогательная функция. в СКЛ запросе, в секции ФРОМ или ВЕРЕ
    // могут встречаться сравнения вида: имя_поля = :параметр
    // данная функция возвращает имя поля по заданному имени параметра
    // если такой параметр в запросе не фигурирует -- возвращается пустая строка
    function GetFieldNameComparedToParam(const AParamName: String): String;

    // проблема:
    // при сохранении объекта в потоке мы пробегаемся по всем
    // полям ссылкам и сохраняем объекты, на которые они
    // ссылаются. Причем сохранение осуществляется перед сохранением
    // главного объекта.
    // Однако существуют случаи, когда сохранение должно быть выполнено
    // в обратном порядке, т.е. сначала главный объект, потом
    // объект на который идет ссылка и в таком же
    // порядке должно произойти восстановление.
    // пример:
    // у компании может быть ноль, один или несколько рассчетных счетов
    // для их хранения создана таблица gd_companyaccount. Каждый
    // счет имеет свой уникальный идентификатор. Каждый счет связан
    // с компанией, которой он принадлежит через поле ссылку.
    // Ссылка должна быть обязательно заполнена.
    // Один из счетов компании является главным. Для его хранения
    // в таблицу gd_company добавлено поле companyaccountkey
    // которое содержит ссылку на главный счет. Поле может быть
    // и не заполнено.
    // Если при сохранении объекта компании следовать стандартной
    // последовательности, т.е. сначала сохранить объект счет, на который
    // идет ссылка, потом объект компанию, то при загрузке в базу
    // возникнут проблемы. Первым будет восстанавливаться объект счет
    // но он содержит обязательную ссылку на объект компанию, которая
    // еще не загружена и следовательно Пост не пройдет.
    // Решением проблемы является сохранение объектов в обратном
    // порядке: сначала объект компания, потом счет.
    // В функцию передается имя поля ссылки. Она возвращает False
    // если необходим ПРЯМОЙ порядок сохранения и ИСТИНА, если обратный.
    function IsReverseOrder(const AFieldName: String): Boolean; virtual;

    // создали новую запись (Insert). пытаемся ее сохранить (Post).
    // возникает ошибка.
    // возможно, такая запись уже существует в базе.
    // данная функция попытается найти подходящую запись
    // и, если она есть, установит курсор на нее и вернет
    // Истина. Если записи нет -- вернет Ложь.
    // При этом датасет будет выведен из состояния вставки через Cancel.
    function CheckTheSame: Boolean;
    // Функция использует следующую функцию, которая должна
    // вернуть сформированный запрос, который поможет отыскивать
    // такую же запись.
    function CheckTheSameStatement: String; virtual;

    //
    procedure InternalPrepare; override;
    procedure InternalUnPrepare; override;

    // создает компонент ИБСКЛ инициализируя его
    // свойства Датабэйз и Транзакция
    function CreateReadIBSQL: TIBSQL; overload;
    function CreateReadIBSQL(out DidActivate: Boolean): TIBSQL; overload;

    //
    procedure SetTransaction(Value: TIBTransaction); override;

    // переопределяя метод GetCustomProcess можно добиться того, что
    // в зависимости от состояния объекта будет применяться сложный
    // или обычный апдейт данных
    // например, если БА представляет собой объединение данных из
    // нескольких таблиц, то динамически можно возвращать кастом процесс
    // следующим образом: если изменялись только поля основной таблицы
    // то особой обработки не надо и можно передать управление обычному
    // датасетовскому обработчику, если же произошло изменение полей
    // и в основной и в присоединенных таблицах, то необходимо выполнить
    // сложный апдейт
    property CustomProcess: TgsCustomProcesses read GetCustomProcess write SetCustomProcess;

    //Дополнительные условия при слиянии записей
    function GetReductionCondition: String; virtual;
    function GetReductionTable: String; virtual;

    // АнОбджект.СелектедИД -- эти ИД добавляются в множество
    procedure ProcessChooseItems(AnObject: TgdcBase); virtual;

    // текущую запись исключает из множества
    procedure DeleteChoose; virtual;

    // для перекрытия методов макросами
    function GetGdcInterface(Source: TObject): IDispatch;

    // свойство добавлено для перекрытия методов макросами
    // свойство определяет необходимость выполнениея Inherited
    // для метода Делфи
    property MethodWithInherited: TStrings read FMethodWithInherited;
    // для перекрытия методов, чтобы не добавлять в каждом юните ссылку на
    property gdcBaseMethodControl: IMethodControl read GetMethodControl;

  public
    constructor Create(AnOwner: TComponent); override;

    //
    constructor CreateSubType(AnOwner: TComponent; const ASubType: TgdcSubType;
      const ASubSet: TgdcSubSet = 'All'); virtual;

    //
    constructor CreateWithParams(AnOwner: TComponent; ADatabase: TIBDatabase;
      ATransaction: TIBTransaction; const ASubType: TgdcSubType = '';
      const ASubSet: TgdcSubSet = 'All'); virtual;

    //
    constructor CreateWithID(AnOwner: TComponent; ADatabase: TIBDatabase;
      ATransaction: TIBTransaction; const AnID: Integer; const ASubType: String = ''); virtual;

    destructor Destroy; override;

    // инициализируем СКЛ после полного окончания конструирования
    procedure AfterConstruction; override;

    //
    procedure Prepare;
    procedure UnPrepare;

    // если датасет был переведен в состояние редактирования
    // а потом вызван Пост, но никаких изменений произведено не было
    // вызываем Отмену, вместо продолжения Поста.
    // делаем это для того, чтобы избежать конфликта на не ждущей
    // транзакции, когда пользователь зашел в диалоговое окно
    // только посмотрел данные и вышел по Ок
    procedure Post; override;

    // функция проверки сабсета на допустимое значение
    // на уровне базового класса мы определяем два
    // допустимых подмножества, которые должны поддерживать
    // все наследники: All и ByIDz
    function CheckSubSet(const ASubSet: String): Boolean; virtual;

    //
    function Choose(C: CgdcBase; F: TgdcFindObject): Boolean; overload;
    function Choose(F: TgdcFindObject): Boolean; overload;
    function Choose(C: CGdcBase; L: TgdcFindObjectList): Boolean; overload;
    function Choose(L: TgdcFindObjectList): Boolean; overload;
    function Choose(C: CGdcBase): Boolean; overload;
    function Choose: Boolean; overload;

{
    Для TgdcBase добавлены  методы
    1)    procedure ChooseItems(DoProcess: Boolean = True); overload;
        осуществялет выбор из объекта того же типа, что и объект вызвавший метод
    2)    procedure ChooseItems(Cl: CgdcBase; out KeyArray: TgdKeyArray; DoProcess: Boolean = True); overload;
        осуществялет выбор из объекта типа Cl
    для выбора записей из объектов. Флаг DoProcess указывает нужно ли автоматически "обрабатывать" выбранные записи (для этого служит метод ProcessChooseItems). Ключи выбранных записи в первом случае заносятся в свойство SelectedID объекта, вызвавшего ChooseItems, во втором случае они возвращаюся параметром KeyArray.

    Для работы Choose необходимо перекрыть в gdc-объекте слудующие методы:
    // Возращает имя формы
        class function GetViewFormClassName(const ASubType: TgdcSubType): String; virtual;
    // Производит обработку выбранных элементов
        procedure ProcessChooseItems(AnObject: TgdcBase); virtual;
    а также перекрыть  методы для gdc_creatable_form
    //Производит настройку формы для режима Choose
          procedure SetChoose(AnObject: TgdcBase); virtual; AnObject - объект вызвавший ChooseItems
    в FormCreate указать, какой объект будет использоваться для Choose (для форм мастер-дитейл). По умолчанию берется главный объект. (Например, FgdcLinkChoose := gdcDetailObject)

    Также был добавлен метод
        procedure DeleteChooseItems(BL: TBookmarkList);
    для удаления выбранных записей. Для его работы необходимо перекрыть метод
        procedure DeleteChoose; virtual;
}
    procedure ChooseItems(DoProcess: Boolean = True); overload;
    function ChooseItems(Cl: CgdcBase; out KeyArray: TgdKeyArray; DoProcess: Boolean = True): Boolean; overload;

    // исключает из множества
    procedure DeleteChooseItems(BL: TBookmarkList);

    // мы используем эту функцию для передачи хэндла
    // в месадже бокс, чтобы каждый раз не проверять
    // задан родительский управляющий элемент или нет
    // если объект находится на форме, то возвращается
    // хэндл формы. если для объекта открыто диалоговое окно
    // то возвращается хэндл диалогового окна
    function ParentHandle: Integer;

    // выводит на экран меню со списком доступных для объекта отчетов
    procedure PopupReportMenu(const X, Y: Integer);

    //
    procedure PopupFilterMenu(const X, Y: Integer);

    // функции производят поиск объекта (ов)
    // возвращают ИД (или список ИД)
    procedure Find;

    // мы вымушаныя перавызначыць гэтую функцыю, бо
    // яе няма ў TIBCustomDataSet
    function ParamByName(Idx : String) : TIBXSQLVAR;

    // у выпадку выкарыстаньня ўнутраннай транзакцыі
    // мы мусім даць карыстальніку магчымасць яе каміта
    // і адката
    {procedure Commit(const AType: TgsCommitType);
    procedure Rollback(const AType: TgsCommitType);}

    // стварае новы запіс і адкрывае дыялог для яго рэдактаваньня
    function CreateDialog(const ADlgClassName: String = ''): Boolean; overload; virtual;
    function CreateDialog(C: CgdcBase): Boolean; overload; virtual;
    function CreateDialog(C: TgdcFullClass): Boolean; overload; virtual;

    // делает новую запись, с предварительным выбором потомков
    function CreateDescendant: Boolean; virtual;

    // стварае копію бягучага запісу і адкрывае дыялог для яго рэдактаваньня
    function CopyDialog: Boolean;

    // запускается перед появлением дилогового окна ввода нового
    // объекта или редактирования старого
    procedure DoBeforeShowDialog(DlgForm: TCreateableForm); virtual;

    // запускается после закрытия дилогового окна ввода нового
    // объекта или редактирования старого
    procedure DoAfterShowDialog(DlgForm: TCreateableForm; IsOk: Boolean); virtual;

    // выдаляе адразу некалькі запісаў, дазеных праз букмаркліст
    function DeleteMultiple(BL: TBookmarkList): Boolean;

    // рэдактаваньне бягучага запісу
    // у дыялоге, вяртае Ісціна, калі карыстальнік
    // выйшаў па Ок і Хлусня ў адваротным выпадку
    function EditDialog(const ADlgClassName: String = ''): Boolean;

    // функцыя адкрывае бягучы запіс на рэдактаваньне
    // потым прабягае па сьпісу запісаў і рэдактуе іх
    // прысваіваючы тыя паля, якія былі зьмененыя пад
    // час рэдактаваньня
    function EditMultiple(BL: TBookmarkList; const ADlgClassName: String = ''): Boolean;

    // функцыя капіраваньня бягучага запісу
    // в заданных полях, в копии, будут установлены заданные
    // значения. Возможно копирование также записей в
    // дитэйл таблицах, ссылающихся на исходную запись
    function Copy(const AFields: String; AValues: Variant; const ACopyDetail: Boolean = False;
      const APost: Boolean = True): Boolean; virtual;

    // захоўвае бягучы запіс (калі ён рэдактаваўся)
    // і ўстаўляе наступны. Функцыя прызначана для выкарыстаньня
    // ў дыялогавых вокнах (кнопка Наступны)
    function CreateNext: Boolean;

    // поддержка работы с клипбоардом
    // копирует в клипбоард текущую запись (BL = nil) или список записей
    procedure CopyToClipboard(BL: TBookmarkList; const ACut: Boolean = False);
    function PasteFromClipboard: Boolean;

    // возвращает Истина, если в клипбоарде есть значение
    // которое может быть вставлено
    function CanPasteFromClipboard: Boolean;

    // позволяет присвоить значение заданному полю в заданной записи
    // для этого выполняется отдельный СКЛ
    procedure AssignField(const AnID: Integer; const AFieldName: String; AValue: Variant);

    // функция возвращает права пользователя на текущую запись
    // если в таблице нет дескрипторов безопасности, то
    // права предоставляются
    function GetUserRights: TUserRights;

    // некоторые поля никогда не должны появляться в гриде
    // данная функция позволяет указать гриду что поле не стоит
    // отображать. Функция должна вернуть список имен полей, разделенных точкой
    // с запятой.
    // список должен оканчиваться точкой с запятой.
    function HideFieldsList: String; virtual;
    function ShowFieldInGrid(AField: TField): Boolean;

    // обновляет содержимое ДатаСета с сохранением
    // текущей позиции
    procedure CloseOpen;

    // нам патрэбны метады каб захоўваць дадзеныя датасета ў
    // плыні і счытваць іх адтуль
    procedure _SaveToStream(Stream: TStream; ObjectSet: TgdcObjectSet); virtual;
    procedure _LoadFromStream(Stream: TStream; IDMapping: TgdKeyIntAssoc; ObjectSet: TgdcObjectSet; UpdateList: TObjectList);

    procedure SaveToStream(Stream: TStream; DetailDS: TgdcBase; const OnlyCurrent: Boolean = True); virtual;
    procedure LoadFromStream(Stream: TStream);

    function QuerySaveFileName(const AFileName: String = ''): String;
    function QueryLoadFileName(const AFileName: String = ''): String;

    procedure SaveToFile(const AFileName: String = '');
    procedure LoadFromFile(const AFileName: String = '');

    // Слияние двух записей
    function Reduction: Boolean; virtual;

    // метод проверяет находится ли Датасет в активном
    // состоянии, в режиме просмотра и не пустой ли он
    // в противном случае генерируется исключение.
    // метод применяется в других методах которые выполняют
    // некоторое действие на основании данных полей из
    // текущей записи. т.е. когда надо быть уверенным, что
    // текущая запись доступна.
    procedure CheckCurrentRecord;

    //
    function GetCurrRecordClass: TgdcFullClass; virtual;

    // Поля используемые для поиска (через запятую)
    function GetFindFieldList: String; virtual;

    // Возвращает значение дисплейного поля по ключу
    class function GetListNameByID(const AnID: TID): String;

    // метод создает копию переданного объекта, при этом копируются
    // следующие свойства:
    // 1. транзакция
    // 2. подмножество
    // 3. DialogActions
    //
    procedure Assign(Source: TPersistent); override;

    // предоставляет пользователю возможность выбрать один из классов
    // наследников для данного класса
    function QueryDescendant: TgdcFullClass;

    // отменяет изменения в полях, используется совместно с sSubDialog
    procedure RevertRecord;

    //Изменение RefreshSQL
    procedure SetRefreshSQLOn(SetOn: Boolean);

    // процедура заполняет переданный список уникальными значениями
    // из заданной колонки. Значения преобразуются в строку.
    // опционально можно задать: сортировать список уникальных значений
    // или нет.
    procedure GetDistinctColumnValues(const AFieldName: String; S: TStrings; const DoSort: Boolean = True);

    // функция возвращает следующее уникальное значение идентификатора
    // объекта. Если параметр установлен в Истина, то генераторы
    // увеличиваются. Функция должна быть переопределена для тех
    // объектов, которые используют свои генераторы для идентификации.
    function GetNextID(const Increment: Boolean = True): Integer; virtual;

    //
    function HasAttribute: Boolean;

    // создает форму для просмотра датасета, для заданного БА
    // поскольку форм может быть предусмотрено несколько, то возможна
    // передача имени класса при вызове функции
    class function CreateViewForm(AnOwner: TComponent; const AClassName: String = '';
      const ASubType: String = ''): TForm; virtual;

    class function GetViewFormClassName(const ASubType: TgdcSubType): String; virtual;

    // фукнция обновляет статистику объекта и сохраняет ее в хранилище
    class procedure RefreshStats;

    // возвращает большая это таблица или нет. Необходимо нам для
    // корректной обработки больших списков в лукапе.
    class function IsBigTable: Boolean;

    //

    class function IsAbstractClass: Boolean; virtual;

    // стварае аб'ект і адкрывае запіс з дадзеным ІД
    // калі такога няма ў базе -- кідаецца выключная сітуацыя
    class function CreateSingularByID(AnOwner: TComponent; ADatabase: TIBDatabase;
      ATransaction: TIBTransaction; const AnID: TID; const ASubType: String = ''): TgdcBase; overload; virtual;
    class function CreateSingularByID(AnOwner: TComponent;
      const AnID: TID; const ASubType: String = ''): TgdcBase; overload; virtual;

    // асноўная табліца аб'екту
    // калі дадзеныя аб'екту захоўваюцца ў адной табліцы,
    // тады гэта яе імя. Калі ў некалькіх, звязаных сувязьзю
    // адзін-да-аднаго, альбо адзін-да-шматлікіх, альбо шмат-да-шматлікіх
    // тады гэтая функцыя вяртае імя галоўнай табліцы
    // галоўная табліца, гэта тая табліца, кожны запіс якой рэпрэзентуе
    // адзін і толькі адзін аб'ект дадзенага тыпу і якая ўтрымлівае першасны
    // ключ
    class function GetListTable(const ASubType: String): String; virtual;
    // поле з назвай аб'екту
    class function GetListField(const ASubType: String): String; virtual;
    // алiас для аб'екта
    class function GetListTableAlias: String;
    // поле з ідэнтыфікатарам аб'екту
    class function GetKeyField(const ASubType: String): String; virtual;

    // умова выдзяленьня падмноства аб'ектаў з усяго
    // мноства запісаў у табліцы
    class function GetRestrictCondition(const ATableName, ASubType: String): String; virtual;

    // функция возвращает идентификатор папки содержащей
    // команды для данного класса в таблице GD_OPERATION
    class function GetOperationFolderID: Integer; virtual;

    // проверяет есть ли у текущего пользователя права на весь
    // набор указанных операций
    class function TestRightForOp(const AnOp: TgdcOperations): Boolean;

    // калі трэба будзе вывесці назву аб'екта, рэпрэзентуемага
    // дадзеным клясам карыстальніку
    // па-ўмалчаньню, выводзіць лакалізаваны назоў галоўнай табліцы
    class function GetDisplayName(const ASubType: String): String; virtual;

    // функция, возвращает список возможных подтипов в SubTypeList в формате
    // Локализованное имя подтипа=Подтип
    // функция возвращает True, если подтипы есть, иначе - False
    class function GetSubTypeList(SubTypeList: TStrings): Boolean; virtual;

    // вяртае інфармацыю аб структуры галоўнай табліцы БА, выкарыстоўваючы
    // атДатабэйз. Такім чынам гэты метад можа быць выкліканы ў любы момант
    // адразу пасля таго як створаны і ініцыялізаваны аб'ект атДатабэйз.
    class function GetTableInfos(const ASubType: String): TgdcTableInfos; virtual;

    // вяртае сьпіс дапушчальных сабсэтаў для дадзенага кляса
    // сабсеты раздзяляюцца кропкай з коскай. Апошні сабсэт у сьпісе
    // таксама закрываецца кропкай з коскай.
    // Прыклад:
    //   All;ByID;ByName;OnlySelected;
    class function GetSubSetList: String; virtual;

    // некоторые бизнес объекты требуют обязательного комита для
    // полного сохранения данных. Например, в объектах представляющих
    // метаданные реальное создание/изменение метаданных в базе
    // происходит по комиту. При загрузке таких объектов из потока
    // после поста каждой записи обязательно надо сделать комит.
    class function CommitRequired: Boolean; virtual;

    // для заданного алиаса поля (TField.FieldName) возвращает
    // имя таблицы
    function RelationByAliasName(const AnAliasName: String): String;

    // для заданного алиаса поля (TField.FieldName) возвращает
    // физическое имя поля в таблице
    function FieldNameByAliasName(const AnAliasName: String): String;

    // находит поле по имени таблицы и имени этого поля в таблице
    // (не алиасу, который может быть указан для поля в запросе!)
    // имя поля и имя таблицы передаются без кавычек
    // регистр не различается
    function FindField(ARelationName, AFieldName: String): TField; overload;
    function FieldByName(const ARelationName, AFieldName: String): TField; overload;

    //
    procedure AddToSelectedID(const AnID: Integer = -1); overload;
    procedure AddToSelectedID(ASelectedID: TgdKeyArray); overload;
    procedure RemoveFromSelectedID(const AnID: Integer = -1);

    // для вываду імя классу на экран
    //  property DisplayName: String read GetDisplayName;

    // пры вывадзе на экран дыялогаў і акон трэба ўказаць
    // бацькоўскі контрал (форму)
    // як правіла, ParentForm -- форма, на якой знаходзіцца
    // БА, вялікая форма для прагладу дадзеных БА
    property ParentForm: TWinControl read FParentForm;

    // заўважым што канцэпцыя ІД яшчэ да канца не распрацаваная...
    property ID: Integer read GetID write SetID;

    //
    property ObjectName: String read GetObjectName write SetObjectName;

    //
    property AggregatesActive: Boolean read FAggregatesActive write SetAggregatesActive;

    // количество детальных таблиц (детальных классов)
    // в связи мастер-детаил с данным классом
    property DetailClassesCount: Integer read GetDetailClassesCount;
    // список классов детальных классов
    property DetailClasses[Index: Integer]: CgdcBase read GetDetailClasses;

    // Количество детальных объектов, связанных с данным через
    // master-detail
    property DetailLinksCount: Integer read GetDetailLinksCount;
    // Указатель на один из списка детальных объектов
    property DetailLinks[Index: Integer]: TgdcBase read GetDetailLinks;

    //
    property EventList: TStringList read FEventList;

    property Params;
    property FindWhereSQL: String read FFindWhereSQL write SetFindWhereSQL;
    property gdcTableInfos: TgdcTableInfos read FgdcTableInfos;

    // Состояние объекта на данный момент
    property BaseState: TgdcStates read FBaseState;

    property SelectSQL;
    property GroupID: Integer read GetGroupID;

    // понадобилось Антону для обработки в окне поиска
    property HasWhereClause: Boolean read GetHasWhereClause;

    //
    property Filter: TgsQueryFilter read FFilter;

    // свойство определяет, что должно быть предпринято при редактировании
    // записи в диалоговом окне и выходе из него. см. комментарий к типу
    // TgsDialogAction. Данное свойство задействовано только если не
    // используются КэшедАпдэйтс.
    //property DialogActions: TgsDialogActions read FDialogActions write SetDialogActions
    //  default DefDialogActions;

    //
    property SubType: String read GetSubType write SetSubType;

    // Событие, которое вызывается после INITSQL и дает возможность изменить созданный запрос
    // пока находится в паблик части, если кому необходимо, в своем классе вынести в паблишед.
    property OnAfterInitSQL: TgdcAfterInitSQL read FAfterInitSQL write FAfterInitSQL;

    // на ўзроўні базавага класа падтрымліваецца інфармацыя аб стваральніку
    // даце і часу стварэньня аб'екту, рэдактары і даце і часу рэдактаваньня
    //
    // для гэтага галоўная табліца мусіць мець палі:
    //   creationdate dcreationdate
    //   creatorkey   dforeignkey
    // и/или
    //   editiondate  deditiondate
    //   editorkey    dforeignkey
    // запаўненьне гэтых палёў бярэ на сябе бізнэс-аб'ект
    // атрымаць доступ да іх можна праз адпаведныя ўласцівасці (гл. ніжэй)
    // альбо непасрэдна звяртаючыся да палёў аб'екта
    // ў апошнім выпадку папярждне трэба праверыць у gdcTableInfos
    // ці ёсць такія палі ў табліцы. Заўважым, што карыстацца FindField
    // недарэчна, бо яна можа выцягнуць поле не з галоўнай табліцы, а
    // з дапасаванай.
    // Асобная заўвага наконта індэксаў па гэтых палёх:
    // ствараць іх не рэкамендуецца, бо гэта замедліць аперацыі
    // устаўкі і абнаўленьня запісу. Гэта ж тычыцца знешняга ключа
    // па палям спасылкам.
    // Прагладзець інфармацыю можна ў стандартным акне Ўласцівасці аб'екту.
    property CreationDate: TDateTime read GetCreationDate;
    property CreatorKey: TID read GetCreatorKey;
    property CreatorName: String read GetCreatorName;
    property EditionDate: TDateTime read GetEditionDate;
    property EditorKey: TID read GetEditorKey;
    property EditorName: String read GetEditorName;

    // если установлено в Истину то после Поста или удаления записи
    // рефрешит мастер запись в мастер датасете (если такой есть)
    // по умолчанию отключено
    property RefreshMaster: Boolean read FRefreshMaster write FRefreshMaster;

    //
    property ExtraConditions: TStrings read GetExtraConditions;

    //
    property DSModified: Boolean read GetDSModified;

    //
    property SelectedID: TgdKeyArray read GetSelectedID write SetSelectedID;

    property SubSetCount: Integer read GetSubSetCount;
    property SubSets[Index: Integer]: TgdcSubSet read GetSubSets write SetSubSets;

    // Свойства для перекрытия методов
    // Для храниния Класс.Метод первого Делфи класса, из которого вызвана функция
    // используется, чтобы знать, когда обнулить стек LastCallClass
    property FunctionClassList: TClassListForMethod read FFunctionClassList write FFunctionClassList;
    // Стек вызова методов. В него заносится вся иерархия классов с подтипами объекта
    // Последний элемент в списке - последний обработанный класс с подтипом (или без),
    // т.е. по инхирит вызывается метод парента последнего элемента.
    property LastCallClass: TClassListForMethod read FLastCallClass write FLastCallClass;

    function HasSubSet(const ASubSet: TgdcSubSet): Boolean;
    procedure DeleteSubSet(const Index: Integer);
    procedure RemoveSubSet(const ASubSet: TgdcSubSet);
    procedure AddSubSet(const ASubSet: TgdcSubSet);
    procedure ClearSubSets;

    //
    procedure SetInclude(const AnID: TID);
    procedure SetExclude(const AnID: TID);

  published
    // наш механізм сувязі мастер-дзітэйл
    property MasterSource: TDataSource read GetMasterSource write SetMasterSource;
    property MasterField: String read GetMasterField write SetMasterField;
    property DetailField: String read GetDetailField write SetDetailField;

    // падмноства аб'ектаў з усёй сукупнасці аб'ектаў дадзенага тыпу
    // задаецца праз падмноства -- строкавы парамэтр
    // пры прысвайваньні датасэт заўсёды зачыняецца
    property SubSet: TgdcSubSet read GetSubSet write SetSubSet
      stored IsSubSetStored;

    // падмноства для вакна пошуку. Яно можа адрознівацца ад падмноства ў
    // аб'екце
    property SearchSubSet: TgdcSubSet read FSearchSubSet write SetSearchSubSet;

    //
    property SetTable: String read FSetTable write SetSetTable;

    // имя компоненты для использования в макросах
    property NameInScript: String read GetNameInScript write FNameInScript
      stored IsNameInScriptStored;

    // вызывается когда изменяется фильтр, ивент необходим, чтобы
    // можно было отобразить изменение фильтра на экране
    property OnFilterChanged: TNotifyEvent read FOnFilterChanged write FOnFilterChanged;

    // наследаваныя ўласцівасці
    property Active default False;
    property CachedUpdates;
    property Database stored False;

    //
    property ReadTransaction stored IsReadTransactionStored;
    property Transaction stored IsTransactionStored;

    // Событие вызывается перед открытием диалогового окна
    property BeforeShowDialog: TgdcDoBeforeShowDialog read FBeforeShowDialog write FBeforeShowDialog;
    // Событие вызывается после закрытия диалогового окна
    property AfterShowDialog: TgdcDoAfterShowDialog read FAfterShowDialog write FAfterShowDialog;

    //
    property Filtered;
    property OnFilterRecord;
  end;


  //
  EgdcBase = class(EIBError)
  private
    FIBError: Boolean;
    FIBErrorCode: Integer;
    FSQLCode: Integer;

  public
    constructor CreateObj(const AMessage: String; AnObj: TgdcBase); overload;
    constructor CreateObj(E: Exception; AnObj: TgdcBase); overload;

    property IBErrorCode: Integer read FIBErrorCode;
    property SQLCode: Integer read FSQLCode;
    property IBError: Boolean read FIBError;
  end;

  // используется для сигнализирования об ошибках,
  // произошедших в бизнес-объекте
  EgdcException = class(Exception);

  TScriptObjectList = class(TComponentList)
  private
    function GetItem(Index: Integer): TgdcBase;

  public
    constructor Create;

    function Add(AComponent: TgdcBase): Integer;
    function IndexByName(AName: String): Integer;

    property Items[Index: Integer]: TgdcBase read GetItem;
  end;

  TgdcDragObject = class(TDragObject)
  public
    BL: TBookmarkList;
    SourceControl: TWinControl;

    constructor Create(ASourceControl: TWinControl); reintroduce;
  end;

  TIBCustomDataSetCrack = class(TIBCustomDataSet);

  {
  Вместо кода:

    ...
    var
      DidActivate: Boolean;
    begin
      DidActivate := ActivateTransaction;
      try
        ...
        try
          ...
        except
          if DidActivate and Transaction.InTransaction then
            Transaction.Rollback;
          raise;
        end;
        ...
      finally
        if DidActivate and Transaction.InTransaction then
          Transaction.Commit;
      end;
    end

  Можно писать:

    ...
    var
      I: IgdcTransactionGuard;
    begin
      I := TgdcTransactionGuard.Create(Transaction);
      ...
      try
        ...
      except
        I.Action := taRollback;
        raise;
      end;
    end
  }

  IgdcTransactionGuard = interface
    function GetTransaction: TIBTransaction;
    function GetAction: TTransactionAction;
    procedure SetAction(AnAction: TTransactionAction);

    property Action: TTransactionAction read GetAction write SetAction;
    property Transaction: TIBTransaction read GetTransaction;
  end;

  TgdcTransactionGuard = class(TInterfacedObject, IgdcTransactionGuard)
  private
    FTransaction: TIBTransaction;
    FDidActivate: Boolean;
    FAction: TTransactionAction;

    function GetAction: TTransactionAction;
    procedure SetAction(AnAction: TTransactionAction);
    function GetTransaction: TIBTransaction;

  public
    constructor Create(ATransaction: TIBTransaction);
    destructor Destroy; override;

    property Action: TTransactionAction read GetAction write SetAction;
    property Transaction: TIBTransaction read GetTransaction;
  end;

  {
  Вместо кода:

    ...
    var
      DidActivate: Boolean;
      q: TIBSQL;
    begin
      q := TIBSQL.Create(nil);
      DidActivate := ActivateTransaction;
      try
        q.Transaction := Transaction;
        ...
        try
          ...
        except
          if DidActivate and Transaction.InTransaction then
            Transaction.Rollback;
          raise;
        end;
        ...
      finally
        q.Free;
        if DidActivate and Transaction.InTransaction then
          Transaction.Commit;
      end;
    end

  Можно писать:

    ...
    var
      I: IgdcQTransactionGuard;
    begin
      I := TgdcQTransactionGuard.Create(Transaction);
      ...
      try
        ...
      except
        I.Action := taRollback;
        raise;
      end;
    end

    к IBSQL мы обращаемся как I.q
  }

  IgdcQTransactionGuard = interface(IgdcTransactionGuard)
    function GetQ: TIBSQL;

    property q: TIBSQL read GetQ;
  end;

  TgdcQTransactionGuard = class(TgdcTransactionGuard, IgdcQTransactionGuard)
  private
    Fq: TIBSQL;

    function GetQ: TIBSQL;

  public
    constructor Create(ATransaction: TIBTransaction);
    destructor Destroy; override;

    property q: TIBSQL read GetQ;
  end;

var
  // мы регистрируем свой формат для передачи объектов через
  // клипбоард
  gdcClipboardFormat: Word;

const
  gdcClipboardFormatName: array[0..12] of Char = 'AndreiKireev'#00;
  gdcCurrentClipboardSignature = $56889103;
  gdcCurrentClipboardVersion = $00000001;

// возвращает наиболее абстрактный базовый класс для
// указанной таблицы, т.е. для GD_CONTACT вернет TgdcBaseContact,
// а не TgdcContact или TgdcContactList
function GetBaseClassForRelation(const ARelationName: String; aTransaction: TIBTransaction): TgdcFullClass;

// в функцию передается класс, она заполняет список классами, которые
// наследуются от заданного и возвращает Истину или Ложь, если
// наследников нет. Третий параметр определяет будут учитываться
// только непосредственные наследники или далекие родственники тоже.
function GetDescendants(AnAncestor: CgdcBase; AClassList: TClassList; const OnlyDirect: Boolean = True): Boolean;

//
function GetClassForObjectByID(ADatabase: TIBDatabase; ATransaction: TIBTransaction;
  AClass: CgdcBase; const ASubType: String; const AnID: Integer): CgdcBase;

//
procedure Register;

// helper function
function IndexOfStr(const S: String; const A: array of String): Integer;

//
function MakeFullClass(C: CgdcBase; const ASubType: TgdcSubType): TgdcFullClass;

implementation

{$R gdcClasses.dcr}

uses
  {Windows,}            IBTable,            DBClient,     gd_security,
  gdOperationInterface, gdJournalInterface, at_classes,   dialogs,
  gdc_frmG_unit,        ActiveX,
  rp_BaseReport_Unit,   IBQuery,            rp_dlgEnterParam_unit,
  Gedemin_TLB,          jclStrings,         gdcAttrUserDefined,
  IBErrorCodes,         evt_i_Base,         gdc_createable_form,
  TypInfo,

  {$IFDEF GEDEMIN}
{  gdcAutoBase,          obj_QueryList,      gsTextTemplate_unit,
  scrOpenSaveDialog_unit,                   obj_Gedemin,}
  {Storages,}
  {$ENDIF}

  gdc_dlgFind_unit,     comctrls,           gsDBDelete_dlgTableValues,
  rp_ReportServer,      gdc_dlgQueryDescendant_unit,
  gdc_dlgObjectProperties_unit,             gsDBReduction,
  gdc_dlgCantCreateObject_unit,             flt_sql_parser,
  gdcClasses,           gdc_dlgG_unit, gdcInvDocument_unit,
  gdcInvPriceList_unit,
  mtd_i_Inherited,      gdcOLEClassList,    prp_methods,
  gs_Exception,         gd_directories_const,Storages;

type
  TgdcReferenceUpdate = class(TObject)
  public
    C: CgdcBase;
    TableName: String;
    FieldName: String;
    KeyFieldName: String;
    ID: TID;
    RefID: TID;
  end;

procedure Register;
begin
  RegisterComponents('gdc', [TgdcBaseManager]);
end;

function IndexOfStr(const S: String; const A: array of String): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to High(A) do
    if S = A[I] then Result := I;
end;

function MakeFullClass(C: CgdcBase; const ASubType: TgdcSubType): TgdcFullClass;
begin
  Result.gdClass := C;
  Result.SubType := ASubType;
end;

function GetClassForObjectByID(ADatabase: TIBDatabase; ATransaction: TIBTransaction;
  AClass: CgdcBase; const ASubType: String; const AnID: Integer): CgdcBase;
var
  Obj: TgdcBase;
begin
  Result := nil;
  Obj := AClass.CreateSingularByID(nil,
    ADatabase, ATransaction,
    AnID, ASubType);
  try
    if Obj <> nil then
    begin
      { TODO : а сабтайп?? }
      Result := Obj.GetCurrRecordClass.gdClass;
    end;
  finally
    Obj.Free;
  end;
end;

function GetBaseClassForRelation(const ARelationName: String; aTransaction: TIBTransaction): TgdcFullClass;
const
  CacheRelationName: String = '';
  CacheClass: CgdcBase = nil;
  CacheSubType: TgdcSubType = '';
var
  I: Integer;
  C: CgdcBase;
  R: TatRelation;
  L: TObjectList;
  ibsql: TIBSQL;
begin
  Assert(ARelationName > '');

  if not Assigned(gdcClassList) then
    raise Exception.Create('gdClassList is not assigned');

  if ARelationName = CacheRelationName then
  begin
    Result.gdClass := CacheClass;
    Result.SubType := CacheSubType;
  end else if StrIPos(UserPrefix, ARelationName) = 1 then
  begin
    R := atDatabase.Relations.ByRelationName(ARelationName);
    if (R <> nil)
      and (R.PrimaryKey <> nil)
      and (R.PrimaryKey.ConstraintFields.Count = 1)
      and (AnsiCompareText(R.PrimaryKey.ConstraintFields[0].FieldName, 'DOCUMENTKEY') = 0) then
    begin
      { TODO : придумать как обрабатывать пользовательские документы }
      ibsql := TIBSQL.Create(nil);
      try
        ibsql.Transaction := aTransaction;
        ibsql.SQL.Text := 'select dt.id, dt1.ClassName, CAST(0 as INTEGER) as LineID from ' +
                     '  gd_documenttype dt LEFT JOIN gd_documenttype dt1 ON dt.parent = dt1.id ' +
                     '  where dt.headerrelkey = :id ' +
                     'UNION ' +
                     'select CAST(0 as INTEGER), dt1.ClassName, dt.id  from ' +
                     '  gd_documenttype dt LEFT JOIN gd_documenttype dt1 ON dt.parent = dt1.id ' +
                     '  where dt.linerelkey = :id ';
        ibsql.ParamByName('id').AsInteger := R.ID;
        ibsql.ExecQuery;
        if ibsql.RecordCount > 0 then
        begin
          if UpperCase(ibsql.FieldByName('ClassName').AsString) = 'TGDCUSERDOCUMENTTYPE' then
          begin
            if ibsql.FieldByName('id').AsInteger > 0 then
              Result.gdClass := TgdcUserDocument
            else
              Result.gdClass := TgdcUserDocumentLine;
          end
          else
            if UpperCase(ibsql.FieldByName('ClassName').AsString) = 'TGDCINVDOCUMENTTYPE' then
            begin
              if ibsql.FieldByName('id').AsInteger > 0 then
                Result.gdClass := TgdcInvDocument
              else
                Result.gdClass := TgdcInvDocumentLine;
            end
            else
              if UpperCase(ibsql.FieldByName('ClassName').AsString) = 'TGDCINVPRICELISTTYPE' then
              begin
                if ibsql.FieldByName('id').AsInteger > 0 then
                  Result.gdClass := TgdcInvPriceList
                else
                  Result.gdClass := TgdcInvPriceListLine;
              end;
          Result.SubType := IntToStr(ibsql.FieldByName('id').AsInteger + ibsql.FieldByName('LineID').AsInteger);
        end
        else
        begin
          Result.gdClass := TgdcUserDocument;
          Result.SubType := '';
        end;
      finally
        ibsql.Free;
      end;
    end else
    begin
      Result.gdClass := TgdcAttrUserDefined;
      Result.SubType := ARelationName;
    end;
  end else
  begin
    Result.gdClass := nil;
    Result.SubType := '';

    with gdcClassList do
      for I := 0 to Count - 1 do
      begin
        if Items[I].InheritsFrom(TgdcBase) then
        begin
          C := CgdcBase(Items[I]);

          { TODO 1 -oденис -cсделать : Сделать обработку подтипа }
          if (AnsiCompareText(C.GetListTable(''), ARelationName) = 0)
            {and (CgdcBase.ClassName = C.ClassParent.ClassName)} then
          begin
            if (Result.gdClass = nil) or Result.gdClass.InheritsFrom(C) then
              Result.gdClass := C;
          end;
        end;
      end;

    if Result.gdClass = nil then
    begin
      R := atDatabase.Relations.ByRelationName(ARelationName);
      if (R <> nil)
        and Assigned(R.PrimaryKey)
        and (R.PrimaryKey.ConstraintFields.Count = 1) then
      begin
        L := TObjectList.Create(False);
        try
          atDatabase.ForeignKeys.ConstraintsByRelation(ARelationName, L);
          for I := 0 to L.Count - 1 do
            with (L[I] as TatForeignKey) do
            begin
              if IsSimpleKey
                and (ConstraintField = R.PrimaryKey.ConstraintFields[0]) then
              begin
                Result := GetBaseClassForRelation(ReferencesRelation.RelationName, aTransaction);
                if Result.gdClass <> nil then
                  break;
              end;
            end;
        finally
          L.Free;
        end;
      end;
    end;
  end;

  if Result.gdClass <> nil then
  begin
    CacheClass := Result.gdClass;
    CacheSubType := Result.SubType;
    CacheRelationName := ARelationName;
  end;
end;

function GetDescendants(AnAncestor: CgdcBase; AClassList: TClassList; const OnlyDirect: Boolean = True): Boolean;
var
  I: Integer;
begin
  AClassList.Clear;
  if Assigned(gdcClassList) then
    for I := 0 to gdcClassList.Count - 1 do
      if (OnlyDirect and (gdcClassList[I].ClassParent = AnAncestor)) or
        ((not OnlyDirect) and (gdcClassList[I].InheritsFrom(AnAncestor))) then
        AClassList.Add(gdcClassList[I]);
  Result := AClassList.Count > 0;
end;

{ TODO : 
код этой функции очень не оптимален
переписать! }
procedure MakeFieldList(Fields: String; List: TStrings);
{var
  Z: Integer;}
begin
  List.CommaText := StringReplace(Fields, ';', ',', [rfReplaceAll]);
{  List.Clear;

  repeat
    Z := Pos(';', Fields);

    if Z > 0 then
    begin
      List.Add(Copy(Fields, 1, Z - 1));
      Fields := Copy(Fields, Z + 1, Length(Fields));
    end else

    if Fields > '' then
      List.Add(Fields);
  until Z = 0;}
end;

{ TgdcFindObject }

constructor TgdcFindObject.Create;
begin
  FID := '';
  FValues := TStringList.Create;
end;

constructor TgdcFindObject.Create(const AnID: String; const Names: String;
  const AnValues: TStringList);
begin
  FID := AnID;
  FValues := TStringList.Create;
  FValues.CommaText := Names;

  if AnValues <> nil then
    SetValues(AnValues);
end;

constructor TgdcFindObject.Create(const AnID: String; const Names: String);
begin
  Create(AnID, Names, nil);
end;

constructor TgdcFindObject.Create(const AnID: String);
begin
  Create(AnID, '', nil);
end;


destructor TgdcFindObject.Destroy;
begin
  FValues.Free;

  inherited Destroy;
end;

procedure TgdcFindObject.SetValues(const AnValues: TStringList);
var
  I: Integer;
begin
  if AnValues <> nil then
    for I := 0 to AnValues.Count - 1 do
      if I <= FValues.Count then
         FValues[I] := FValues.Names[I] + '=' + FValues[I];
end;

procedure TgdcFindObject.SetValues(const gdcBase: TgdcBase);
var
  S: TStringList;
  I: Integer;
  Field: TField;

begin
  Assert(gdcBase <> nil);

  S := TStringList.Create;
  try
    S.CommaText := gdcBase.GetFindFieldList;
    Values.Clear;
    for I := 0 to S.Count - 1 do
    begin
      Field := gdcBase.FindField(S[I]);
      if Field <> nil then
        Values.Add(S[I] + '=' + Field.AsString);
      ID := IntToStr(gdcBase.ID);
    end;
  finally
    S.Free;
  end;
end;


{ TgdcFindObjectList }

function TgdcFindObjectList.GetItem(Index: Integer): TgdcFindObject;
begin
  Result := TgdcFindObject(inherited GetItem(Index));
end;

destructor TgdcFindObjectList.Destroy;
begin
  FNames.Free;

  inherited Destroy;
end;

constructor TgdcFindObjectList.Create(const Names: String);
begin
  inherited;

  FNames := TStringList.Create;
  FNames.CommaText := Names;
end;

function TgdcFindObjectList.Add(const AnID: String; Values: TStringList): Integer;
var
  T: TgdcFindObject;
  I: Integer;
begin
  T := TgdcFindObject.Create(AnID);
  for I := 0 to FNames.Count - 1 do
    if I < Values.Count then
      T.Values.Add(FNames[I] + '=' + Values[I]);

  Result := inherited Add(T);
end;

{ TgdcBase }
// Events

procedure TgdcBase.DoAfterDelete;
  //q: TIBSQL;
  //DidActivate: Boolean;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOAFTERDELETE')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOAFTERDELETE');
  {M}      Index := LastCallClass.IndexOf('DOAFTERDELETE');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOAFTERDELETE', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOAFTERDELETE') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOAFTERDELETE');
  {M}    end;
  {END MACRO}

  FDSModified := True;

  // не замедлит ли это...
  { TODO : все равно это не поможет, если идет удаление каскадом... }
  (*
  DidActivate := False;
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := Transaction;

    DidActivate := ActivateTransaction;

    q.SQL.Text := 'DELETE FROM gd_ruid WHERE id=:ID';
    q.Prepare;
    q.Params[0].AsInteger := FDeletingID;
    try
      q.ExecQuery;
    except
      { TODO : пока не сапгрейдили все базы }
    end;
    FDeletingID := -1;
  finally
    if DidActivate then
      Transaction.Commit;

    q.Free;
  end;
  *)

  if FRefreshMaster and Assigned(FgdcDataLink) and FgdcDataLink.Active then
    FgdcDataLink.DataSet.Refresh;

  inherited;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTERDELETE')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOAFTERDELETE') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOAFTERDELETE'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOAFTERDELETE');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoAfterInsert;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOAFTERINSERT')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOAFTERINSERT');
  {M}      Index := LastCallClass.IndexOf('DOAFTERINSERT');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOAFTERINSERT', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOAFTERINSERT') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOAFTERINSERT');
  {M}    end;
  {END MACRO}

  if not FDataTransfer then
    inherited;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTERINSERT')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOAFTERINSERT') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOAFTERINSERT'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOAFTERINSERT');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoAfterOpen;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOAFTEROPEN')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOAFTEROPEN');
  {M}      Index := LastCallClass.IndexOf('DOAFTEROPEN');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOAFTEROPEN', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOAFTEROPEN') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOAFTEROPEN');
  {M}    end;
  {END MACRO}

  inherited DoAfterOpen;

  if Assigned(EventControl) then
    EventControl.SetChildEvents(Self);

  if not (csDesigning in ComponentState) then
    SetDefaultFields(False);

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTEROPEN')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOAFTEROPEN') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOAFTEROPEN'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOAFTEROPEN');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoAfterPost;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOAFTERPOST')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOAFTERPOST');
  {M}      Index := LastCallClass.IndexOf('DOAFTERPOST');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOAFTERPOST', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOAFTERPOST') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOAFTERPOST');
  {M}    end;
  {END MACRO}

  if FDataTransfer then
    exit;

  inherited;

  // проблема:
  // если открывается пустой датасет, для которого
  // устанавливается подмножество ПоИдентификатору
  // и в него добавляется запись, то, после закрытия-открытия,
  // эта запись не будет видна, поскольку не инициализируется
  // параметр ИД (селект СКЛ имеет вид: SELECT * FROM ... WHERE id=:ID).
  // мы добавили инициализацию этого параметра в АфтерПост
  if HasSubSet('ByID') then
  begin
    FID := ID;
    ParamByName(GetKeyField(SubType)).AsInteger := FID;
  end else
  if HasSubSet('ByName') then
  begin
    FObjectName := ObjectName;
    ParamByName(GetListField(SubType)).AsString := FObjectName;
  end;

  //
  if FRefreshMaster and Assigned(FgdcDataLink) and FgdcDataLink.Active then
    FgdcDataLink.DataSet.Refresh;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOAFTERPOST')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOAFTERPOST') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOAFTERPOST'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOAFTERPOST');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoBeforeClose;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFORECLOSE')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOBEFORECLOSE');
  {M}      Index := LastCallClass.IndexOf('DOBEFORECLOSE');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOBEFORECLOSE', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOBEFORECLOSE') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOBEFORECLOSE');
  {M}    end;
  {END MACRO}

  inherited;

  if Assigned(EventControl) then
    EventControl.ResetChildEvents(Self);

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFORECLOSE')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOBEFORECLOSE') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOBEFORECLOSE'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOBEFORECLOSE');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoBeforeDelete;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFOREDELETE')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOBEFOREDELETE');
  {M}      Index := LastCallClass.IndexOf('DOBEFOREDELETE');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOBEFOREDELETE', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOBEFOREDELETE') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOBEFOREDELETE');
  {M}    end;
  {END MACRO}

  inherited;
  FDeletingID := ID;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFOREDELETE')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOBEFOREDELETE') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOBEFOREDELETE'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOBEFOREDELETE');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoBeforeEdit;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFOREEDIT')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOBEFOREEDIT');
  {M}      Index := LastCallClass.IndexOf('DOBEFOREEDIT');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOBEFOREEDIT', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOBEFOREEDIT') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOBEFOREEDIT');
  {M}    end;
  {END MACRO}

  inherited;
  FOldValues.Clear;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFOREEDIT')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOBEFOREEDIT') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOBEFOREEDIT'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOBEFOREEDIT');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.DoBeforeInsert;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFOREINSERT')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOBEFOREINSERT');
  {M}      Index := LastCallClass.IndexOf('DOBEFOREINSERT');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOBEFOREINSERT', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOBEFOREINSERT') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOBEFOREINSERT');
  {M}    end;
  {END MACRO}

  if not FDataTransfer then
    inherited;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFOREINSERT')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOBEFOREINSERT') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOBEFOREINSERT'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOBEFOREINSERT');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

(*

  Перед сохранением записи синхронизируем значения дескрипторов
  безопасности. Распространим более сильные права на менее сильные.

*)
procedure TgdcBase.DoBeforePost;
var
  {@UNFOLD MACRO INH_ORIG_PARAMS()}
  {M}
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
  F: TField;
  AFull, AChag, AView, I: Integer;
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOBEFOREPOST')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOBEFOREPOST');
  {M}      Index := LastCallClass.IndexOf('DOBEFOREPOST');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOBEFOREPOST', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOBEFOREPOST') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOBEFOREPOST');
  {M}    end;
  {END MACRO}

  if FDataTransfer then
    exit;

  if tiEditionInfo in gdcTableInfos then
  begin
    FieldByName('EDITORKEY').AsInteger := IBLogin.ContactKey;
    FieldByName('EDITIONDATE').AsDateTime := Now;
  end;

{ TODO : а если у главной таблицы нет дескрипторов, а у присоединенной есть? }
  F := FindField('afull');

  if (F <> nil) then
  begin
    AFull := F.AsInteger or 1;
    if AFull <> F.AsInteger then
      F.AsInteger := AFull;
  end;

  if (F <> nil) and (FindField('achag') <> nil) then
  begin
    AChag := FieldByName('achag').AsInteger or F.AsInteger;
    if AChag <> FieldByName('achag').AsInteger then
      FieldByName('achag').AsInteger := AChag;
  end;

  if FindField('AChag') <> nil then
    F := FindField('AChag');

  if (F <> nil) and (FindField('AView') <> nil) then
  begin
    AView := FieldByName('AView').AsInteger or F.AsInteger;
    if AView <> FieldByName('AView').AsInteger then
      FieldByName('AView').AsInteger := AView;
  end;

  for I := 0 to FieldCount - 1 do
    ValidateField(Fields[I]);

  inherited DoBeforePost;

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOBEFOREPOST')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOBEFOREPOST') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOBEFOREPOST'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOBEFOREPOST');
  {M}    end;
  {M}  end;
  {END MACRO}
end;
(*
var
  F: TField;
  AFull, AChag, AView, I: Integer;
begin
  if FDataTransfer then
    exit;

  if tiEditionInfo in gdcTableInfos then
  begin
    FieldByName('EDITORKEY').AsInteger := IBLogin.ContactKey;
    FieldByName('EDITIONDATE').AsDateTime := Now;
  end;

{ TODO : а если у главной таблицы нет дескрипторов, а у присоединенной есть? }
  F := FindField('afull');

  if (F <> nil) then
  begin
    AFull := F.AsInteger or 1;
    if AFull <> F.AsInteger then
      F.AsInteger := AFull;
  end;

  if (F <> nil) and (FindField('achag') <> nil) then
  begin
    AChag := FieldByName('achag').AsInteger or F.AsInteger;
    if AChag <> FieldByName('achag').AsInteger then
      FieldByName('achag').AsInteger := AChag;
  end;

  if FindField('AChag') <> nil then
    F := FindField('AChag');

  if (F <> nil) and (FindField('AView') <> nil) then
  begin
    AView := FieldByName('AView').AsInteger or F.AsInteger;
    if AView <> FieldByName('AView').AsInteger then
      FieldByName('AView').AsInteger := AView;
  end;

  for I := 0 to FieldCount - 1 do
    ValidateField(Fields[I]);

  inherited DoBeforePost;
end;
*)
// End Event

function TgdcBase.AcceptClipboard(CD: PgdcClipboardData): Boolean;
(*
var
  I, K: Integer;
  Bm: TBookmarkStr;
  C: TPersistentClass;
  Obj: TgdcBase;
*)
begin
  Result := False;

  // может нам передали плохой указатель?
  // тогда выходим
(*
  if gdcObjectList.IndexOf(CD^.Obj) = -1 then exit;

  if CD^.ClassName = Self.ClassName then
  begin
    Bm := Bookmark;
    DisableControls;
    try
      for I := 0 to CD^.IDCount - 1 do
      begin
        K := CD^.ID[I];
        if CD^.Cut then
          AssignField(K, GetCopyFieldName, GetCopyValue)
        else
        begin
          C := FindClass(CD.ClassName);
          if C.InheritsFrom(TgdcBase) then
            Obj := CgdcBase(C).CreateSingularByID(nil,
              Self.Database, Self.Transaction, K)
          else
            Obj := nil;
          try
            if Obj <> nil then
              Obj.Copy(GetCopyFieldName, GetCopyValue, True);
          finally
            Obj.Free;
          end;
        end;
      end;
      Result := True;
    finally
      Bookmark := Bm;
      EnableControls;
    end;
  end;
*)  
end;

procedure TgdcBase.AfterConstruction;
begin
  inherited AfterConstruction;

  if gdcBaseManager <> nil then
  begin
    if Transaction = nil then
    begin
      FInternalTransaction := TIBTransaction.Create(Self);
      FInternalTransaction.Params.Text := 'read_committed'#13#10'rec_version'#13#10'nowait'#13#10;
      FInternalTransaction.Name := 'Internal';
      FInternalTransaction.AutoStopAction := saNone;
      Transaction := FInternalTransaction;
    end;

    if gdcBaseManager.ReadTransaction <> nil then
    begin
      ReadTransaction := gdcBaseManager.ReadTransaction;

// Проверка на то что Owner is TgdcBase добавлена потому, что
// когда идет FreeNotification, то он проверяет саму компоненту и все, которые
// к ней относятся и если там есть, кто-то кто отвечает условию, он  для него то же делает
// FreeNotification, однако он освобождается из списка, но начальная проверка его не знает,
// после чего происходит ошибка.

      if not (Owner is TgdcBase) then
        ReadTransaction.FreeNotification(Self);
    end;

    if Database = nil then
      Database := gdcBaseManager.Database;

    if Transaction.DefaultDatabase <> Database then
      Transaction.DefaultDatabase := Database;
  end;

  //FIBSQL := TIBSQL.Create(Self);
  //SetIBSQL;

  //InitSQL;
end;

function TgdcBase.GetCopyFieldName: String;
begin
  Result := '';
end;

function TgdcBase.GetCopyValue: Variant;
begin
  Result := Self.ID;
end;

procedure TgdcBase.AssignField(const AnID: Integer;
  const AFieldName: String; AValue: Variant);
var
  Q: TIBSQL;
  Obj: TgdcBase;
  C: TClass;
  DidActivate: Boolean;
begin
  if Active then
  begin
    C := GetCurrRecordClass.gdClass;
    Obj := CgdcBase(C).CreateWithID(Owner, Database, Transaction, AnID);
    try
      Obj.Assign(Self);
      Obj.Open;
      if Obj.RecordCount > 0 then
      begin
        Obj.Edit;
        if VarIsNull(AValue) then
          Obj.FieldByName(AFieldName).Clear
        else
          Obj.FieldByName(AFieldName).AsVariant := AValue;
        Obj.Post;
        { TODO : то есть мы не уверены активна тр или нет?? }
        if Transaction.InTransaction then
          Transaction.CommitRetaining;
      end;
    finally
      Obj.Free;
    end;
  end else
  begin
    DidActivate := False;
    Q := TIBSQL.Create(nil);
    try
      Q.Database := Database;
      Q.Transaction := Transaction;
      DidActivate := ActivateTransaction;
      Q.SQL.Text := Format('UPDATE %s SET %s=:V WHERE %s=%d', [GetListTable(SubType), AFieldName, GetKeyField(SubType), AnID]);
      Q.Prepare;
      if VarIsNull(AValue) then
        Q.ParamByName('V').Clear
      else
        Q.ParamByName('V').AsVariant := AValue;

      Q.ExecQuery;
    finally
      if DidActivate then
        Transaction.Commit;
      Q.Free;
    end;
  end;
end;

function TgdcBase.CanPasteFromClipboard: Boolean;
begin
  // в макросах датасет почти всегда прибывает в состоянии
  // редактирования
  Result := {(State = dsBrowse)
    and }Clipboard.HasFormat(gdcClipboardFormat)
    and TestRightForOp([opCreate, opChange]);
end;

procedure TgdcBase.CloseOpen;
var
  OldID: TID;
begin
  { TODO : 
если делать дизэйбл контролс, то в гриде остается выделение
записей, если там был мульти селект }
  //DisableControls;
  try
    if Active and not IsEmpty then
      OldID := ID
    else
      OldID := -1;
    Close;
    Open;
    if OldID <> -1 then
      Locate(GetKeyField(SubType), OldID, []);
  finally
    //EnableControls;
  end;
end;

{procedure TgdcBase.Commit(const AType: TgsCommitType);
begin
  _CommitRollback(True, AType);
end;}

function TgdcBase.GetNotCopyField: String;
  {@CALL MACRO INH_PARAMS (var)}
begin
  {@CALL MACRO INH_BODY(GDC_BASE, GDC_GETNOTCOPYFIELD)}

  Result := GetKeyField(SubType);

  {@CALL MACRO INH_FINALLY(GDC_BASE, GDC_GETNOTCOPYFIELD)}
end;

function TgdcBase.TestCopyField(const FieldName: String): Boolean;
begin
  Result := StrIPos(FieldName + ',', GetNotCopyField + ',') = 0;
end;

function TgdcBase.Copy(const AFields: String; AValues: Variant;
  const ACopyDetail: Boolean = False; const APost: Boolean = True): Boolean;
var
  V: array of Variant;
  I: Integer;
  L: TList;
  C: TClass;
  Obj: TgdcBase;
begin
  CheckBrowseMode;

  if GetCurrRecordClass.gdClass = Self.ClassType then
  begin

    // список значений полей должен быть обязательно массивом
    if (AFields > '') and (not VarIsArray(AValues)) then
      AValues := VarArrayOf([AValues]);

    // сохраним значения текущей записи
    SetLength(V, FieldCount);
    for I := 0 to FieldCount - 1 do
      V[I] := Fields[I].AsVariant;

    // добавим новую и скопируем в нее значения полей
    // исходной записи, кроме первичного ключа
    // и полей, для которых заданы другие значения
    L := TList.Create;
    try
      GetFieldList(L, AFields);
      Insert;
      for I := 0 to FieldCount - 1 do
        if L.IndexOf(Fields[I]) >= 0 then
          Fields[I].AsVariant := AValues[L.IndexOf(Fields[I])]
        else
          if TestCopyField(Fields[I].FieldName) and (not Fields[I].ReadOnly) then
            Fields[I].AsVariant := V[I];
      if APost then
        Post;
    finally
      L.Free;
    end;

    Result := True;
  end
  else
  begin
    C := GetCurrRecordClass.gdClass;
    Obj := CgdcBase(C).CreateWithID(Owner, Database, Transaction, ID);
    try
      Obj.Open;
      Result := Obj.Copy(AFields, AValues, ACopyDetail, APost);
{ TODO : а рефреш датасета? }      
    finally
      Obj.Free;
    end;
  end;
end;

procedure TgdcBase.CopyDetailTable(const AMasterTableName: String;
  const AnOldID, ANewID: Integer);
var
  q: TIBSQL;
  ibtS: TIBQuery;
  ibtD: TIBTable;
  I: Integer;
  DidActivate: Boolean;
begin
  DidActivate := False;
  q := TIBSQL.Create(Self);
  ibtS := TIBQuery.Create(Self);
  ibtD := TIBTable.Create(Self);
  try
    q.Database := Database;
    q.Transaction := Transaction;

    ibtS.Database := Database;
    ibtS.Transaction := Transaction;
    ibtS.Unidirectional := True;

    ibtD.Database := Database;
    ibtD.Transaction := Transaction;
    ibtD.Unidirectional := True;

    DidActivate := ActivateTransaction;

    // обрабатываем только случай с целочисленным ключем
    // получаем список ссылающихся таблиц, имя поля
    // фореин кея (поля-ссылки на главную таблицу), имя
    // поля первичного ключа в главной таблице
    q.SQL.Text :=
      'SELECT rc2.rdb$relation_name, is1.rdb$field_name, is2.rdb$field_name ' +
      'FROM ' +
      '  rdb$relation_constraints rc ' +
      '  JOIN rdb$ref_constraints rf ' +
      '    ON rc.rdb$constraint_name = rf.rdb$const_name_uq ' +
      '    AND rc.rdb$relation_name = :RN AND rc.rdb$constraint_type = ''PRIMARY KEY'' ' +
      '  JOIN rdb$relation_constraints rc2 ' +
      '    ON rc2.rdb$constraint_name = rf.rdb$constraint_name ' +
      '    AND rc2.rdb$constraint_type = ''FOREIGN KEY'' ' +
      '  JOIN rdb$indices ri ' +
      '    ON ri.rdb$index_name = rc2.rdb$index_name ' +
      '  JOIN rdb$index_segments is1 ' +
      '    ON is1.rdb$index_name = ri.rdb$index_name ' +
      '  JOIN rdb$indices ri2 ' +
      '    ON ri2.rdb$index_name = rc.rdb$index_name ' +
      '  JOIN rdb$index_segments is2 ' +
      '    ON is2.rdb$index_name = ri2.rdb$index_name ' +
      ' ';
    q.Prepare;
    q.ParamByName('RN').AsString := GetListTable(SubType);
    q.ExecQuery;

    while not q.EOF do
    begin
{      ibtS.TableName := q.Fields[0].AsString;
      ibtS.Filter := Format('%s=%d', [q.Fields[1].AsString, AnOldID]);
      ibtS.Open;
      ibtS.Filtered := True;}
      ibtS.SQL.Text := Format('SELECT * FROM %s WHERE %s=%d',
        [q.Fields[0].AsString, q.Fields[1].AsString, AnOldID]);
      ibtS.Open;

      ibtD.TableName := q.Fields[0].AsString;
      ibtD.Open;

      ibtS.First;
      while not ibtS.EOF do
      begin
        ibtD.Insert;

        for I := 0 to ibtS.FieldCount - 1 do
          if AnsiCompareText(ibtS.Fields[I].FieldName, Trim(q.Fields[1].AsString)) = 0 then
            ibtD.FieldByName(ibtS.Fields[I].FieldName).AsInteger := ANewID
          else if AnsiCompareText(ibtS.Fields[I].FieldName, Trim(q.Fields[2].AsString)) = 0 then
            ibtD.FieldByName(ibtS.Fields[I].FieldName).Clear
          else if (not ((db.faReadOnly in ibtD.FieldDefList[I].Attributes) and (ibtD.FieldDefList[I].InternalCalcField = True))) then
            ibtD.FieldByName(ibtS.Fields[I].FieldName).Assign(ibtS.Fields[I]);

        ibtD.Post;
        ibtS.Next;
      end;
      ibtS.Close;
      ibtD.Close;

      q.Next;
    end;

    q.Close;
  finally
    if DidActivate then
      Transaction.Commit;

    q.Free;
    ibtS.Free;
    ibtD.Free;
  end;
end;

function TgdcBase.CopyDialog: Boolean;
var
  Bm: String;
  C: TClass;
  Obj: TgdcBase;
begin
  if GetCurrRecordClass.gdClass = Self.ClassType then
  begin
    Bm := Bookmark;
    Result := Copy('', Null, True, False) and EditDialog;
    if not Result then
      if BookmarkValid(Pointer(Bm)) then
        Bookmark := Bm;
  end
  else
  begin
    C := GetCurrRecordClass.gdClass;
    Obj := CgdcBase(C).CreateWithID(Owner, Database, Transaction, ID);
    try
      Obj.Open;
      Result := Obj.CopyDialog;
      if Result then Refresh;
    finally
      Obj.Free;
    end;
  end;
end;

procedure TgdcBase.CopyToClipboard(BL: TBookmarkList; const ACut: Boolean = False);
var
  H: THandle;
  P: PgdcClipboardData;
  I, IC: Integer;
  Bm: String;
begin
  CheckActive;
  if (BL = nil) or (BL.Count = 0) then IC := 1 else
    IC := BL.Count;
  H := GlobalAlloc(GMEM_MOVEABLE or GMEM_DDESHARE,
    SizeOf(TgdcClipboardData) -
    SizeOf(TIDArr) + IC * SizeOf(TID) -
    SizeOf(TObjectNameArr) + IC * SizeOf(TObjectNameChar));
  if H <> 0 then
  begin
    P := GlobalLock(H);
    if P <> nil then
    begin
      P^.Signature := gdcCurrentClipboardSignature;
      P^.Version := gdcCurrentClipboardVersion;
      StrPCopy(P^.ClassName, System.Copy(Self.ClassName, 1, 47));
      P^.Obj := Self;
      P^.Cut := ACut;
      P^.IDCount := IC;
      if (BL = nil) or (BL.Count = 0) then
      begin
        P^.ID[0] := Self.ID;
        StrPLCopy(P^.ObjectName[0], Self.ObjectName, 63);
      end else begin
        DisableControls;
        try
          BL.Refresh;
          Bm := Bookmark;
          for I := 0 to BL.Count - 1 do
          begin
            Bookmark := BL[I];
            P^.ID[I] := Self.ID;
            StrPLCopy(P^.ObjectName[I], Self.ObjectName, 63);
          end;
          Bookmark := Bm;
        finally
          EnableControls;
        end;
      end;
      GlobalUnlock(H);
      Clipboard.SetAsHandle(gdcClipboardFormat, H);
    end;
  end;
end;

constructor TgdcBase.Create(AnOwner: TComponent);
begin
  inherited Create(AnOwner);

  FAfterInitSQL := nil;
  FSQLInitialized := False;
  FGetDialogDefaultsFieldsCached := False;
  FSavedParams := TObjectList.Create(True);
  FRefreshMaster := False;

  FSubSets := TStringList.Create;
  FSubSets.Sorted := False;
  FSubSets.Duplicates := dupError;
  FSubSets.Add('All');

  FBaseState := [];
  FID := -1;
  FObjectName := '';
  FSQLSetup := nil;
  FExtraConditions := TStringList.Create;
  FExtraConditions.OnChange := DoAfterExtraChanged;
  FDSModified := False;
  FDlgStack := TObjectStack.Create;
  FDeletingID := -1;

  FFilter := nil;

  FBeforeShowDialog := nil;
  FAfterShowDialog := nil;

{ TODO :
этого не должно быть! кастом процесс динамическое значение
и не должно нигде хранится!

очевидно, схему придется изменить. Должны быть три переменных
процедурного типа. которые должны хранить адреса процедур для
кастом процессов. Тогда кастом процесса не понадобится.
}
  FCustomProcess := [];
  //FDialogActions := DefDialogActions;
  FgdcDataLink := TgdcDataLink.Create(Self);
  FDetailLinks := TObjectList.Create(False);

  if AnOwner is TWinControl then
  begin
    FParentForm := AnOwner as TWinControl;

    if FParentForm is Tgdc_frmG then
      Include(FBaseState, sView);
  end else
    FParentForm := nil;

  FSubType := '';

  gdcObjectList.Add(Self);

  FNameInScript := '';
  FEventList := TStringList.Create;
  LoadEventList;

  FSelectedID := TgdKeyArray.Create;

  FOldValues := TObjectList.Create(True);

  FgdcTableInfos := GetTableInfos(FSubType);

  FFunctionClassList :=  TClassListForMethod.Create;
  FLastCallClass := TClassListForMethod.Create;
  FMethodWithInherited := TStringList.Create;

  if Assigned(InheritedMethodInvoker) then
      InheritedMethodInvoker.RegisterMethodInvoker(Self, OnInvoker);
end;

procedure TgdcBase.Prepare;
begin
  InternalPrepare;
end;

function TgdcBase.CreateDialog(const ADlgClassName: String = ''): Boolean;
var
  DlgForm: TCreateableForm;
  InTransaction: Boolean;
  C: TClass;
  FormClass: String;
begin
  DlgForm := nil;
  if ADlgClassName <> '' then
  begin
    if Assigned(GlobalStorage) then
    begin
      FormClass := GlobalStorage.ReadString(st_ds_NewFormPath + '\' + ADlgClassName, st_ds_FormClass);
      if FormClass <> '' then
      begin
        C := GetClass(FormClass);
        if Assigned(C) then
        begin
          DlgForm := CCreateableForm(C).CreateUser(FParentForm, ADlgClassName)
        end;
      end;
    end;
  end;
  if DlgForm = nil then
    DlgForm := CreateDialogForm;

  if not Assigned(DlgForm) then
  begin
    Result := False;
    exit;
  end;

  if not (DlgForm is Tgdc_dlgG) then
  begin
    DlgForm.Free;
    Result := False;
    exit;
  end;

  with DlgForm as Tgdc_dlgG do
  try
    InTransaction := Transaction.InTransaction;

    FDlgStack.Push(DlgForm);

    if not Active then
      Open;

    if Self.State <> dsInsert then
      Self.Insert;

    if sDialog in FBaseState then
    begin
      Include(FBaseState, sSubDialog);
    end else
      Include(FBaseState, sDialog);

    LoadDialogDefaults;

    Setup(Self);

    DoBeforeShowDialog(DlgForm);
    Result := (ShowModal = mrOk) or MultipleCreated;
    DoAfterShowDialog(DlgForm, Result);

    if ModalResult = mrOk then
      SaveDialogDefaults;

    if not (sSubDialog in FBaseState) then
    begin
      if Self.State in dsEditModes then
        if ModalResult = mrOk then Self.Post else Self.Cancel;

      if (not InTransaction) and Transaction.InTransaction then
      begin
        if Result then
          Transaction.Commit
        else
          Transaction.Rollback;

        {$IFDEF DEBUG}
        OutputDebugString('Окно не закрыло транзакцию');
        {$ENDIF}
      end;
    end;
  finally
    if sSubDialog in FBaseState then
    begin
      Exclude(FBaseState, sSubDialog);
    end else
      Exclude(FBaseState, sDialog);

    FDlgStack.Pop;

    Free;
  end;
end;

function TgdcBase.CreateDialogForm: TCreateableForm;
begin
  Result := CCreateableForm(FindClass('Tgdc_dlgObjectProperties')).Create(FParentForm);
end;

function TgdcBase.CreateNext: Boolean;
begin
  CheckActive;
  if State in dsEditModes then
    Post;
  if [sDialog, sSubDialog] * BaseState = [sDialog] then
  begin
    SaveDialogDefaults;
    Insert;
    LoadDialogDefaults;
  end else
    Insert;
  Result := True;
end;

class function TgdcBase.CreateSingularByID(AnOwner: TComponent;
  ADatabase: TIBDatabase; ATransaction: TIBTransaction;
  const AnID: TID; const ASubType: String = ''): TgdcBase;
begin
  Result := Self.CreateWithID(AnOwner, ADatabase, ATransaction, AnID, ASubType);
  Result.Open;
  Result.Next;
  if Result.RecordCount <> 1 then
  begin
    Result.Free;
    raise EgdcBase.Create(Self.ClassName + ': ID not found (' + IntToStr(AnID) + ')');
  end else
    Result.First;
end;

constructor TgdcBase.CreateWithID;
begin
  CreateSubType(AnOwner, ASubType);
  inherited Database := ADatabase;
  inherited Transaction := ATransaction;
  UniDirectional := True;
  FID := AnID;
  SubSet := 'ByID';
end;

constructor TgdcBase.CreateWithParams(AnOwner: TComponent;
  ADatabase: TIBDatabase; ATransaction: TIBTransaction;
  const ASubType: TgdcSubType = ''; const ASubSet: TgdcSubSet = 'All');
begin
  CreateSubType(AnOwner, ASubType, ASubSet);
  inherited Database := ADatabase;
  inherited Transaction := ATransaction;
end;

procedure TgdcBase.CustomExecQuery(const ASQL: String; Buff: Pointer);
var
  S: String;
  DidActivate: Boolean;
begin
  if not Assigned(FExecQuery) then
    FExecQuery := TIBSQL.Create(nil);

  if FExecQuery.Transaction <> Transaction then
    FExecQuery.Transaction := Transaction;

  if FExecQuery.Database <> Database then
    FExecQuery.Database := Database;

  with TatSQLSetup.Create(nil) do
  try
    S := PrepareSQL(ASQL, Self.ClassName + '(' + Self.SubType + ')');
    if FExecQuery.SQL.Text <> S then
      FExecQuery.SQL.Text := S;
  finally
    Free;
  end;

  DidActivate := False;
  try
    DidActivate := ActivateTransaction;

    FExecQuery.Prepare;
    SetInternalSQLParams(FExecQuery, Buff);
    FExecQuery.ExecQuery;
  finally
    if DidActivate then
      Transaction.Commit;
  end;
end;

function TgdcBase.DeleteMultiple(BL: TBookmarkList): Boolean;
var
  I: Integer;
  S: String;
  Prev: TgdcFullClass;
begin
  Result := False;
  if (BL = nil) or (BL.Count <= 1) then
  begin
    if (RecordCount > 0) and
       (
         (not (sView in BaseState)) or
         (MessageBox(ParentHandle, PChar(Format('Удалить выделенную запись "%s"?', [ObjectName])), 'Внимание!', MB_YESNO + MB_ICONQUESTION) = IDYES)
       ) then
    begin
      Result := DeleteRecord;
    end;
  end
  else
    if (not (sView in BaseState)) or (MessageBox(ParentHandle,
          PChar(Format('Выделено записей: %d'#13#10'Удалить?', [BL.Count])),
          'Внимание!',
          MB_YESNO + MB_ICONQUESTION) = IDYES) then
    begin
      DisableControls;
      try
        S := '';

        if (not (cpDelete in CustomProcess)) then
        begin
          for I := 0 to BL.Count - 1 do
          begin
            if Length(S) > 30000 then break;
            Bookmark := BL[I];
            if I = 0 then
              Prev := GetCurrRecordClass
            else if (Prev.gdClass <> GetCurrRecordClass.gdClass) or (Prev.SubType <> GetCurrRecordClass.SubType) then
            begin
              S := '';
              break;
            end;
            S := S + FieldByName(GetKeyField(SubType)).AsString + ',';
          end;
          SetLength(S, Length(S) - 1);
        end;

        if (cpDelete in CustomProcess) or (S = '') then
        begin
          for I := 0 to BL.Count - 1 do
          begin
            Bookmark := BL[I];
            if DeleteRecord then
              Result := True;
          end;
        end else
        begin
          try
            ExecSingleQuery(Format('DELETE FROM %s WHERE %s IN (%s)',
              [GetListTable(SubType), GetKeyField(SubType), S]));
            try
              ExecSingleQuery(Format('DELETE FROM gd_ruid WHERE id IN (%s)',
                [S]));
            except
              { TODO : пока не сапгрейдили все базы }
            end;

            FDataTransfer := True;
            try
              for I := 0 to BL.Count - 1 do
              begin
                Bookmark := BL[I];
                Delete;
              end;
            finally
              FDataTransfer := False;
            end;

            Result := True;
          except
            on E: Exception do
            begin
              if not (E is EAbort) then
                MessageBox(ParentHandle,
                  'При удалении группы записей произошла ошибка. Попробуйте удалять записи по одной.',
                  'Ошибка',
                  MB_OK or MB_ICONHAND);
              Result := False;
            end;
          end;

        end;
      finally
        EnableControls;
      end;
    end;
end;

destructor TgdcBase.Destroy;
begin
  if Assigned(InheritedMethodInvoker) then
      InheritedMethodInvoker.UnRegisterMethodInvoker(Self);

  FreeAndNil(FInternalTransaction);

  FreeAndNil(FDetailLinks);
  if (FgdcDataLink <> nil) and (FgdcDataLink.DataSet is TgdcBase) then
    (FgdcDataLink.DataSet as TgdcBase).RemoveDetailLink(Self);
  FreeAndNil(FgdcDataLink);
  gdcObjectList.Extract(Self);
  FEventList.Free;
  FpmReport.Free;
  if Assigned(FFilter) then
    FreeAndNil(FFilter);
  //FIBSQL.Free;
  FOldValues.Free;
  FExecQuery.Free;
  FExtraConditions.Free;
  FSelectedID.Free;
  FSavedParams.Free;
  FreeAndNil(FSubSets);

  FreeAndNil(FSQLSetup);

  inherited Destroy;

  FFunctionClassList.Free;
  FLastCallClass.Free;
  FMethodWithInherited.Free;

end;

procedure TgdcBase.MakeReportMenu;
var
  IBSQL: TIBSQL;
  MenuItem: TMenuItem;
  DidActivate: Boolean;
begin
//  if FpmReport <> nil then exit;
//При изменении отчетов, добавлении или удалении необходимо перечитывать меню
  if FpmReport <> nil then
  begin
    FpmReport.Free;
    FpmReport := nil;
  end;

  FpmReport := TPopupMenu.Create(Self);
  FpmReport.AutoLineReduction := Menus.maAutomatic;

  DidActivate := False;
  IBSQL := TIBSQL.Create(Self);
  try
    IBSQL.Database := DataBase;
    IBSQL.Transaction := ReadTransaction;
    DidActivate := ActivateReadTransaction;

  {$IFDEF DEPARTMENT}
    if IBLogin.IsUserAdmin then
    begin
      MenuItem := TMenuItem.Create(FpmReport);
      MenuItem.Caption := cst_Reportregistrylist;
      MenuItem.OnClick := DoOnReportListClick;
      FpmReport.Items.Add(MenuItem);

      MenuItem := TMenuItem.Create(FpmReport);
      MenuItem.Caption := '-';
      FpmReport.Items.Add(MenuItem);
    end;
   {$ELSE}
      MenuItem := TMenuItem.Create(FpmReport);
      MenuItem.Caption := cst_Reportregistrylist;
      MenuItem.OnClick := DoOnReportListClick;
      FpmReport.Items.Add(MenuItem);

      MenuItem := TMenuItem.Create(FpmReport);
      MenuItem.Caption := '-';
      FpmReport.Items.Add(MenuItem);
   {$ENDIF}

    IBSQL.SQL.Text := Format(
      ' SELECT id, name FROM rp_reportlist r WHERE r.reportgroupkey = %d ' +
      ' AND g_sec_testall(r.afull, r.achag, r.aview, %d) <> 0 ORDER BY name', [GroupID, IBLogin.Ingroup]);
    IBSQL.ExecQuery;

    while not IBSQL.Eof do
    begin
      MenuItem := TMenuItem.Create(FpmReport);
      MenuItem.Caption := IBSQL.FieldByName('Name').AsString;
      MenuItem.Tag := IBSQL.FieldByName('ID').AsInteger;
      MenuItem.OnClick := DoOnReportClick;
      FpmReport.Items.Add(MenuItem);

      IBSQL.Next;
    end;

  finally
    IBSQL.Close;
    IBSQL.Free;

    if DidActivate then
      DeactivateReadTransaction;
  end;
end;

procedure TgdcBase.Find;
begin
  with Tgdc_dlgFind.Create(Self) do
  try
    Find(Self);
  finally
    Free;
  end;
end;

procedure TgdcBase.DoBeforeOpen;
begin
  if not FSQLInitialized then
    InitSQL;

  if HasSubSet('ByID') and (FID > -1) then
    ParamByName(GetKeyField(SubType)).AsInteger := FID
  else if HasSubSet('ByName') and (FObjectName > '') then
    ParamByName(GetListField(SubType)).AsString := FObjectName;

  inherited DoBeforeOpen;

  {$IFDEF DEBUG}
  //OutputDebugString(PChar(Name + '.BeforeOpen: ' + FormatDateTime('hh:nn:ss.z', Now)));
  {$ENDIF}
end;

procedure TgdcBase.DoOnNewRecord;
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_WITHOUTPARAM('TGDCBASE', 'DOONNEWRECORD')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'DOONNEWRECORD');
  {M}      Index := LastCallClass.IndexOf('DOONNEWRECORD');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'DOONNEWRECORD', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'DOONNEWRECORD') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'DOONNEWRECORD');
  {M}    end;
  {END MACRO}
  if FDataTransfer then
    exit;

  _DoOnNewRecord;


  inherited DoOnNewRecord;
  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'DOONNEWRECORD')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'DOONNEWRECORD') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'DOONNEWRECORD'));
  {M}      ClearMacrosStack('TGDCBASE', 'DOONNEWRECORD');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

function TgdcBase.EditDialog(const ADlgClassName: String = ''): Boolean;
var
  C: TClass;
  CFull: TgdcFullClass;
  Obj: TgdcBase;
  DlgForm: TCreateableForm;
  I: Integer;
  F: TField;
  InTransaction: Boolean;
  FormClass: String;
  //Buff: PChar;
  //BuffSize: Integer;
begin
  DlgForm := nil;
  if GetCurrRecordClass.gdClass = Self.ClassType then
  begin
    C := GetClass(ADlgClassName);

    if (C <> nil) and (C.InheritsFrom(TCreateableForm)) then
      DlgForm := CCreateableForm(C).Create(FParentForm)
    else
    begin
      if Assigned(GlobalStorage) then
      begin
        FormClass := GlobalStorage.ReadString(st_ds_NewFormPath + '\' + ADlgClassName, st_ds_FormClass);
        if FormClass <> '' then
        begin
          C := GetClass(FormClass);
          if Assigned(C) then
          begin
            DlgForm := CCreateableForm(C).CreateUser(FParentForm, ADlgClassName)
          end;
        end;
      end;
    end;

    if DlgForm = nil then
      DlgForm := CreateDialogForm;

    if Assigned(DlgForm) then
      with DlgForm do
    try
      InTransaction := Transaction.Active;

      FDlgStack.Push(DlgForm);

      Self.Edit;

      if sDialog in FBaseState then
      begin
        Include(FBaseState, sSubDialog);
      end else
        Include(FBaseState, sDialog);

      Setup(Self);

      DoBeforeShowDialog(DlgForm);
      Result := ShowModal = mrOk;
      DoAfterShowDialog(DlgForm, Result);

      if not (sSubDialog in FBaseState) then
      begin
        if Self.State in dsEditModes then
          if Result then Self.Post else Self.Cancel;

        if (not InTransaction) and Transaction.InTransaction then
        begin
          if Result then
            Transaction.Commit
          else
            Transaction.Rollback;

          {$IFDEF DEBUG}
          OutputDebugString('Окно не закрыло транзакцию!');
          {$ENDIF}
        end;

        if not Result then
          for I := 0 to FDetailLinks.Count - 1 do
            if (FDetailLinks[I] <> nil) and (DetailLinks[I].Transaction <> DetailLinks[I].ReadTransaction)
            then
            begin
              DetailLinks[I].Close;
              DetailLinks[I].Open;
            end;
      end;
    finally
      if sSubDialog in FBaseState then
      begin
        Exclude(FBaseState, sSubDialog);
      end else
        Exclude(FBaseState, sDialog);

      FDlgStack.Pop;

      Free;
    end else
      Result := False;
  end else begin
    CFull := GetCurrRecordClass;
    C := CFull.gdClass;
    Obj := CgdcBase(C).CreateWithID(Owner, Database, Transaction, ID, CFull.SubTYpe);
    try
      Obj.MasterSource := MasterSource;

      Obj.AfterCancel := AfterCancel;
      Obj.AfterClose := AfterClose;
      Obj.AfterDelete := AfterDelete;
      Obj.AfterEdit := AfterEdit;
      Obj.AfterInsert := AfterInsert;
      Obj.AfterInternalDeleteRecord := AfterInternalDeleteRecord;
      Obj.AfterInternalPostRecord := AfterInternalPostRecord;
      Obj.AfterOpen := AfterOpen;
      Obj.AfterPost := AfterPost;
      Obj.AfterRefresh := AfterRefresh;
      Obj.AfterScroll := AfterScroll;
      Obj.AfterShowDialog := AfterShowDialog;
      Obj.BeforeCancel := BeforeCancel;
      Obj.BeforeClose := BeforeClose;
      Obj.BeforeDelete := BeforeDelete;
      Obj.BeforeEdit := BeforeEdit;
      Obj.BeforeInsert := BeforeInsert;
      Obj.BeforeInternalDeleteRecord := BeforeInternalDeleteRecord;
      Obj.BeforeInternalPostRecord := BeforeInternalPostRecord;
      Obj.BeforeOpen := BeforeOpen;
      Obj.BeforePost := BeforePost;
      Obj.BeforeRefresh := BeforeRefresh;
      Obj.BeforeScroll := BeforeScroll;
      Obj.BeforeShowDialog := BeforeShowDialog;
      Obj.OnCalcFields := OnCalcFields;
      Obj.OnDeleteError := OnDeleteError;
      Obj.OnEditError := OnEditError;
      Obj.OnNewRecord := OnNewRecord;
      Obj.OnPostError := OnPostError;
      Obj.OnUpdateError := OnUpdateError;
      Obj.OnUpdateRecord := OnUpdateRecord;
      try

        Obj.Open;
        Result := Obj.EditDialog(ADlgClassName);

        if Result and Active and Obj.Active then
        begin

          { TODO :
  тут проблема: запрос в компоненте может быть изменен
  например в фильтре пользователь создал свой запрос
  вытянув туда дополнительную колонку. в Обдж такой колонки
  не будет...

  получается что создавая объект копию надо как-то с ним
  синхронизировать запрос. }
          {Assert(_RecordBufferSize = Obj.RecordBufferSize);

          IBAlloc(Buff, 0, _RecordBufferSize);
          try
            Obj.ReadRecordCache(Obj._CurrentRecord, Buff, False);
            WriteRecordCache(_CurrentRecord, Buff);
            Resync([]);
          finally
            FreeMem(Buff, _RecordBufferSize);
          end;}

          {BuffSize := 0;
          FDataTransfer := True;
          try
            for I := 0 to FieldCount - 1 do
            begin
              F := Obj.FindField(Fields[I].FieldName);
              if Assigned(F) then
              begin
                if F.DataSize > BuffSize then
                begin
                  BuffSize := F.DataSize;
                  ReallocMem(Buff, BuffSize);
                end;
                if Obj.InternalGetFieldData(F, Buff) then
                  InternalSetFieldData(Fields[I], Buff);
              end;
            end;
          finally
            FDataTransfer := False;
            ReallocMem(Buff, 0);
          end;}

          FDataTransfer := True;
          try
            AfterCancel := nil;
            AfterClose := nil;
            AfterDelete := nil;
            AfterEdit := nil;
            AfterInsert := nil;
            AfterInternalDeleteRecord := nil;
            AfterInternalPostRecord := nil;
            AfterOpen := nil;
            AfterPost := nil;
            AfterRefresh := nil;
            AfterScroll := nil;
            AfterShowDialog := nil;
            BeforeCancel := nil;
            BeforeClose := nil;
            BeforeDelete := nil;
            BeforeEdit := nil;
            BeforeInsert := nil;
            BeforeInternalDeleteRecord := nil;
            BeforeInternalPostRecord := nil;
            BeforeOpen := nil;
            BeforePost := nil;
            BeforeRefresh := nil;
            BeforeScroll := nil;
            BeforeShowDialog := nil;
            OnCalcFields := nil;
            OnDeleteError := nil;
            OnEditError := nil;
            OnNewRecord := nil;
            OnPostError := nil;
            OnUpdateError := nil;
            OnUpdateRecord := nil;

            Edit;
            for I := 0 to FieldCount - 1 do
            begin
              F := Obj.FindField(Fields[I].FieldName);
              if Assigned(F) then
                Fields[I].Assign(F);
            end;
            Post;
          finally
            FDataTransfer := False;
          end;
        end;

      finally
        AfterCancel := Obj.AfterCancel;
        AfterClose := Obj.AfterClose;
        AfterDelete := Obj.AfterDelete;
        AfterEdit := Obj.AfterEdit;
        AfterInsert := Obj.AfterInsert;
        AfterInternalDeleteRecord := Obj.AfterInternalDeleteRecord;
        AfterInternalPostRecord := Obj.AfterInternalPostRecord;
        AfterOpen := Obj.AfterOpen;
        AfterPost := Obj.AfterPost;
        AfterRefresh := Obj.AfterRefresh;
        AfterScroll := Obj.AfterScroll;
        AfterShowDialog := Obj.AfterShowDialog;
        BeforeCancel := Obj.BeforeCancel;
        BeforeClose := Obj.BeforeClose;
        BeforeDelete := Obj.BeforeDelete;
        BeforeEdit := Obj.BeforeEdit;
        BeforeInsert := Obj.BeforeInsert;
        BeforeInternalDeleteRecord := Obj.BeforeInternalDeleteRecord;
        BeforeInternalPostRecord := Obj.BeforeInternalPostRecord;
        BeforeOpen := Obj.BeforeOpen;
        BeforePost := Obj.BeforePost;
        BeforeRefresh := Obj.BeforeRefresh;
        BeforeScroll := Obj.BeforeScroll;
        BeforeShowDialog := Obj.BeforeShowDialog;
        OnCalcFields := Obj.OnCalcFields;
        OnDeleteError := Obj.OnDeleteError;
        OnEditError := Obj.OnEditError;
        OnNewRecord := Obj.OnNewRecord;
        OnPostError := Obj.OnPostError;
        OnUpdateError := Obj.OnUpdateError;
        OnUpdateRecord := Obj.OnUpdateRecord;
      end;

    finally
      Obj.Free;
    end;
  end;
end;

function TgdcBase.EditMultiple(BL: TBookmarkList; const ADlgClassName: String = ''): Boolean;
var
  SL, SLChanged: TStringList;
  PS: PString;
  I, K, ErrCount: Integer;
  Bm: String;
  C: TClass;
begin
  Assert(not Transaction.Active, 'Transaction must be closed!');

  if (BL = nil) or (BL.Count <= 1) then
    Result := EditDialog(ADlgClassName)
  else begin
    if MessageBox(ParentHandle,
      PChar(Format('Выделено для редактирования записей: %d. Продолжить?', [BL.Count])),
      'Внимание',
      MB_YESNO or MB_ICONQUESTION) = IDNO then
    begin
      Result := False;
      exit;
    end;

    SL := TStringList.Create;
    SLChanged := TStringList.Create;
    try
      GetFieldNames(SL);
      for I := 0 to SL.Count - 1 do
      begin
        New(PS);
        PS^ := FieldByName(SL[I]).AsString;
        SL.Objects[I] := TObject(PS);
      end;
      C := GetCurrRecordClass.gdClass;
      Result := EditDialog(ADlgClassName);
      if Result then
      begin
        for I := 0 to SL.Count - 1 do
        begin
          if FieldByName(SL[I]).AsString <> PString(SL.Objects[I])^ then
          begin
            New(PS);
            PS^ := FieldByName(SL[I]).AsString;
            SLChanged.AddObject(SL[I], TObject(PS));
          end;
        end;
        if SLChanged.Count > 0 then
        begin
          DisableControls;
          ErrCount := 0;
          try
            Bm := Bookmark;
            for I := 0 to BL.Count - 1 do
            begin
              if (BL[I] = Bm) or not BookmarkValid(Pointer(BL[I])) then
                continue;
              Bookmark := BL[I];
              if GetCurrRecordClass.gdClass <> C then
                continue;
              try
                Edit;
                for K := 0 to SLChanged.Count - 1 do
                begin
                  FieldByName(SLChanged[K]).AsString := PString(SLChanged.Objects[K])^;
                end;
                Post;
              except
                Inc(ErrCount);
              end;
            end;
            Bookmark := Bm;
          finally
            EnableControls;
          end;

          if ErrCount > 0 then
          begin
            MessageBox(ParentHandle,
              PChar(Format('В процессе редактирования возникли ошибки в %d записи(ях).',
                [ErrCount])),
              'Внимание',
              MB_OK or MB_ICONHAND);
          end;
        end;
      end;
    finally
      for I := 0 to SL.Count - 1 do
        if SL.Objects[I] <> nil then
        begin
          PS := PString(SL.Objects[I]);
          Dispose(PS);
        end;
      SL.Free;
      for I := 0 to SLChanged.Count - 1 do
        if SLChanged.Objects[I] <> nil then
        begin
          PS := PString(SLChanged.Objects[I]);
          Dispose(PS);
        end;
      SLChanged.Free;
    end;
  end;
end;

function TgdcBase.GetDeleteSQLText: String;
begin
  Result := Format('DELETE FROM %s WHERE %s=:OLD_%s ',
    [GetListTable(SubType), GetKeyField(SubType), GetKeyField(SubType)]);
end;

function TgdcBase.GetDetailClasses(Index: Integer): CgdcBase;
begin
  Assert((Index >= 0) and (Index < GetDetailClassesCount), 'Invalid index specified');
  Result := nil;
end;

function TgdcBase.GetDetailClassesCount: Integer;
begin
  Result := 0;
end;

function TgdcBase.GetDetailField: String;
begin
  if FgdcDataLink <> nil then
    Result := FgdcDataLink.DetailField
  else
    Result := '';  
end;

class function TgdcBase.GetDisplayName(const ASubType: String): String;
var
  R: TatRelation;
begin
  Result := '';
  if Assigned(atDatabase) then
  begin
    R := atDatabase.Relations.ByRelationName(GetListTable(ASubType));
    { TODO : может предусмотреть два метода: один возвращает длинное имя, второй короткое? }
    if R <> nil then Result := R.LShortName;
  end;
end;

function TgdcBase.GetGroupClause: String;
begin
  Result := ' ';
end;

function TgdcBase.GetID: Integer;
begin
  if Active then
    Result := FieldByName(GetKeyField(SubType)).AsInteger
  else
    Result := FID;
end;

function TgdcBase.GetInsertSQLText: String;
var
  I: Integer;
  F, V: String;
  SL: TStrings;
  LT, LF: String;
  IsUserTable: Boolean;
begin
  Assert(GetListTable(SubType) > '');

  LT := GetListTable(SubType);
  LF := GetListField(SubType);

  IsUserTable := Pos(UserPrefix, UpperCase(LT)) = 1;

  if Database = nil then
    Result := Format('INSERT INTO %s (%s) VALUES (:NEW_%s) ', [LT, LF, LF])
  else begin
    SL := TStringList.Create;
    try
      Database.GetFieldNames(LT, SL);
      Result := 'INSERT INTO ' + LT + ' (';
      F := '';
      V := '';
      for I := 0 to SL.Count - 1 do
        if (IsUserTable or (Pos(UserPrefix, UpperCase(SL[I])) <> 1)) and //атрибуты вставит наш анализатор кода
          (not Database.Has_Computed_BLR(UpperCase(LT), UpperCase(SL[I]))) and
          (UpperCase(SL[I]) <> 'LB') and
          (UpperCase(SL[I]) <> 'RB') then
        begin
          F := F + SL[I] + ',';
          V := V + ':NEW_' + SL[I] + ',';
        end;
      SetLength(F, Length(F) - 1);
      SetLength(V, Length(V) - 1);
      Result := Result + F + ') VALUES (' + V + ') ';

      FUpdateableFields := F;
    finally
      SL.Free;
    end;
  end;
end;

class function TgdcBase.GetKeyField(const ASubType: String): String;
begin
  Result := 'ID';
end;

function TgdcBase.GetMasterField: String;
begin
  if FgdcDataLink <> nil then
    Result := FgdcDataLink.MasterField
  else
    Result := '';  
end;

function TgdcBase.GetMasterSource: TDataSource;
begin
  if FgdcDataLink <> nil then
    Result := FgdcDataLink.DataSource
  else
    Result := nil;
end;

function TgdcBase.GetModifySQLText: String;
var
  I: Integer;
  SL: TStrings;
  LT, KF, LF: String;
  IsUserTable: Boolean;
begin
  Assert(GetListTable(SubType) > '');

  LT := GetListTable(SubType);
  KF := GetKeyField(SubType);
  LF := GetListField(SubType);

  IsUserTable := Pos(UserPrefix, UpperCase(LT)) = 1;

  if (Database = nil) then
    Result := Format('UPDATE %s SET %s=:NEW_%s WHERE %s=:OLD_%s ',
      [LT, LF, LF, KF, KF])
  else begin
    SL := TStringList.Create;
    try
      Database.GetFieldNames(LT, SL);
      if SL.Count < 2 then
        Result := Format('UPDATE %s SET %s=:NEW_%s WHERE %s=:OLD_%s ',
          [LT, LF, LF, KF, KF])
      else begin
        Result := 'UPDATE ' + LT + ' SET ';
        for I := 0 to SL.Count - 1 do
          if (AnsiCompareText(SL[I], KF) <> 0) and
             (IsUserTable or (Pos(UserPrefix, UpperCase(SL[I])) <> 1)) and
             (not Database.Has_Computed_BLR(UpperCase(LT), UpperCase(SL[I]))) and
             (UpperCase(SL[I]) <> 'LB') and
             (UpperCase(SL[I]) <> 'RB') then
            Result := Result + SL[I] + '=:NEW_' + SL[I] + ',';
        SetLength(Result, Length(Result) - 1);
        Result := Result + ' WHERE ' + KF + '=:OLD_' + KF + ' ';
      end;
    finally
      SL.Free;
    end;
  end;
end;

class function TgdcBase.GetOperationFolderID: Integer;
begin
  Result := -1;
end;

function TgdcBase.GetOrderClause: String;
begin
  Result := ' ';
end;

function TgdcBase.GetRefreshSQLText: String;
begin
  Result :=
    GetSelectClause + ' ' +
    GetFromClause + ' ' +
    Format('WHERE %s.%s = :NEW_%s ', [GetListTableAlias,
      GetKeyField(SubType), GetKeyField(SubType)]);
end;

class function TgdcBase.GetRestrictCondition(
  const ATableName, ASubType: String): String;
begin
  Result := '';
end;

function TgdcBase.GetSelectClause: String;
begin
  Result := Format('SELECT %s.* ', [GetListTableAlias]);
end;

function TgdcBase.GetSelectSQLText: String;

  function GetSetTableSelect: String;
  begin
    if FSetTable > '' then
      Result := ', gd$st.* '
    else
      Result := '';
  end;

  function GetSetTableJoin: String;
  var
    PK: TatPrimaryKey;
    R: TatRelation;
  begin
    Result := '';
    if (FSetTable > '') and (atDatabase <> nil) and (atDatabase.Relations <> nil) then
    begin
      R := atDatabase.Relations.ByRelationName(FSetTable);

      if R <> nil then
        PK := R.PrimaryKey
      else
        PK := nil;

      if (PK <> nil) and (PK.ConstraintFields.Count = 2) then
      begin
        if AnsiCompareText(PK.ConstraintFields[0].References.RelationName, GetListTable(SubType)) = 0 then
        begin
          FSetItemField := PK.ConstraintFields[0].FieldName;
          FSetMasterField := PK.ConstraintFields[1].FieldName;
        end else
        begin
          FSetItemField := PK.ConstraintFields[1].FieldName;
          FSetMasterField := PK.ConstraintFields[0].FieldName;
        end;

        Result := Format('JOIN %s gd$st ON gd$st.%s = :MASTER_RECORD_ID AND gd$st.%s = %s.%s ',
          [FSetTable, FSetMasterField, FSetItemField, GetListTableAlias, GetKeyField(SubType)]);
      end;
    end;
  end;

begin
  Result :=
    GetSelectClause + ' ' + GetSetTableSelect +
    GetFromClause + ' ' + GetSetTableJoin +
    GetWhereClause + ' ';
  if not HasSubSet('ByID') then
    Result := Result +
      GetGroupClause + ' ' +
      GetOrderClause;
end;

function TgdcBase.Choose(F: TgdcFindObject): Boolean;
begin
  with Tgdc_dlgFind.Create(Self) do
  try
    Result := Choose(Self, F);

  finally
    Free;
  end;
end;

function TgdcBase.Choose(L: TgdcFindObjectList): Boolean;
begin
  with Tgdc_dlgFind.Create(Self) do
  try
    Result := Choose(Self, L);
  finally
    Free;
  end;
end;

function TgdcBase.Choose: Boolean;
var
  L: TgdcFindObjectList;
  I: Integer;

begin
  L := TgdcFindObjectList.Create(GetFindFieldList);
  try
    Result := Choose(L);
    if Result then
       for I := 0 to L.Count - 1 do
         try
           ChooseElement(TgdcFindObject(L[I]));
         except
         end;
  finally
    L.Free;
  end;
end;

function TgdcBase.Choose(C: CgdcBase; F: TgdcFindObject): Boolean;
var
  Obj: TgdcBase;

begin
  Obj := C.CreateWithParams(Owner, Database, Transaction);
  try
    Obj.SearchSubSet := SearchSubSet;
    Result := Obj.Choose(F);
  finally
    Obj.Free;
  end;
end;

function TgdcBase.Choose(C: CGdcBase; L: TgdcFindObjectList): Boolean;
var
  Obj: TgdcBase;

begin
  Obj := C.CreateWithParams(Owner, Database, Transaction);
  try
    Obj.SearchSubSet := SearchSubSet;
    Result := Obj.Choose(L);
  finally
    Obj.Free;
  end;
end;

function TgdcBase.Choose(C: CGdcBase): Boolean;
var
  L: TgdcFindObjectList;
  I: Integer;

begin
  L := TgdcFindObjectList.Create(GetFindFieldList);
  try
    Result := Choose(C, L);
    if Result then
      for I := 0 to L.Count - 1 do
        try
          ChooseElement(TgdcFindObject(L[I]));
        except
        end;
  finally
    L.Free;
  end;
end;

function TgdcBase.GetUserRights: TUserRights;

  procedure WorkDescr(var R: TUserRights; const UR: TUserRight; const FN: String);
  var
    F: TField;
  begin
    F := FindField(FN);
    if (F <> nil) and (((F.AsInteger or 1) and IBLogin.InGroup) = 0) then
      Exclude(R, UR);
  end;

begin
  Result := [urView, urChag, urFull];
  WorkDescr(Result, urView, 'aview');
  WorkDescr(Result, urChag, 'achag');
  WorkDescr(Result, urFull, 'afull');
end;

function TgdcBase.GetWhereClause: String;

  function GetSecCondition: String;
  begin
    Result := '';
    if Assigned(IBLogin) then
    begin
      if tiAView in gdcTableInfos then
        Result := Result + Format(' g_sec_test(%s.aview, %d) <> 0 ',
          [GetListTableAlias, IBLogin.InGroup])
      else if tiAChag in gdcTableInfos then
        Result := Result + Format(' g_sec_test(%s.achag, %d) <> 0 ',
          [GetListTableAlias, IBLogin.InGroup])
      else if tiAFull in gdcTableInfos then
        Result := Result + Format(' g_sec_test(%s.afull, %d) <> 0 ',
          [GetListTableAlias, IBLogin.InGroup]);
    end;
  end;

var
  S: TStringList;
  I: Integer;
begin
  S := TStringList.Create;
  try
    S.Duplicates := dupIgnore;
    GetWhereClauseConditions(S);
    S.Add(GetSecCondition);
    for I := 0 to FExtraConditions.Count - 1 do
      S.Add(FExtraConditions[I]);
    S.Add(FFindWhereSQL); { TODO : рудимент! убрать! }
    for I := S.Count - 1 downto 0 do
      if Trim(S[I]) = '' then
        S.Delete(I);
    if S.Count > 0 then
    begin
      Result := 'WHERE ' + S[0];
      for I := 1 to S.Count - 1 do
        Result := Result + ' AND ' + S[I];
    end else
      Result := '';
  finally
    S.Free;
  end;
end;

procedure TgdcBase.InitSQL;
var
  SQLText, FullClassName: String;
  isReplaceSQL: Boolean;
  {$IFDEF DEBUG}T: TDateTime;{$ENDIF}
begin
  {$IFDEF DEBUG}
  T := Now;
  {$ENDIF}

  if FSQLInitialized then
    exit;

  SetDefaultFields(True);
  DestroyFields;

  if not Assigned(FSQLSetup) then
    FSQLSetup := TatSQLSetup.Create(nil);

  if not (csDesigning in ComponentState) then
  begin
    FullClassName := Self.ClassName + '(' + Self.SubType + ')';
    with FSQLSetup do
    begin
      //В Select-запрос вытягиваем только указанные аттрибуты
      SelectSQL.Text := PrepareSQL(GetSelectSQLText, FullClassName);
      ModifySQL.Text := PrepareSQL(GetModifySQLText, FullClassName);
      InsertSQL.Text := PrepareSQL(GetInsertSQLText, FullClassName);
      DeleteSQL.Text := {PrepareSQL(}GetDeleteSQLText{)};
      RefreshSQL.Text := PrepareSQL(GetRefreshSQLText, FullClassName);
    end;
  end else
  begin
    SelectSQL.Text := GetSelectSQLText;
    ModifySQL.Text := GetModifySQLText;
    InsertSQL.Text := GetInsertSQLText;
    DeleteSQL.Text := GetDeleteSQLText;
    RefreshSQL.Text := GetRefreshSQLText;
  end;

// Событие на создание запроса. Для возможности его корректировки из вне.

  if Assigned(FAfterInitSQL) then
  begin
    isReplaceSQL := False;
    SQLText := SelectSQL.Text;
    FAfterInitSQL(Self, SQLText, isReplaceSQL);
    if isReplaceSQL then
      SelectSQL.Text := SQLText;
  end;

  FSQLInitialized := True;

  {$IFDEF DEBUG}
  //if Now - T > 1 / (24 * 60 * 60) then
    OutputDebugString(PChar(Name + '.InitSQL: ' + FormatDateTime('s.z', Now - T)));
  {$ENDIF}
end;

procedure TgdcBase.InternalDelete;
begin
  inherited InternalDelete;
  {$IFDEF DEBUG}JournalAdd(Transaction, 1);{$ENDIF}
end;

procedure TgdcBase.InternalPostRecord(Qry: TIBSQL; Buff: Pointer);
var
  i, j, k: Integer;
  pbd: PBlobDataArray;
  DidActivate: Boolean;
begin
  pbd := PBlobDataArray(PChar(Buff) + FBlobCacheOffset);
  j := 0;
  for i := 0 to FieldCount - 1 do
    if Fields[i].IsBlob then
    begin
      k := FMappedFieldPosition[Fields[i].FieldNo -1];
      if pbd^[j] <> nil then
      begin
        pbd^[j].Finalize;
        PISC_QUAD(
          PChar(Buff) + PRecordData(Buff)^.rdFields[k].fdDataOfs)^ :=
          pbd^[j].BlobID;
        PRecordData(Buff)^.rdFields[k].fdIsNull := pbd^[j].Size = 0;
      end;
      Inc(j);
    end;

  if not FDataTransfer then
  begin
    if Assigned(UpdateObject) then
    begin
      if (Qry = QDelete) then
        UpdateObject.Apply(DB.ukDelete)
      else
        if (Qry = QInsert) then
          UpdateObject.Apply(DB.ukInsert)
        else
          UpdateObject.Apply(DB.ukModify);
    end
    else
    begin
      DidActivate := False;
      try
        DidActivate := ActivateTransaction;
        try
          { TODO : в случае кастом обработки роузаффектед будет содержать 0 }
          FRowsAffected := 0;
          if (Qry = QInsert) then
            _CustomInsert(Buff)
          else if (Qry = QModify) then
            _CustomModify(Buff);
        except
          if DidActivate and AllowCloseTransaction then
            Transaction.Rollback;
          raise;
        end;
      finally
        if DidActivate and AllowCloseTransaction then
          Transaction.Commit;
      end;
    end;
  end;

  PRecordData(Buff)^.rdUpdateStatus := usUnmodified;
  PRecordData(Buff)^.rdCachedUpdateStatus := cusUnmodified;
  SetModified(False);
  WriteRecordCache(PRecordData(Buff)^.rdRecordNumber, Buff);

  if not FDataTransfer then
  begin
    if (ForcedRefresh or FNeedsRefresh) and CanRefresh then
      InternalRefreshRow;
  end;

  {logging}
  {$IFDEF DEBUG}
  if State = dsInsert then JournalAdd(Transaction, 1)
    else JournalAdd(Transaction, 2);
  {$ENDIF}
end;

procedure TgdcBase.InternalDeleteRecord(Qry: TIBSQL; Buff: Pointer);
var
  DidActivate: Boolean;
  CFull: TgdcFullClass;
  C: CgdcBase;
  Obj: TgdcBase;
begin
  if (Assigned(FUpdateObject) and (FUpdateObject.GetSQL(DB.ukDelete).Text > '')) then
    FUpdateObject.Apply(DB.ukDelete)
  else if not FDataTransfer then
  begin
    if GetCurrRecordClass.gdClass = Self.ClassType then
    begin
      //!!!
      DidActivate := False;
      try
        DidActivate := ActivateTransaction;
        try
      //!!!
          FRowsAffected := 0;
          if (Qry = QDelete) then
            _CustomDelete(Buff);
      //!!!
        except
          if DidActivate and AllowCloseTransaction then
            Transaction.Rollback;
          raise;
        end;
      finally
        if DidActivate and AllowCloseTransaction then
          Transaction.Commit;
      end;
      //!!!
    end else
    begin
      CFull := GetCurrRecordClass;
      C := CFull.gdClass;
      Obj := CgdcBase(C).CreateWithID(Owner, Database, Transaction, ID, CFull.SubType);
      try
        Obj.Open;
        Obj.Delete;
      finally
        Obj.Free;
      end;
    end;
  end;
  with PRecordData(Buff)^ do
  begin
    rdUpdateStatus := usDeleted;
    rdCachedUpdateStatus := cusUnmodified;
  end;
  WriteRecordCache(PRecordData(Buff)^.rdRecordNumber, Buff);
end;

class function TgdcBase.IsBigTable: Boolean;
begin
  //...
  Result := False;
end;

procedure TgdcBase.Loaded;
begin
  inherited Loaded;

  FFilter := TgsQueryFilter.Create(Self);
  FFilter.Database := Database;
  FFilter.IBDataSet := Self;
  FFilter.OnFilterChanged := DoOnFilterChanged;
  FFilter.Name := 'flt_' + RemoveProhibitedSymbols(System.copy(ClassName, 2, 255));
end;

procedure TgdcBase._LoadFromStream(Stream: TStream; IDMapping: TgdKeyIntAssoc; ObjectSet: TgdcObjectSet; UpdateList: TObjectList);

  function StreamReadString(St: TStream): String;
  var
    L: Integer;
  begin
    St.Read(L, SizeOf(L));
    SetLength(Result, L);
    if L > 0 then
      St.Read(Result[1], L);
  end;

  function CopyRecord(SourceDS: TDataSet; TargetDS: TgdcBase; UL: TObjectList): Boolean;
  var
    I, Key: Integer;
    R: TatRelation;
    F: TatRelationField;
    IsNull: Boolean;
    SourceField, TargetField: TField;
    RU: TgdcReferenceUpdate;
  begin
    Result := False;
    RU := nil;

    for I := 0 to SourceDS.FieldCount - 1 do
    begin
      SourceField := SourceDS.Fields[I];
      TargetField := TargetDS.FindField(SourceField.FieldName);

      if (AnsiCompareText(SourceField.FieldName, TargetDS.GetKeyField(TargetDS.SubType)) <> 0)
        and (TargetField <> nil) then
      begin
        R := atDatabase.Relations.ByRelationName(TargetDS.RelationByAliasName(TargetField.FieldName));

        // системных таблиц нет в нашей структуре атДатабэйз
        if R = nil then
        begin
          TargetField.Assign(SourceField);
          continue;
        end;

        F := R.RelationFields.ByFieldName(TargetDS.FieldNameByAliasName(TargetField.FieldName));

        RU := nil;
        IsNull := False;
        Key := -1;

        if (F <> nil) and (F.References <> nil) then
        begin
{          if (ObjectSet.Find(SourceField.AsInteger) <> -1) and (SourceField.AsInteger <> SourceDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsInteger) then
          begin
            RU := TgdcReferenceUpdate.Create;
            RU.C := GetBaseClassForRelation(F.References.RelationName).gdClass;
            RU.TableName := R.RelationName;
            RU.FieldName := F.FieldName;
            RU.KeyFieldName := R.PrimaryKey.ConstraintFields[0].FieldName;
            RU.ID := -1;
            RU.RefID := SourceField.AsInteger;
            UL.Add(RU);
            IsNull := True;
          end else
          begin}
            Key := IDMapping.IndexOf(SourceField.AsInteger);
            if Key <> -1 then
            begin
              Key := IDMapping.ValuesByIndex[Key];
              IsNull := Key = -1;
            end;
            if IsNull and (ObjectSet.Find(SourceField.AsInteger) <> -1) and (SourceField.AsInteger <> SourceDS.FieldByName(TargetDS.GetKeyField(TargetDS.SubType)).AsInteger) then
            begin
              RU := TgdcReferenceUpdate.Create;
              RU.C := GetBaseClassForRelation(F.References.RelationName, ReadTransaction).gdClass;
              RU.TableName := R.RelationName;
              RU.FieldName := F.FieldName;
              RU.KeyFieldName := R.PrimaryKey.ConstraintFields[0].FieldName;
              RU.ID := -1;
              RU.RefID := SourceField.AsInteger;
              UL.Add(RU);
              IsNull := True;
            end
         // end;
        end;

        if Key = -1 then
        begin
          if IsNull then
            TargetField.Clear
          else
            TargetField.Assign(SourceField);
        end else
        begin
          if IsNull then
            TargetField.Clear
          else
            TargetField.AsInteger := Key;
        end;
      end;
    end;


    try
      try
        TargetDS.Post;
      except
        on E: EDatabaseError do
        begin
          // добавить не удалось. возможно объект уже
          // существует в базе. прежде чем переходить
          // к ручному управлению попробуем поискать
          // подходящий объект автоматически
          if not TargetDS.CheckTheSame then
            if not TargetDS.EditDialog('Tgdc_dlgCantCreateObject') then
              raise;
        end;
      end;

      IDMapping.ValuesByIndex[
        IDMapping.Add(SourceDS.FieldByName(TargetDS.GetKeyField(SubType)).AsInteger)] := TargetDS.ID;

      if RU <> nil then
      begin
        RU.ID := TargetDS.ID;
      end;

      for I := UL.Count - 1 downto 0 do
      begin
        if (UL[I] as TgdcReferenceUpdate).RefID = SourceDS.FieldByName(TargetDS.GetKeyField(SubType)).AsInteger then
        begin
          ExecSingleQuery(Format('UPDATE %s SET %s=%d WHERE %s=%d',
            [(UL[I] as TgdcReferenceUpdate).TableName,
             (UL[I] as TgdcReferenceUpdate).FieldName,
             TargetDS.ID,
             (UL[I] as TgdcReferenceUpdate).KeyFieldName,
             (UL[I] as TgdcReferenceUpdate).ID]));
        end;
        UL.Delete(I);
      end;

      ObjectSet.Remove(SourceDS.FieldByName(TargetDS.GetKeyField(SubType)).AsInteger);

      Result := True;
    except
      on E: EDatabaseError do
      begin
        MessageBox(ParentHandle,
          PChar(Format('Невозможно добавить объект: %s %s %d', [TargetDS.ClassName, TargetDS.ObjectName, TargetDS.ID])),
          'Ошибка',
          MB_OK or MB_ICONHAND);

        TargetDS.Cancel;

        IDMapping.ValuesByIndex[
          IDMapping.Add(SourceDS.FieldByName(TargetDS.GetKeyField(SubType)).AsInteger)] := -1;
      end;
    end;
  end;

  procedure InsertRecord(SourceDS: TDataSet; TargetDS: TgdcBase; UL: TObjectList);
  var
    q: TIBSQL;
  begin
    TargetDS.Insert;
    if CopyRecord(SourceDS, TargetDS, UL) then
    begin
      q := TIBSQL.Create(nil);
      try
        q.Database := TargetDS.Database;
        q.Transaction := TargetDS.Transaction;

        q.SQL.Text := 'SELECT *  FROM gd_ruid WHERE id=:id';
        q.Prepare;
        q.ParamByName('id').AsInteger := TargetDS.ID;
        q.ExecQuery;

        if q.EOF then
        begin
          q.Close;
          q.SQL.Text := 'INSERT INTO gd_ruid VALUES (:id, :xid, :dbid, :modified, :editorkey)';
          q.Prepare;
          q.ParamByName('id').AsInteger := TargetDS.ID;
          q.ParamByName('xid').AsInteger := SourceDS.FieldByName('_XID').AsInteger;
          q.ParamByName('dbid').AsInteger := SourceDS.FieldByName('_DBID').AsInteger;
          q.ParamByName('modified').AsDateTime := SourceDS.FieldByName('_MODIFIED').AsDateTime;
          if Assigned(IBLogin) then
            q.ParamByName('editorkey').AsInteger := IBLogin.ContactKey
          else
            q.ParamByName('editorkey').Clear;
          q.ExecQuery;
        end else
        begin
          // этот объект уже приходил к нам из другой базы
          // его РУИД уже сформирован. Если мы не хотим в будущем
          // каждый раз указывать соответствие объектов при импорте
          // необходимо передать назад в базу источник
          // существующий РУИД этого объекта, чтобы там прописать его.
          //
          // хм. надо подумать...
          //
          // пока же просто обновим его РУИД
          // проблема будет только если из двух баз постоянно
          // поочередно передаются данные в третью
          // придется каждый раз указывать соответствие объектов

          (*
          q.Close;
          q.SQL.Text := 'UPDATE gd_ruid SET xid=:xid, dbid=:dbid, modified=:modified WHERE id=:id';
          q.Prepare;
          q.ParamByName('id').AsInteger := TargetDS.ID;
          q.ParamByName('xid').AsInteger := SourceDS.FieldByName('_XID').AsInteger;
          q.ParamByName('dbid').AsInteger := SourceDS.FieldByName('_DBID').AsInteger;
          q.ParamByName('modified').AsDateTime := SourceDS.FieldByName('_MODIFIED').AsDateTime;
          q.ExecQuery;
          *)
        end;
      finally
        q.Free;
      end;
    end;
  end;

var
  CDS: TClientDataSet;
  I, D, P: Integer;
  q: TIBSQL;
  Obj: TgdcBase;
  C: TClass;
  IDMappingCreated: Boolean;
  LoadClassName, LoadSubType: String;
  MS: TMemoryStream;
  ULCreated: Boolean;
  Modified: TDateTime;
  DidActivate: Boolean;
begin
  CheckBrowseMode;

  Assert(IBLogin <> nil);
  Assert(atDatabase <> nil);
  Assert(ObjectSet <> nil);

  if IDMapping = nil then
  begin
    IDMapping := TgdKeyIntAssoc.Create;
    IDMappingCreated := True;
  end else
    IDMappingCreated := False;

  if UpdateList = nil then
  begin
    UpdateList := TObjectList.Create(True);
    ULCreated := True;
  end else
    ULCreated := False;

  try
    while Stream.Position < Stream.Size do
    begin
      P := Stream.Position;

      // проверим тот ли поток нам подсунули для считывания из
      Stream.Read(I, SizeOf(I));
      if I <> $55443322 then
        raise EgdcBase.CreateObj('Invalid stream format', Self);

      // загружаем класс и подтип сохраненного объекта
      LoadClassName := StreamReadString(Stream);
      LoadSubType := StreamReadString(Stream);

      C := GetClass(LoadClassName);
      if C = nil then
        raise EgdcBase.CreateObj('Invalid class name', Self);

      if (C <> Self.ClassType) or (LoadSubType <> SubType) then
      begin
        // тип считываемого объекта не соответствует типу объекта
        // вернем состояние потока в исходное, создадим
        // объект нужного типа и вызовем его метод загрузки из
        // потока
        Stream.Position := P;

        Obj := CgdcBase(C).CreateWithParams(nil,
          Database, Transaction, LoadSubType);
        try
          Obj.Open;
          Obj._LoadFromStream(Stream, IDMapping, ObjectSet, UpdateList);
          Obj.Close;
        finally
          Obj.Free;
        end;
      end else
      begin
        CDS := TClientDataSet.Create(nil);
        try
          Stream.Read(I, SizeOf(I));
          MS := TMemoryStream.Create;
          try
            MS.CopyFrom(Stream, I);
            MS.Position := 0;
            CDS.LoadFromStream(MS);
          finally
            MS.Free;
          end;

          CDS.Open;

          DidActivate := False;
          q := TIBSQL.Create(nil);
          try
            q.Database := Database;
            q.Transaction := Transaction;
            DidActivate := ActivateTransaction;

            q.SQL.Text := 'SELECT * FROM gd_ruid WHERE xid=:xid AND dbid=:dbid';
            q.Prepare;
            q.ParamByName('xid').AsInteger := CDS.FieldByName('_XID').AsInteger;
            q.ParamByName('dbid').AsInteger := CDS.FieldByName('_DBID').AsInteger;
            q.ExecQuery;

            if q.EOF then
            begin
              InsertRecord(CDS, Self, UpdateList);
            end else
            begin
              Modified := q.FieldByName('modified').AsDateTime;
              D := q.FieldByName('id').AsInteger;

              q.Close;
              q.SQL.Text := Format('SELECT * FROM %s WHERE %s=:id', [GetListTable(SubType), GetKeyField(SubType)]);
              q.Prepare;
              q.ParamByName('id').AsInteger := D;
              q.ExecQuery;

              if q.EOF then
              begin
                q.Close;
                q.SQL.Text := 'DELETE FROM gd_ruid WHERE xid=:xid AND dbid=:dbid';
                q.Prepare;
                q.ParamByName('xid').AsInteger := CDS.FieldByName('_XID').AsInteger;
                q.ParamByName('dbid').AsInteger := CDS.FieldByName('_DBID').AsInteger;
                q.ExecQuery;

                InsertRecord(CDS, Self, UpdateList);
              end else
              begin
                if Modified < CDS.FieldByName('_modified').AsDateTime then
                begin
                  Obj := CreateSingularByID(nil, Database, Transaction,
                    q.FieldByName(GetKeyField(SubType)).AsInteger, SubType);
                  try
                    Obj.Edit;
                    if CopyRecord(CDS, Obj, UpdateList) then
                    begin
                      q.Close;
                      q.SQL.Text := 'UPDATE gd_ruid SET modified=:modified WHERE xid=:xid AND dbid=:dbid';
                      q.Prepare;
                      q.ParamByName('xid').AsInteger := CDS.FieldByName('_XID').AsInteger;
                      q.ParamByName('dbid').AsInteger := CDS.FieldByName('_DBID').AsInteger;
                      q.ParamByName('modified').AsDateTime := CDS.FieldByName('_MODIFIED').AsDateTime;
                      q.ExecQuery;
                    end;

                    Obj.Close;
                  finally
                    Obj.Free;
                  end;
                end else
                begin
                  IDMapping.ValuesByIndex[
                    IDMapping.Add(CDS.FieldByName(GetKeyField(SubType)).AsInteger)] :=
                    q.FieldByName(GetKeyField(SubType)).AsInteger;
                end;
              end;
            end;
          finally
            q.Free;

            if DidActivate then
              Transaction.Commit;

          end;
        finally
          CDS.Free;
        end;
      end;
    end;
  finally
    if IDMappingCreated then
      IDMapping.Free;

    if ULCreated then
      UpdateList.Free;
  end;
end;

procedure TgdcBase.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  if (Operation = opRemove) and (AComponent <> nil) then
  begin
    if AComponent = FInternalTransaction then
      FInternalTransaction := nil
    else if AComponent = MasterSource then
      MasterSource := nil
    else if AComponent = ReadTransaction then
      ReadTransaction := nil
    else if AComponent is TgdcBase then
      RemoveDetailLink(AComponent as TgdcBase);
  end;
  inherited;
end;

function TgdcBase.ParamByName(Idx: String): TIBXSQLVAR;
begin
  InternalPrepare;
  Result := QSelect.ParamByName(Idx);
end;

function TgdcBase.PasteFromClipboard: Boolean;
var
  H: THandle;
  P: PgdcClipboardData;
begin
  Result := False;

  if not Clipboard.HasFormat(gdcClipboardFormat) then
    exit;

  H := Clipboard.GetAsHandle(gdcClipboardFormat);
  if H <> 0 then
  begin
    P := GlobalLock(H);
    try
      if (P <> nil)
        and (P^.Signature = gdcCurrentClipboardSignature)
        and (P^.Version = gdcCurrentClipboardVersion)
        and (GetClass(P^.ClassName) <> nil)
        and (gdcObjectList.IndexOf(P^.Obj) <> -1)
      then begin
        Result := AcceptClipboard(P);
      end;
    finally
      GlobalUnlock(H);
    end;
  end;

  {if Result and Transaction.InTransaction then
    Commit(ctRetainingReopen);}
end;

class procedure TgdcBase.RefreshStats;
begin
  //...
end;

procedure TgdcBase.ResetAllAggs(AnActive: Boolean);
begin

end;

{procedure TgdcBase.Rollback(const AType: TgsCommitType);
begin
  if (not (sView in BaseState)) or
    (sDialog in BaseState) or
    (MessageBox(ParentHandle, 'Отменить изменения в базе?', 'Внимание!',
      MB_YESNO + MB_ICONQUESTION) = IDYES)
  then
    _CommitRollback(False, AType);
end;}

(*

  Сохранение сделаем следующим образом:
  1. создадим клиент датасет, взяв определение колонок из
     нашего датасета
  2. перенесем в него данные
  3. сохраним в поток

*)
procedure TgdcBase._SaveToStream(Stream: TStream; ObjectSet: TgdcObjectSet);

  procedure StreamWriteString(St: TStream; const S: String);
  var
    L: Integer;
  begin
    L := Length(S);
    St.Write(L, SizeOf(L));
    if L > 0 then
      St.Write(S[1], L);
  end;

  procedure SaveBindedObjectsForTable(const ATableName: String; ReversedList: TgdcObjectSets);
  var
    R: TatRelation;
    I: Integer;
    Obj: TgdcBase;
    C: TgdcFullClass;
    OS: TgdcObjectSet;
  begin
    Assert(Assigned(ReversedList));

    // найдем все поля ссылки и запишем в поток
    // объекты на которые они ссылаются
    R := atDatabase.Relations.ByRelationName(ATableName);
    Assert(R <> nil);

    for I := 0 to R.RelationFields.Count - 1 do
    begin
      if (FindField(R.RelationName, R.RelationFields[I].FieldName) = nil) or
          (FieldByName(R.RelationName, R.RelationFields[I].FieldName).IsNull) then
        continue;

      if R.RelationFields[I].gdClass <> nil then
      begin
        C.gdClass := CgdcBase(R.RelationFields[I].gdClass);
        C.SubType := R.RelationFields[I].gdSubType;
      end else
      begin
        C.gdClass := nil;
        C.SubType := '';
      end;

      if (C.gdClass = nil) and (R.RelationFields[I].References <> nil) then
        C := GetBaseClassForRelation(R.RelationFields[I].References.RelationName, ReadTransaction);

// смысл второго условия, недопустить зацикливания, когда в записи есть поле-ссылка
// на эту же запись
      if (C.gdClass <> nil) and
        ((C.gdClass <> Self.ClassType) or (FieldByName(R.RelationName, R.RelationFields[I].FieldName).AsInteger <> ID)) then
      begin
        if IsReverseOrder(FieldByName(R.RelationName, R.RelationFields[I].FieldName).FieldName) then
        begin
          OS := ReversedList.Find(C);
          if OS = nil then
          begin
            OS := TgdcObjectSet.Create(C.gdClass, C.SubType);
            ReversedList.Add(OS);
          end;
          OS.Add(FieldByName(R.RelationName, R.RelationFields[I].FieldName).AsInteger);
        end else begin
          Obj := C.gdClass.CreateSingularByID(nil,
              Database,
              Transaction,
              FieldByName(R.RelationName, R.RelationFields[I].FieldName).AsInteger,
              C.SubType);
          try
            Obj._SaveToStream(Stream, ObjectSet);
          finally
            Obj.Free;
          end;
        end;
      end;
    end;
  end;

var
  CDS: TClientDataSet;
  I, J, K: Integer;
  q: TIBSQL;
  RUID: TRUID;
  //Modified: TDateTime;
  C: TgdcFullClass;
  Obj: TgdcBase;
  MS: TMemoryStream;
  ObjectSetCreated: Boolean;
  OL, DL: TObjectList;
  ReversedList: TgdcObjectSets;
  DidActivate: Boolean;
  {$IFDEF DEBUG}Ch: array[0..255] of Char;{$ENDIF}
begin
  CheckBrowseMode;

  Assert(IBLogin <> nil);
  Assert(atDatabase <> nil);
  Assert(not EOF);

  // если объект с заданным ИД уже сохранен в потоке,
  // то выходим, ничего не делая
  if (ObjectSet <> nil) and (ObjectSet.Find(ID) <> -1) then
    exit;

  if ObjectSet = nil then
  begin
    ObjectSet := TgdcObjectSet.Create(TgdcBase, '');
    ObjectSetCreated := True;
  end else
    ObjectSetCreated := False;

  ReversedList := TgdcObjectSets.Create;
  try
    // если текущая запись репрезентует объект другого
    // класса, то создадим экземпляр и вызовем его метод
    // сохранения в потоке
    C := GetCurrRecordClass;

    if (Self.ClassType <> C.gdClass) or (Self.SubType <> C.SubType) then
    begin
      try
        Obj := C.gdClass.CreateSingularByID(nil,
          Database, Transaction, ID, C.SubType);
        try
          Obj._SaveToStream(Stream, ObjectSet);
        finally
          Obj.Free;
        end;
      except
        on E: Exception do
        begin
          if not (E is EAbort) then
            MessageBox(ParentHandle,
              PChar(Format('Нарушена целостность данных. '#13#10# +
              'Предполагаемая информация о типе объекта'#13#10# +
              'c идентификатором %d: %s (подтип: "%s")'#13#10# +
              'не соответствует действительности.'#13#10#13#10 +
              'Объект не будет сохранен.', [ID, C.gdClass.ClassName, C.SubType])),
              'Ошибка',
              MB_OK or MB_ICONEXCLAMATION);
        end;
      end;
    end else
    begin
      {$IFDEF DEBUG}
      StrPCopy(Ch, ClassName + ' ' + IntToStr(GetTickCount));
      OutputDebugString(Ch);
      {$ENDIF}

      // для избежания рекурсивного сохранения пометим
      // что мы начали сохранять объект с текущим идентификатором
      ObjectSet.Add(ID);

      // сохраним все объекты на которые есть ссылки из
      // главной таблицы текущего объекта
      SaveBindedObjectsForTable(GetListTable(SubType), ReversedList);

      // теперь найдем все таблицы, первичный ключ которых одновременно
      // является ссылкой на нашу запись, т.е. таблицы связанные
      // жесткой связью один-к-одному с нашей таблицей
      // записи в таких таблицах, в совокупности с записью в главной
      // таблице, представляют данные одного объекта
      // пример: gd_contact -- gd_company -- gd_companycode
      OL := TObjectList.Create(False);
      try
        atDatabase.ForeignKeys.ConstraintsByReferencedRelation(
          GetListTable(SubType), OL);
        for I := 0 to OL.Count - 1 do
          with OL[I] as TatForeignKey do
        begin
          if IsSimpleKey
            and (Relation.PrimaryKey <> nil)
            and (Relation.PrimaryKey.ConstraintFields.Count = 1)
            and (ConstraintField = Relation.PrimaryKey.ConstraintFields[0]) then
          begin
            SaveBindedObjectsForTable(Relation.RelationName, ReversedList);
          end;
        end;
      finally
        OL.Free;
      end;

      // проверим был ли сформирован РУИД для сохраняемого
      // объекта
      DidActivate := False;
      q := TIBSQL.Create(nil);
      try
        q.Database := Database;
        q.Transaction := Transaction;

        DidActivate := ActivateTransaction;

        q.SQL.Text := 'SELECT * FROM gd_ruid WHERE id=:id';
        q.Prepare;
        q.ParamByName('id').AsInteger := ID;
        q.ExecQuery;

        if q.EOF then
        begin
          // если нет, то сформируем РУИД и занесем его в базу
          RUID.XID := ID;
          RUID.DBID := IBLogin.DBID;
          q.Close;
          q.SQL.Text := 'INSERT INTO gd_ruid VALUES (:id, :xid, :dbid, :modified, :editorkey)';
          q.Prepare;
          q.ParamByName('id').AsInteger := ID;
          q.ParamByName('xid').AsInteger := RUID.XID;
          q.ParamByName('dbid').AsInteger := RUID.DBID;
          q.ParamByName('modified').AsDateTime := EditionDate;
          if Assigned(IBLogin) then
            q.ParamByName('editorkey').AsInteger := IBLogin.ContactKey
          else
            q.ParamByName('editorkey').Clear;
          q.ExecQuery;
        end else
        begin
          // если у объекта уже есть РУИД, то прочитаем
          // его из базы
          RUID.XID := q.FieldByName('xid').AsInteger;
          RUID.DBID := q.FieldByName('dbid').AsInteger;
        end;
      finally
        if DidActivate then
          Transaction.Commit;

        q.Free;
      end;

      CDS := TClientDataSet.Create(nil);
      try
        for I := 0 to FieldDefs.Count - 1 do
        begin
          if (not (DB.faReadOnly in FieldDefs[I].Attributes))
            and (not FieldDefs[I].InternalCalcField)
            and (not FieldByName(FieldDefs[I].Name).IsNull) then
          begin
            CDS.FieldDefs.Add(FieldDefs[I].Name, FieldDefs[I].DataType,
              FieldDefs[I].Size, FieldDefs[I].Required);
          end;
        end;

        CDS.FieldDefs.Add('_XID', ftInteger, 0, True);
        CDS.FieldDefs.Add('_DBID', ftInteger, 0, True);
        CDS.FieldDefs.Add('_MODIFIED', ftDateTime, 0, True);

        CDS.CreateDataSet;

        CDS.Insert;
        for K := 0 to FieldCount - 1 do
          if CDS.FindField(Fields[K].FieldName) <> nil then
            CDS.FieldByName(Fields[K].FieldName).Assign(Fields[K]);
        CDS.FieldByName('_XID').AsInteger := RUID.XID;
        CDS.FieldByName('_DBID').AsInteger := RUID.DBID;
        CDS.FieldByName('_MODIFIED').AsDateTime := EditionDate;
        CDS.Post;

        // запишем метку потока, чтобы потом знать то ли
        // нам подсунули для считывания
        I := $55443322;
        Stream.Write(I, SizeOf(I));

        StreamWriteString(Stream, ClassName);
        StreamWriteString(Stream, SubType);

        MS := TMemoryStream.Create;
        try
          CDS.SaveToStream(MS);
          I := MS.Size;
          Stream.Write(I, SizeOf(I));
          Stream.CopyFrom(MS, 0);
        finally
          MS.Free;
        end;
      finally
        CDS.Free;
      end;

      for I := 0 to ReversedList.Count - 1 do
      begin
        for J := 0 to (ReversedList[I] as TgdcObjectSet).Count - 1 do
        begin
          Obj := (ReversedList[I] as TgdcObjectSet).gdClass.CreateSingularByID(nil,
            Database, Transaction,
            (ReversedList[I] as TgdcObjectSet).Items[J],
            (ReversedList[I] as TgdcObjectSet).SubType);
          try
            Obj._SaveToStream(Stream, ObjectSet);
          finally
            Obj.Free;
          end;
        end;
      end;

      // теперь надо сохранить все детальные объекты
      // детальный объект мы создаем следующим образом:
      // 1. строим список фореин ключей, ссылающихся на нашу таблицу
      // 2. из списка берем только те ключи, которые состоят из
      //    одного поля и тип домена которых
      //    DMASTERKEY
      // 3. находим базовые классы для таблиц, для которых
      //    созданы эти ключи
      // 4. создаем экземпляры объектов по найденным классам
      // 5. устанавливаем дополнительное условие: ссылка на
      //    мастер запись
      // 6. открываем датасет с примененным условием
      // 7. сохраняем все его записи в потоке
      DL := TObjectList.Create(False);
      try
        atDatabase.ForeignKeys.ConstraintsByReferencedRelation(
          GetListTable(SubType), DL);
        for I := 0 to DL.Count - 1 do
          with DL[I] as TatForeignKey do
        begin
          if IsSimpleKey and (ConstraintField.Field.FieldName = 'DMASTERKEY') then
          begin
            C := GetBaseClassForRelation(Relation.RelationName, ReadTransaction);
            if C.gdClass <> nil then
            begin
              Obj := C.gdClass.Create(nil);
              try
                Obj.Database := Database;
                Obj.Transaction := Transaction;
                Obj.SubType := C.SubType;
                Obj.ExtraConditions.Add(
                  Obj.GetListTableAlias + '.' +
                  ConstraintField.FieldName + '=' +
                  FieldByName(ReferencesRelation.RelationName, ReferencesFields[0].FieldName).AsString);
                Obj.Open;
                while not Obj.EOF do
                begin
                  Obj._SaveToStream(Stream, ObjectSet);
                  Obj.Next;
                end;
                Obj.Close;
              finally
                Obj.Free;
              end;
            end;
          end;
        end;
      finally
        DL.Free;
      end;
    end;
  finally
    ReversedList.Free;

    if ObjectSetCreated then
      ObjectSet.Free;
  end;
end;

procedure TgdcBase.SetAggregatesActive(const Value: Boolean);
begin
  FAggregatesActive := Value;
end;

procedure TgdcBase.SetDetailField(const Value: String);
begin
  if FgdcDataLink <> nil then
    FgdcDataLink.DetailField := Value;
end;

procedure TgdcBase.SetID(const Value: Integer);
var
  WasActive: Boolean;
begin
  Assert(Value >= -1, 'Invalid id');
  FID := Value;
  if FID = -1 then Close else
  begin
    if State in dsEditModes then
      FieldByName(GetKeyField(SubType)).AsInteger := FID else
    if HasSubSet('ByID') then
    begin
      WasActive := Active;
      Close;
      ParamByName(GetKeyField(SubType)).AsInteger := FID;
      Active := WasActive;

{ TODO :
при открытии с несуществующим ИД теперь
просто откроет пустой датасет. Надо проверить весь код
который мог от этого зависеть. }

      //if EOF then raise EgdcBase.CreateObj('Invalid id specified', Self);
    end else
      if Active and (not Locate(GetKeyField(SubType), Value, [])) then
        raise EgdcBase.CreateObj('Invalid id specified', Self);
  end;
end;

procedure TgdcBase.SetMasterField(const Value: String);
begin
  if FgdcDataLink <> nil then
    FgdcDataLink.MasterField := Value;
end;

procedure TgdcBase.SetMasterSource(Value: TDataSource);
begin
  if IsLinkedTo(Value) then
    IBError(ibxeCircularReference, [nil]);

  if (FgdcDataLink <> nil) and (MasterSource <> Value) then
  begin
    if FgdcDataLink.DataSet is TgdcBase then
      (FgdcDataLink.DataSet as TgdcBase).RemoveDetailLink(Self);
    FgdcDataLink.DataSource := Value;
    FgdcDataLink.FLinkEstablished := False;
  end;
end;

class function TgdcBase.TestRightForOp(const AnOp: TgdcOperations): Boolean;
begin
{ TODO :
!!!!
для тестирования даем полный доступ! }
  (*
  Result := False;
  if opAccess in AnOp then
    if not gdOperationList.Test(GetOperationFolderID + GDC_OP_ACCESS) then exit else
  else if opCreate in AnOp then
    if not gdOperationList.Test(GetOperationFolderID + GDC_OP_CREATE) then exit else
  else if opChange in AnOp then
    if not gdOperationList.Test(GetOperationFolderID + GDC_OP_CHANGE) then exit else
  else if opDelete in AnOp then
    if not gdOperationList.Test(GetOperationFolderID + GDC_OP_DELETE) then exit else
  else if opPrint in AnOp then
    if not gdOperationList.Test(GetOperationFolderID + GDC_OP_PRINT) then exit else
  else if opChangeRight in AnOp then
    if not gdOperationList.Test(GetOperationFolderID + GDC_OP_CHANGERIGHT) then exit;
  *)
  Result := True;
end;

{ TgdcDataLink }

procedure TgdcDataLink.ActiveChanged;
begin
  FTimer.Enabled := False;
  if DataSet = nil then
    FLinkEstablished := False
  else if (FMasterField.Count > 0) and (FDetailField.Count > 0) then
    if not DataSet.Active then
      FDetailObject.Close
    else begin
      if not FLinkEstablished then
      begin
        if (DataSet is TIBCustomDataSet) then
        begin
          if (FDetailObject.Transaction = nil) or (FDetailObject.Transaction = FDetailObject.FInternalTransaction) then
            FDetailObject.Transaction := (DataSet as TIBCustomDataSet).Transaction;

          if (FDetailObject.ReadTransaction = nil) or (FDetailObject.ReadTransaction <> (DataSet as TIBCustomDataSet).ReadTransaction) then
            FDetailObject.ReadTransaction := (DataSet as TIBCustomDataSet).ReadTransaction;
        end;

        if DataSet is TgdcBase then
          (DataSet as TgdcBase).AddDetailLink(FDetailObject);

        FLinkEstablished := True;
      end;

      if FDetailObject.Active then
        FDetailObject.RefreshParams
      else
        FDetailObject.Open;
    end;
end;

procedure TgdcDataLink.CheckBrowseMode;
begin
  {if FDetailObject.Active then
    FDetailObject.CheckBrowseMode;}
end;

constructor TgdcDataLink.Create(ADetailObject: TgdcBase);
begin
  inherited Create;
  FDetailObject := ADetailObject;
  FTimer := TTimer.Create(nil);
  FTimer.Enabled := False;
  FTimer.Interval := 0; {60}
  FTimer.OnTimer := DoOnTimer;
  FMasterField := TStringList.Create;
  FDetailField := TStringList.Create;
  FLinkEstablished := False;
end;

destructor TgdcDataLink.Destroy;
begin
  FTimer.Free;
  if DataSet is TgdcBase then
    (DataSet as TgdcBase).RemoveDetailLink(FDetailObject);
  FDetailObject.FgdcDataLink := nil;
  FMasterField.Free;
  FDetailField.Free;
  inherited;
end;

procedure TgdcDataLink.DoOnTimer(Sender: TObject);
begin
  if FTimer.Enabled then
  begin
    FTimer.Enabled := False;
    if FDetailObject.Active then
      FDetailObject.RefreshParams;
  end;
end;

procedure TgdcDataLink.EditingChanged;
begin
  FTimer.Enabled := False;
  if DataSet.State in dsEditModes then
    if FDetailObject.State in dsEditModes then
      FDetailObject.Post;
end;

function TgdcDataLink.GetDetailField: String;
begin
  Result := StringReplace(FDetailField.CommaText, ',', ';', [rfReplaceAll]);
end;

function TgdcDataLink.GetMasterField: String;
begin
  Result := StringReplace(FMasterField.CommaText, ',', ';', [rfReplaceAll]);
end;

procedure TgdcDataLink.RecordChanged(F: TField);
begin
  if (F = nil) and FDetailObject.Active then
  begin
    if (FTimer.Interval = 0) or (not (sView in FDetailObject.BaseState)) then
      FDetailObject.RefreshParams
    else begin
      FTimer.Enabled := False;
      FTimer.Enabled := True;
    end;
  end;
end;

(*procedure TgdcDataLink.RefreshParams(const AnyWay: Boolean);
var
  Master, Detail: TStringList;
  I: Integer;
  ParamsChanged: Boolean;

begin
  if (DataSet = nil)
    or (not DataSet.Active)
    or (FDetailObject = nil)
    {or (not FgdcObject.Active)} then exit;

  Master := TStringList.Create;
  Detail := TStringList.Create;

  //FgdcObject.DisableControls;
  try
    MakeFieldList(FMasterField, Master);
    MakeFieldList(FDetailField, Detail);

    ParamsChanged := False;

    if not AnyWay then
      for I := 0 to Master.Count - 1 do
        if DataSet.FieldByName(Master[I]).AsString <>
          FDetailObject.ParamByName(Detail[I]).AsString then
        begin
          ParamsChanged := True;
          Break;
        end;

    if AnyWay or ParamsChanged then
    begin
      FDetailObject.Close;

      //
      // Присваиваем соответствующее подключение
      //  и транзакцию

      { TODO :
тут вопрос. правильнее все эти манипуляции с транзакциями делать
по присваиванию мастер обжекта а не тут... }
      {if not Assigned(FgdcObject.Transaction) and (DataSet is TgdcBase) then
        FgdcObject.Transaction := (DataSet as TgdcBase).Transaction else

      if (DataSet is TgdcBase) and
        (FgdcObject.Transaction = FgdcObject.FInternalTransaction) then
      begin
        FreeAndNil(FgdcObject.FInternalTransaction);
        FgdcObject.Transaction := (DataSet as TgdcBase).Transaction;
      end;

      if not Assigned(FgdcObject.Database) and (DataSet is TgdcBase) then
        FgdcObject.Database := (DataSet as TgdcBase).Database;}

      //
      // Устанавливаем параметры

      for I := 0 to Master.Count - 1 do
        if not DataSet.FieldByName(Master[I]).IsNull then
          FDetailObject.ParamByName(Detail[I]).AsString :=
              DataSet.FieldByName(Master[I]).AsString
        else
          FDetailObject.ParamByName(Detail[I]).Clear;

      FDetailObject.Open;
    end;
  finally
    Master.Free;
    Detail.Free;

    //FgdcObject.EnableControls;
  end;
end;*)

procedure TgdcDataLink.SetDetailField(const Value: String);
begin
  FDetailField.CommaText := StringReplace(Value, ';', ',', [rfReplaceAll]);
end;

procedure TgdcDataLink.SetMasterField(const Value: String);
begin
  FMasterField.CommaText := StringReplace(Value, ';', ',', [rfReplaceAll]);
end;

{ TgdcAggregate }

constructor TgdcAggregate.Create(AnAggregates: TgdcAggregates;
  ADataSet: TgdcBase);
begin
  FDataSet := ADataSet;
  inherited Create(AnAggregates);
end;

destructor TgdcAggregate.Destroy;
begin
  inherited;

end;

function TgdcAggregate.GetDisplayName: String;
begin
  Result := FAggregateName;
  if Result = '' then Result := Expression;
  if Result = '' then Result := inherited GetDisplayName;
end;

procedure TgdcAggregate.SetActive(const Value: Boolean);
begin
  FActive := Value;
end;

procedure TgdcAggregate.SetExpression(const Value: String);
begin
  FExpression := Value;
end;

procedure TgdcAggregate.SetIndexName(const Value: String);
begin
  FIndexName := Value;
end;

procedure TgdcAggregate.SetVisible(const Value: Boolean);
begin
  FVisible := Value;
end;

function TgdcAggregate.Value: Variant;
begin
  Result := Null;
end;

{ TgdcAggregates }

function TgdcAggregates.Add: TgdcAggregate;
begin
  Result := TgdcAggregate(inherited Add);
  Result.FDataSet := TgdcBase(GetOwner);
end;

procedure TgdcAggregates.Clear;
var
  DataSet: TgdcBase;
begin
  inherited Clear;
  DataSet := TgdcBase(GetOwner);
  if DataSet <> nil then
    DataSet.ResetAllAggs(DataSet.AggregatesActive);
end;

constructor TgdcAggregates.Create(Owner: TPersistent);
begin
  inherited Create(TgdcAggregate);
  FOwner := Owner;
end;

function TgdcAggregates.Find(const DisplayName: string): TgdcAggregate;
var
  I: Integer;
begin
  I := IndexOf(DisplayName);
  if I < 0 then Result := nil else Result := TgdcAggregate(Items[I]);
end;

function TgdcAggregates.GetItem(Index: Integer): TgdcAggregate;
begin
  Result := TgdcAggregate(inherited GetItem(Index));
end;

function TgdcAggregates.GetOwner: TPersistent;
begin
  Result := FOwner;
end;

function TgdcAggregates.IndexOf(const DisplayName: string): Integer;
begin
  for Result := 0 to Count - 1 do
    if AnsiCompareText(TgdcAggregate(Items[Result]).DisplayName, DisplayName) = 0 then Exit;
  Result := -1;
end;

procedure TgdcAggregates.SetItem(Index: Integer;
  const Value: TgdcAggregate);
begin
  inherited SetItem(Index, Value);
end;

{ TgdcBaseManager }

constructor TgdcBaseManager.Create(AnOwner: TComponent);
begin
  Assert(gdcBaseManager = nil, 'Only one instance of gdcBaseManager is allowed');
  inherited Create(AnOwner);
  FIBBase := TIBBase.Create(Self);
  FReadTransaction := TIBTransaction.Create(nil);
  FReadTransaction.Params.Text := 'read_committed'#13#10'rec_version'#13#10'nowait'#13#10'read'#13#10;
  FReadTransaction.Name := 'InternalRead';
  FReadTransaction.AutoStopAction := saNone;
  gdcBaseManager := Self;
end;

destructor TgdcBaseManager.Destroy;
begin
  gdcBaseManager := nil;
  if Assigned(FReadTransaction) and FReadTransaction.InTransaction then
    FReadTransaction.Commit;

  FreeAndNil(FReadTransaction);
  FreeAndNil(FIBBase);
  inherited;
end;

function TgdcBaseManager.GetDatabase: TIBDatabase;
begin
  if Assigned(FIBBase) then
    Result := FIBBase.Database
  else
    Result := nil;
end;

function TgdcBaseManager.GetReadTransaction: TIBTransaction;
begin
  Result := FReadTransaction;
end;

{procedure TgdcBaseManager.InitObjects;
var
  I: Integer;
begin
  for I := 0 to gdcObjectList.Count - 1 do
    if (gdcObjectList[I] as TgdcBase).State in [dsInactive] then
      (gdcObjectList[I] as TgdcBase).Database := Database;
end;}

procedure TgdcBaseManager.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = Database) then
    Database := nil;
  if (Operation = opRemove) and (AComponent = FReadTransaction) then
    raise Exception.Create(GetGsException(Self, 'Cannot delete global read transaction'));
end;

procedure TgdcBaseManager.SetDatabase(const Value: TIBDatabase);
begin
  if (Database <> Value) and Assigned(FIBBase) and Assigned(FReadTransaction) then
  begin
    FIBBase.Database := Value;
    FReadTransaction.DefaultDatabase := Value;
    //InitObjects;
  end;
end;

class function TgdcBase.CreateViewForm(AnOwner: TComponent;
  const AClassName: String = ''; const ASubType: String = ''): TForm;
var
  C: TPersistentClass;
begin
  C := GetClass(AClassName);
  if C = nil then
    C := FindClass(GetViewFormClassName(ASubType));
  if (C <> nil) and C.InheritsFrom(TgdcCreateableForm) then
  begin
    if ASubType = '' then
    begin
//      if AUseExisting then
        Result := CgdcCreateableForm(C).CreateAndAssign(AnOwner)
//      else
//        Result := CCreateableForm(C).Create(AnOwner);
    end else
      Result := CgdcCreateableForm(C).CreateSubType(AnOwner, ASubType)
//    Tgdc_frmG(Result).Setup(nil);
  end else
  begin
    Result := nil;
  end;
end;

procedure TgdcBase.SetFindWhereSQL(const Value: String);
var
  WasActive: Boolean;
begin
  if FFindWhereSQL <> Value then
  begin
    WasActive := Active;
    Close;
    FFindWhereSQL := Value;
    FSQLInitialized := False;
    //InitSQL;
    Active := WasActive;
  end;
end;

procedure TgdcBase.SetSubSet(const Value: TgdcSubSet);
var
  I: Integer;
begin
  if not (csLoading in ComponentState) then
    Close;
  if (csDesigning in ComponentState) then
    FSubSets.CommaText := Value
  else if SubSet <> Value then
  begin
    FSubSets.CommaText := Value;
    if FSubSets.Count = 0 then
      raise EgdcBase.CreateObj(Format('Invalid subset "%s" specified.', [Value]), Self);
    for I := 0 to FSubSets.Count - 1 do
      if not CheckSubSet(FSubSets[I]) then
        raise EgdcBase.CreateObj(Format('Invalid subset "%s" specified.', [Value]), Self);
    UniDirectional := HasSubSet('ByID');
    if HasSubSet('All') then
      BufferChunks := 1000
    else if HasSubSet('ByName') then
      BufferChunks := 10
    else
      BufferChunks := 100;
    FSQLInitialized := False;
    //InitSQL;
  end;
end;

function TgdcBase.CheckSubSet(const ASubSet: String): Boolean;
begin
  Result := Pos(';' + ASubSet + ';', ';' + GetSubSetList) > 0;
end;

// Слияние
function TgdcBase.Reduction: Boolean;
var
  FgsDBReduction: TgsDBReductionWizard;
  C: TClass;
  S: String;
  DidActivate: Boolean;
begin
  DidActivate := False;
  FgsDBReduction := TgsDBReductionWizard.Create(Self);
  try
    DidActivate := ActivateTransaction;
    if not Assigned(FgsDBReduction) then
      FgsDBReduction := TgsDBReductionWizard.Create(Self);

    FgsDBReduction.Database := DataBase;
    FgsDBReduction.Transaction := Transaction;

//    FgsDBReduction.Table := GetListTable(SubType);
    FgsDBReduction.Table := GetReductionTable;
    FgsDBReduction.MainTable := GetListTable(SubType);
    FgsDBReduction.KeyField := GetKeyField(SubType);
    FgsDBReduction.ListField := GetListField(SubType);
    FgsDBReduction.CondemnedKey := IntToStr(ID);
    FgsDBReduction.AddCondition := GetReductionCondition;

    C := GetCurrRecordClass.gdClass;

    if C <> nil then
      S := C.ClassName
    else
      S := '';

    Result := FgsDBReduction.Wizard(S, SubType);
  finally
    if DidActivate then
      Transaction.Commit;
    FgsDBReduction.Free;
  end;
end;

function TgdcBase.GetCurrRecordClass: TgdcFullClass;
begin
  Result.gdClass := CgdcBase(Self.ClassType);
  Result.SubType := SubType;
end;

function TgdcBase.GetFindFieldList: String;
begin
  Result := 'Name';
end;

function TgdcBase.GetNameInScript: String;
begin
  if FNameInScript > '' then
    Result := FNameInScript
  else
    Result := Name;
end;

function TgdcBase.CreateDescendant: Boolean;
begin
  Result := CreateDialog(QueryDescendant);
end;

function TgdcBase.CreateDialog(C: CgdcBase): Boolean;
begin
  Result := CreateDialog(MakeFullClass(C, ''));
end;

function TgdcBase.CreateDialog(C: TgdcFullClass): Boolean;
var
  Obj: TgdcBase;
  I: Integer;
  F: TField;
begin
  if C.gdClass <> nil then
  begin
    CheckClass(C.gdClass);
    if (C.gdClass = Self.ClassType) and (C.SubType = SubType) then
      Result := CreateDialog
    else begin
      Obj := C.gdClass.CreateWithParams(Owner, Database, Transaction, C.SubType, 'ByID');
      try
        // обязательно надо сохранить мастера!
        //Obj.MasterField := MasterField;
        //Obj.DetailField := DetailField;
        Obj.MasterSource := MasterSource;

        Obj.AfterCancel := AfterCancel;
        Obj.AfterClose := AfterClose;
        Obj.AfterDelete := AfterDelete;
        Obj.AfterEdit := AfterEdit;
        Obj.AfterInsert := AfterInsert;
        Obj.AfterInternalDeleteRecord := AfterInternalDeleteRecord;
        Obj.AfterInternalPostRecord := AfterInternalPostRecord;
        Obj.AfterOpen := AfterOpen;
        Obj.AfterPost := AfterPost;
        Obj.AfterRefresh := AfterRefresh;
        Obj.AfterScroll := AfterScroll;
        Obj.AfterShowDialog := AfterShowDialog;
        Obj.BeforeCancel := BeforeCancel;
        Obj.BeforeClose := BeforeClose;
        Obj.BeforeDelete := BeforeDelete;
        Obj.BeforeEdit := BeforeEdit;
        Obj.BeforeInsert := BeforeInsert;
        Obj.BeforeInternalDeleteRecord := BeforeInternalDeleteRecord;
        Obj.BeforeInternalPostRecord := BeforeInternalPostRecord;
        Obj.BeforeOpen := BeforeOpen;
        Obj.BeforePost := BeforePost;
        Obj.BeforeRefresh := BeforeRefresh;
        Obj.BeforeScroll := BeforeScroll;
        Obj.BeforeShowDialog := BeforeShowDialog;
        Obj.OnCalcFields := OnCalcFields;
        Obj.OnDeleteError := OnDeleteError;
        Obj.OnEditError := OnEditError;
        Obj.OnNewRecord := OnNewRecord;
        Obj.OnPostError := OnPostError;
        Obj.OnUpdateError := OnUpdateError;
        Obj.OnUpdateRecord := OnUpdateRecord;
        try

          //Obj.Assign(Self);

          Result := Obj.CreateDialog;

          if Result and Active and Obj.Active then
          begin
            FDataTransfer := True;

            AfterCancel := nil;
            AfterClose := nil;
            AfterDelete := nil;
            AfterEdit := nil;
            AfterInsert := nil;
            AfterInternalDeleteRecord := nil;
            AfterInternalPostRecord := nil;
            AfterOpen := nil;
            AfterPost := nil;
            AfterRefresh := nil;
            AfterScroll := nil;
            AfterShowDialog := nil;
            BeforeCancel := nil;
            BeforeClose := nil;
            BeforeDelete := nil;
            BeforeEdit := nil;
            BeforeInsert := nil;
            BeforeInternalDeleteRecord := nil;
            BeforeInternalPostRecord := nil;
            BeforeOpen := nil;
            BeforePost := nil;
            BeforeRefresh := nil;
            BeforeScroll := nil;
            BeforeShowDialog := nil;
            OnCalcFields := nil;
            OnDeleteError := nil;
            OnEditError := nil;
            OnNewRecord := nil;
            OnPostError := nil;
            OnUpdateError := nil;
            OnUpdateRecord := nil;

            try
              while not Obj.BOF do
              begin
                Insert;
                for I := 0 to FieldCount - 1 do
                begin
                  F := Obj.FindField(Fields[I].FieldName);
                  if Assigned(F) then
                    Fields[I].Assign(F);
                end;
                Post;
                Obj.Prior;
              end;
            finally
              FDataTransfer := False;
            end;
          end;

        finally  
          AfterCancel := Obj.AfterCancel;
          AfterClose := Obj.AfterClose;
          AfterDelete := Obj.AfterDelete;
          AfterEdit := Obj.AfterEdit;
          AfterInsert := Obj.AfterInsert;
          AfterInternalDeleteRecord := Obj.AfterInternalDeleteRecord;
          AfterInternalPostRecord := Obj.AfterInternalPostRecord;
          AfterOpen := Obj.AfterOpen;
          AfterPost := Obj.AfterPost;
          AfterRefresh := Obj.AfterRefresh;
          AfterScroll := Obj.AfterScroll;
          AfterShowDialog := Obj.AfterShowDialog;
          BeforeCancel := Obj.BeforeCancel;
          BeforeClose := Obj.BeforeClose;
          BeforeDelete := Obj.BeforeDelete;
          BeforeEdit := Obj.BeforeEdit;
          BeforeInsert := Obj.BeforeInsert;
          BeforeInternalDeleteRecord := Obj.BeforeInternalDeleteRecord;
          BeforeInternalPostRecord := Obj.BeforeInternalPostRecord;
          BeforeOpen := Obj.BeforeOpen;
          BeforePost := Obj.BeforePost;
          BeforeRefresh := Obj.BeforeRefresh;
          BeforeScroll := Obj.BeforeScroll;
          BeforeShowDialog := Obj.BeforeShowDialog;
          OnCalcFields := Obj.OnCalcFields;
          OnDeleteError := Obj.OnDeleteError;
          OnEditError := Obj.OnEditError;
          OnNewRecord := Obj.OnNewRecord;
          OnPostError := Obj.OnPostError;
          OnUpdateError := Obj.OnUpdateError;
          OnUpdateRecord := Obj.OnUpdateRecord;
        end;

      finally
        Obj.Free;
      end;
    end;
  end else
    Result := False;
end;


// Вызов списка отчетов
procedure TgdcBase.DoOnReportListClick(Sender: TObject);
begin
  ClientReport.Execute(GroupID);
end;

// Выбор отчета для печати
procedure TgdcBase.DoOnReportClick(Sender: TObject);
begin
  PrintReport((Sender as TMenuItem).Tag);
end;

procedure TgdcBase.PrintReport(const ID: Integer);
begin
  Assert(ClientReport <> nil, 'Не подключен сервер отчетов');
  ClientReport.BuildReport(ID);
end;

procedure TgdcBase.isUse;
var
  I: Integer;
  LI: TListItem;
  atRelation: TatRelation;
  FTableList, FForeignList: TStringList;
  FKeyField: String;
  FTable, FKey: String;
  OL: TObjectList;

  // возвращает первичный ключ для заданной таблицы
  function GetPrimary(const TableName: String): String;
  var
    q: TIBSQL;
  begin
    q := TIBSQL.Create(Self);
    try
      q.Database := DataBase;
      q.Transaction := ReadTransaction;
      q.SQL.Text :=
        ' SELECT ' +
        '   isg1.RDB$FIELD_NAME PrimaryName ' +
        ' FROM ' +
        '   RDB$INDEX_SEGMENTS isg1 ' +
        '   , RDB$RELATION_CONSTRAINTS rc1 ' +
        ' WHERE ' +
        '   rc1.RDB$RELATION_NAME = UPPER(''' + TableName + ''')' +
        '   AND rc1.RDB$INDEX_NAME = isg1.RDB$INDEX_NAME ' +
        '   AND rc1.RDB$CONSTRAINT_TYPE = ''PRIMARY KEY''';
      q.ExecQuery;
      Result := '';
      while not q.Eof do
      begin
        if Result = '' then
          Result := q.FieldByName('PrimaryName').AsTrimString
        else
          raise EgdcBase.CreateObj('gdc.IsUse: Composite primary keys are not supported', Self);
          // Result := Result + ';' + q.FieldByName('PrimaryName').AsTrimString;
        q.Next;
      end;
    finally
      q.Free;
    end;
  end;

  procedure AddTable(TableName: String);
  var
    sql, sqlValue: TIBSQL;
    NewTable, NewPrimary: String;

  begin
    try
      sql := TIBSQL.Create(Self);
      sqlvalue := TIBSQL.Create(Self);
      try
        sql.Database := Database;
        sql.Transaction := ReadTransaction;
        sqlValue.Database := Database;
        sqlValue.Transaction := Transaction;

        sql.sql.Text :=
          ' SELECT ' +
          '     isg2.RDB$FIELD_NAME     TargetField ' +
          '   , rc2.RDB$RELATION_NAME  TargetTable ' +
          ' FROM ' +
          '     RDB$RELATION_CONSTRAINTS rc1 ' +
          '   , RDB$REF_CONSTRAINTS rfc ' +
          '   , RDB$RELATION_CONSTRAINTS rc2 ' +
          '   , RDB$INDEX_SEGMENTS isg2 ' +
          '   , RDB$RELATION_CONSTRAINTS rc3 ' +
          '   , rdb$ref_constraints rrc ' +
          ' WHERE ' +
          '   rc1.RDB$RELATION_NAME = UPPER(''' + TableName + ''')' +
          '   AND rfc.RDB$CONSTRAINT_NAME = rc2.RDB$CONSTRAINT_NAME ' +
          '   AND rfc.RDB$CONST_NAME_UQ = rc1.RDB$CONSTRAINT_NAME ' +
          '   AND rc2.RDB$INDEX_NAME = isg2.RDB$INDEX_NAME ' +
          '   AND rc3.RDB$RELATION_NAME = rc2.RDB$RELATION_NAME ' +
          '   AND rc3.RDB$CONSTRAINT_TYPE = ''PRIMARY KEY''' +
          '   AND rrc.RDB$CONSTRAINT_NAME = rc2.RDB$CONSTRAINT_NAME ' +
          '   AND rrc.RDB$DELETE_RULE = ''RESTRICT'' ' +
          ' ORDER BY ' +
          '   rc2.RDB$RELATION_NAME ';
        sql.ExecQuery;

        NewTable := '';
        while not sql.Eof do
        begin
          try
            if NewTable <> sql.FieldByName('targettable').AsTrimString then
            begin
              NewTable := sql.FieldByName('targettable').AsTrimString;
              NewPrimary := GetPrimary(NewTable);
            end;

            sqlValue.Close;
            sqlValue.sql.Text := 'SELECT ' + sql.FieldByName('TargetField').AsTrimString +
              ' FROM ' + NewTable + ' WHERE ' + sql.FieldByName('TargetField').AsTrimString +
              ' = ' + FKey; //!!!
            sqlValue.ExecQuery;
            if sqlValue.RecordCount > 0 then
            begin
              FTableList.Add(NewTable);
              FForeignList.Add(sql.FieldByName('targetfield').AsTrimString);

              if NewPrimary = sql.FieldByName('targetfield').AsTrimString then
                AddTable(NewTable);
            end;
          except
          end;
          sql.Next;
        end;

      finally
        sql.Free;
        sqlValue.Free;
      end;
    except
    end;
  end;


begin
  FTableList := TStringList.Create;
  FForeignList := TStringList.Create;
  try
    FTable := GetListTable(SubType);
    FKeyField := GetPrimary(FTable);
    FKey := FieldByName(FKeyField).AsString;

    Assert(FKeyField > '', 'У таблицы отсутствует ключевое поле.');
    AddTable(FTable);
//вытягиваем все таблицы, которые имеют с главной таблицей связь 1:1
    OL := TObjectList.Create(False);
    try
      atDatabase.ForeignKeys.ConstraintsByReferencedRelation(
        GetListTable(SubType), OL);
      for I := 0 to OL.Count - 1 do
        with OL[I] as TatForeignKey do
      begin
        if IsSimpleKey
          and (Relation.PrimaryKey <> nil)
          and (Relation.PrimaryKey.ConstraintFields.Count = 1)
          and (ConstraintField = Relation.PrimaryKey.ConstraintFields[0]) then
        begin
          AddTable(Relation.RelationName);
        end;
      end;
    finally
      OL.Free;
    end;


    if FTableList.Count <> 0 then
      with TdlgTableValues.Create(Self) do
      try
        qryValue.DataBase := DataBase;
        qryValue.Transaction := ReadTransaction;
        lvTables.Items.BeginUpdate;
        for I := 0 to FTableList.Count - 1 do
        begin
          LI := lvTables.Items.Add;

          atRelation := atDatabase.Relations.ByRelationName(FTableList.Strings[I]);
          if atRelation <> nil then
            LI.Caption := atRelation.LName
          else
            LI.Caption := FTableList.Strings[I];

          LI.SubItems.Add(FForeignList.Strings[I]);
          LI.SubItems.Add(FTableList.Strings[I]);
        end;
        if lvTables.Items.Count <> 0 then
          lvTables.Items[lvTables.Items.Count - 1].Selected := True;
        lvTables.Items.EndUpdate;

        Key := FKey;
        ShowModal;
      finally
        Free;
      end;
  finally
    FTableList.Free;
    FForeignList.Free;
  end;
end;

procedure TgdcBase.ExecSingleQuery(const S: String);
var
  IBSQL: TIBSQL;
  DidActivate: Boolean;
begin
  DidActivate := False;
  IBSQL := TIBSQL.Create(nil);
  try
    IBSQL.DataBase := DataBase;
    IBSQL.Transaction := Transaction;
    DidActivate := ActivateTransaction;
    IBSQL.SQL.Text := S;
    try
      IBSQL.ExecQuery;
    except
      if DidActivate and Transaction.InTransaction then
        Transaction.Rollback;
      raise;
    end;
  finally
    if DidActivate and Transaction.InTransaction then
      Transaction.Commit;
    IBSQL.Free;
  end;
end;

function TgdcBase.DeleteRecord: Boolean;
begin
  Result := False;
  try
    Delete;
    Result := True
  except
    on E: EIBError do
    begin
      if E.IBErrorCode = isc_foreign_key then
      begin
        isUse;
        Abort;
      end else
        raise EgdcBase.CreateObj(E, Self);
    end;
  end;
end;

class procedure TgdcBase.CheckClass(C: TClass);
begin
  if not C.InheritsFrom(Self) then
    raise EgdcBase.Create('Invalid gdc class specified');
end;

procedure TgdcBase.ChooseElement(F: TgdcFindObject);
begin
end;

function TgdcBase.GetGroupID: Integer;
var
  q: TIBSQL;
  DidActivate: Boolean;
begin
  DidActivate := False;
  q := TIBSQL.Create(nil);
  try
    try
      q.Database := Database;
      q.Transaction := Transaction;
      DidActivate := ActivateTransaction;

      q.SQL.Text := 'SELECT ID FROM RP_REPORTGROUP WHERE usergroupname = ''' +
        UpperCase(ClassName + SubType) + '''';
      q.ExecQuery;
      if q.RecordCount > 0 then
        Result := q.FieldByName('ID').ASInteger
      else
      begin
        q.Close;
        Result := GetNextID;
        q.SQL.Text := Format('INSERT INTO RP_REPORTGROUP(ID, USERGROUPNAME, NAME) ' +
          ' VALUES(%d, ''' + UpperCase(ClassName + SubType) + ''', ''' +
            GetDisplayName(SubSet) + ''')', [Result]);
        q.ExecQuery;
        { TODO : что-то не нравится мне этот ретаининг...
                 тут скорее всего надо использовать отдельную
                 транзакцию
        }
        Transaction.CommitRetaining;
      end;
    finally
      q.Free;

      if DidActivate then
        Transaction.Commit;
    end;
  except
    Result := cst_ReportGroupID;
  end;
end;

procedure TgdcBase.LoadEventList;
begin
  FEventList.Add(gdcEventTypesString[etAfterCancel]);
  FEventList.Add(gdcEventTypesString[etAfterClose]);
  FEventList.Add(gdcEventTypesString[etAfterDelete]);
  FEventList.Add(gdcEventTypesString[etAfterEdit]);
  FEventList.Add(gdcEventTypesString[etAfterInsert]);
  FEventList.Add(gdcEventTypesString[etAfterOpen]);
  FEventList.Add(gdcEventTypesString[etAfterPost]);
  FEventList.Add(gdcEventTypesString[etAfterRefresh]);
  FEventList.Add(gdcEventTypesString[etAfterScroll]);
  FEventList.Add(gdcEventTypesString[etBeforeCancel]);
  FEventList.Add(gdcEventTypesString[etBeforeClose]);
  FEventList.Add(gdcEventTypesString[etBeforeDelete]);
  FEventList.Add(gdcEventTypesString[etBeforeEdit]);
  FEventList.Add(gdcEventTypesString[etBeforeInsert]);
  FEventList.Add(gdcEventTypesString[etBeforeOpen]);
  FEventList.Add(gdcEventTypesString[etBeforePost]);
  FEventList.Add(gdcEventTypesString[etBeforeRefresh]);
  FEventList.Add(gdcEventTypesString[etBeforeScroll]);
  FEventList.Add(gdcEventTypesString[etOnCalcFields]);
  FEventList.Add(gdcEventTypesString[etOnNewRecord]);
  FEventList.Add(gdcEventTypesString[etOnFieldChange]);
end;

{ TScriptObjectDescription }

function TScriptObjectList.Add(
  AComponent: TgdcBase): Integer;
begin
  Result := Inherited Add(TComponent(AComponent));
end;

constructor TScriptObjectList.Create;
begin
  inherited;
  OwnsObjects := False;
end;

function TScriptObjectList.GetItem(
  Index: Integer): TgdcBase;
begin
  Result := TgdcBase(inherited Items[Index]);
end;


function TScriptObjectList.IndexByName(AName: String): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if Items[I].NameInScript = AName then
    begin
      Result := I;
      Break;
    end;
end;

procedure TgdcBase.CreateFields;
var
  I: Integer;
  F: TatRelationField;
  FieldName, RelationName: String;
begin
  inherited;

  // локализуем экранные метки полей
  for I := 0 to FieldCount - 1 do
  begin
    with QSelect.Current[i].Data^ do
    begin
      { Get the field name }
      SetString(RelationName, relname, relname_length);
      SetString(FieldName, sqlname, sqlname_length);
    end;

    F := atDatabase.FindRelationField(RelationName, FieldName);
    if F <> nil then
      Fields[I].DisplayLabel := F.LName;

    // для полей, которые не входят в запросы на обновление данных
    // и если для объекта не предусмотрена специальная обработка
    // мы снимаем Required
    if (CustomProcess * [cpInsert, cpModify]) = [] then
      if StrIPos(',' + Fields[I].FieldName + ',', ',' + FUpdateableFields + ',') = 0 then
      begin
        Fields[I].Required := False;
        //Fields[I].ReadOnly := True;
      end;

    //
    Fields[I].Visible := ShowFieldInGrid(Fields[I]);
  end;
end;

function TgdcBase.GetHasWhereClause: Boolean;
begin
  Result := (GetWhereClause > '') or
    (Assigned(IBLogin) and ([tiAView, tiAChag, tiAFull] * gdcTableInfos <> []));
end;

class function TgdcBase.GetListTableAlias: String;
begin
  Result := 'z';
end;

function TgdcBase.QueryDescendant: TgdcFullClass;
var
  I: Integer;
  CL: TClassList;
begin
  Result.SubType := SubType;

  CL := TClassList.Create;
  try
    if not GetChildrenClass(CL) then
    begin
      Result.gdClass := CgdcBase(Self.ClassType);
      exit;
    end;

    if CL.Count = 1 then
    begin
      Result.gdClass := CgdcBase(CL[0]);
      exit;
    end;

    with Tgdc_dlgQueryDescendant.Create(ParentForm) do
    try
      rgObjects.Items.Clear;
      for I := 0 to CL.Count - 1 do
        rgObjects.Items.Add(CgdcBase(CL[I]).GetDisplayName(SubType));

      if Height < CL.Count * 30 + 30 then
        Height := CL.Count * 30 + 30;

      rgObjects.ItemIndex := 0;

      if ShowModal <> mrOk then
      begin
        Result.gdClass := nil;
        exit;
      end;

      Result.gdClass := CgdcBase(CL[rgObjects.ItemIndex]);
    finally
      Free;
    end;

  finally
    CL.Free;
  end;
end;

class function TgdcBase.GetListNameByID(const AnID: TID): String;
var
  q: TIBSQL;
  tr: TIBTransaction;
begin
  Assert(Assigned(gdcBaseManager) and Assigned(gdcBaseManager.Database));

  q := TIBSQL.Create(nil);
  tr := TIBTransaction.Create(nil);
  try
    tr.DefaultDatabase := gdcBaseManager.Database;
    tr.StartTransaction;

    q.Database := gdcBaseManager.Database;
    q.Transaction := tr;
    { TODO : а сабсет?? }
    q.SQL.Text := 'SELECT ' + GetListField('') + ' FROM ' +
      GetListTable('') + ' WHERE ' + GetKeyField('') + ' = :ID';
    q.Params[0].AsInteger := AnID;
    q.ExecQuery;
    if q.EOF then
      Result := ''
    else
      Result := q.Fields[0].AsString;
    q.Close;
    tr.Commit;
  finally
    q.Free;
    tr.Free;
  end;
end;

procedure TgdcBase.PopupReportMenu(const X, Y: Integer);
var
  Pt: TPoint;
begin
//При изменении отчетов, добавлении или удалении необходимо перечитывать меню
  //if not Assigned(FpmReport) then
    MakeReportMenu;

  if (X = -1) and (Y = -1) then
    GetCursorPos(Pt)
  else
    Pt := Point(X, Y);

  FpmReport.Popup(Pt.X, Pt.Y);
end;

procedure TgdcBase.PopupFilterMenu(const X, Y: Integer);
begin
  FFilter.PopupMenu(X, Y);
end;

procedure TgdcBase.DoOnFilterChanged(Sender: TObject;
  const AnCurrentFilter: Integer);
begin
  if Assigned(FOnFilterChanged) then
    FOnFilterChanged(Sender);
end;

{procedure TgdcBase.SetIBSQL;
begin
  FIBSQL.Close;
  FIBSQL.DataBase := DataBase;
  FIBSQL.Transaction := Transaction;
end;}

function TgdcBase.GetDetailLinks(Index: Integer): TgdcBase;
begin
  Result := FDetailLinks[Index] as TgdcBase;
end;

function TgdcBase.GetDetailLinksCount: Integer;
begin
  Result := FDetailLinks.Count;
end;

procedure TgdcBase.AddDetailLink(AnObject: TgdcBase);
begin
  if Assigned(FDetailLinks) and (FDetailLinks.IndexOf(AnObject) = -1) then
    FDetailLinks.Add(AnObject);
end;

procedure TgdcBase.RemoveDetailLink(AnObject: TgdcBase);
begin
  if Assigned(FDetailLinks) then
    FDetailLinks.Remove(AnObject);
end;

function TgdcBase.GetChildrenClass(CL: TClassList): Boolean;
begin
  Result := GetDescendants(CgdcBase(Self.ClassType), CL, True);
end;

procedure TgdcBase.ValidateField(Sender: TField);
begin
  //
end;

function TgdcBase.RelationByAliasName(const AnAliasName: String): String;
begin
  Result := QSelect.FieldByName(AnAliasName).AsXSQLVAR.relname;
end;

function TgdcBase.FieldNameByAliasName(const AnAliasName: String): String;
begin
  Result := QSelect.FieldByName(AnAliasName).AsXSQLVAR.sqlname;
end;

procedure TgdcBase.CustomDelete(Buff: Pointer);
  {@CALL MACRO INH_PARAMS (var)}
begin
  {@CALL MACRO INH_BODY(GDC_BASE, GDC_CUSTOMDELETE)}

  SetInternalSQLParams(FQDelete, Buff);
  FQDelete.ExecQuery;
  FRowsAffected := FQDelete.RowsAffected;

  {@CALL MACRO INH_FINALLY(GDC_BASE, GDC_CUSTOMDELETE)}
end;

procedure TgdcBase.CustomInsert(Buff: Pointer);
  {@UNFOLD MACRO INH_ORIG_PARAMS(VAR)}
  {M}VAR
  {M}  Params, LResult: Variant;
  {M}  Index: Integer;
  {END MACRO}
begin
  {@UNFOLD MACRO INH_ORIG_CUSTOMINSERT('TGDCBASE', 'CUSTOMINSERT')}
  {M}  try
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      SetFirstClassMethod('TGDCBASE', 'CUSTOMINSERT');
  {M}      Index := LastCallClass.IndexOf('CUSTOMINSERT');
  {M}      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') = -1) then
  {M}      begin
  {M}        Params := VarArrayOf([GetGdcInterface(Self), Integer(Buff)]);
  {M}        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, 'TGDCBASE',
  {M}          'CUSTOMINSERT', Params, LResult) then
  {M}          exit;
  {M}      end else
  {M}        //
  {M}        if (TStrings(LastCallClass.Objects[Index]).IndexOf('TGDCBASE') > -1) and
  {M}          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
  {M}          <> UpperCase('TGDCBASE')) then
  {M}        begin
  {M}          if MethodWithInherited.IndexOf('TGDCBASE' + '.' + 'CUSTOMINSERT') > -1 then
  {M}            Inherited;
  {M}          Exit;
  {M}        end;
  {M}        MethodWithInherited.Add('TGDCBASE' + '.' + 'CUSTOMINSERT');
  {M}    end;
  {END MACRO}

  //
  SetInternalSQLParams(QInsert, Buff);
  QInsert.ExecQuery;
  FRowsAffected := QInsert.RowsAffected;
  //

  {@UNFOLD MACRO INH_ORIG_FINALLY('TGDCBASE', 'CUSTOMINSERT')}
  {M}  finally
  {M}    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
  {M}    begin
  {M}      if MethodWithInherited.IndexOf('TGDCBASE' +
  {M}        '.' + 'CUSTOMINSERT') > - 1 then
  {M}        MethodWithInherited.Delete(MethodWithInherited.IndexOf('TGDCBASE' +
  {M}          '.' + 'CUSTOMINSERT'));
  {M}      ClearMacrosStack('TGDCBASE', 'CUSTOMINSERT');
  {M}    end;
  {M}  end;
  {END MACRO}
end;

procedure TgdcBase.CustomModify(Buff: Pointer);
  {@CALL MACRO INH_PARAMS (var)}
begin
  {@CALL MACRO INH_BODY(GDC_BASE, GDC_CUSTOMMODIFY)}

  SetInternalSQLParams(QModify, Buff);
  QModify.ExecQuery;
  FRowsAffected := QModify.RowsAffected;

  {@CALL MACRO INH_FINALLY(GDC_BASE, GDC_CUSTOMMODIFY)}
end;

function TgdcBase.GetObjectName: String;
begin
  if Active then
    Result := Trim(FieldByName(GetListField(SubType)).AsString)
  else
    Result := FObjectName;
end;

procedure TgdcBase.SetObjectName(const Value: String);
var
  WasActive: Boolean;
begin
  FObjectName := Value;
  if FObjectName = '' then Close else
  begin
    if State in dsEditModes then
      FieldByName(GetListField(SubType)).AsString := FObjectName else
    if HasSubSet('ByName') then
    begin
      WasActive := Active;
      Close;
      ParamByName(GetListField(SubType)).AsString := FObjectName;
      Active := WasActive;
      {if EOF then
        raise EgdcBase.CreateObj('Invalid object name specified', Self);}
    end else
      if Active and (not Locate(GetListField(SubType), Value, [])) then
        raise EgdcBase.CreateObj('Invalid object name specified', Self);
  end;
end;

procedure TgdcBase.SetRefreshSQLOn(SetOn: Boolean);
begin
  Close;
  
  if SetOn then
  begin
    if not Assigned(FSQLSetup) then
      FSQLSetup := TatSQLSetup.Create(nil);

    if not (csDesigning in ComponentState) then
    begin
      RefreshSQL.Text := FSQLSetup.PrepareSQL(GetRefreshSQLText, Self.ClassName +
        '(' + Self.SubType + ')');
    end else
      RefreshSQL.Text := GetRefreshSQLText;

  end else
    RefreshSQL.Text := '';

  Open;
end;

procedure TgdcBase.RevertRecord;
var
  I: Integer;
begin
  Assert(sSubDialog in FBaseState);
  Assert(State in dsEditModes);
  for I := 0 to FOldValues.Count - 1 do
    if (FOldValues[I] as TFieldValue).IsNull then
      FieldByName((FOldValues[I] as TFieldValue).FieldName).Clear
    else
      FieldByName((FOldValues[I] as TFieldValue).FieldName).AsString :=
        (FOldValues[I] as TFieldValue).Value;
  FOldValues.Clear;
end;

procedure TgdcBase.SetSubType(const Value: String);
begin
  if FSubType <> Value then
  begin
    Close;
    FSubType := Value;
    FgdcTableInfos := GetTableInfos(FSubType);
    if Assigned(FFilter) then
      FFilter.Name := 'flt_' + RemoveProhibitedSymbols(FSubType) + System.copy(ClassName, 2, 255);
    FSQLInitialized := False;  
    //InitSQL;
  end;
end;

constructor TgdcBase.CreateSubType(AnOwner: TComponent;
  const ASubType: TgdcSubType; const ASubSet: TgdcSubSet = 'All');
begin
  Create(AnOwner);
  SubType := ASubType; // тут должно быть обязательно присваивание проперти!
  SubSet := ASubSet;  
end;

{ TgdcDragObject }

constructor TgdcDragObject.Create(ASourceControl: TWinControl);
begin
  inherited Create;
  SourceControl := ASourceControl;
end;

function TgdcBase.GetSubType: String;
begin
  Result := FSubType;
end;

function TgdcBase.ParentHandle: Integer;
begin
  Result := 0;

  if (FDlgStack.Count > 0) and (FDlgStack.Peek <> nil) and (FDlgStack.Peek is TForm) then
    Result := (FDlgStack.Peek as TForm).Handle
  else if Assigned(FgdcDataLink) and (FgdcDataLink.DataSet is TgdcBase) then
    Result := (FgdcDataLink.DataSet as TgdcBase).ParentHandle;

  if (Result = 0) and Assigned(FParentForm) then
    Result := FParentForm.Handle;
end;

procedure TgdcBase.Post;
var
  S: TDataSetState;
  q: TIBSQL;
  DidActivate: Boolean;
begin
  if FDataTransfer then
  begin
    inherited Post;
    exit;
  end;

(*
  if FDataTransfer then
  begin
    // кусок кода из ДБ
    UpdateRecord;
    case State of
      dsEdit, dsInsert:
        begin
          DataEvent(deCheckBrowseMode, 0);
          //CheckRequiredFields;
          //DoBeforePost;
          CheckOperation(InternalPost, FOnPostError);
          FreeFieldBuffers;
          SetState(dsBrowse);
          Resync([]);
          //DoAfterPost;
        end;
    end;

    exit;
  end;*)

  if (State = dsEdit) and (sDialog in FBaseState) and
    (not Modified) then Cancel
  else begin
    S := State;
    inherited Post;
    FDSModified := True;

    { TODO :
этот участок кода под вопросом! мы сомневаемся не отразится ли
на скорости дополнительный запрос на любое изменение данных
заметьте, что даже если в таблице есть соответстующие поля
все равно заносим сюда, потому что при считывании объекта из
потока мы будем смотреть дату из руидовской таблицы
}
    if Assigned(IBLogin) and (S in dsEditModes) then
    begin
      DidActivate := False;
      q := TIBSQL.Create(nil);
      try
        q.Database := Database;
        q.Transaction := Transaction;
        DidActivate := ActivateTransaction;
        if S = dsEdit then
          q.SQL.Text := 'UPDATE gd_ruid SET modified=''NOW'', editorkey=:EK WHERE id=:ID'
        else
          q.SQL.Text := 'INSERT INTO gd_ruid VALUES (:ID, :ID, GEN_ID(gd_g_dbid, 0), ''NOW'', :EK)';
        try
          q.Prepare;
          q.ParamByName('ID').AsInteger := Self.ID;
          q.ParamByName('EK').AsInteger := IBLogin.ContactKey;
          q.ExecQuery;
        except
          //on E: Exception do
          //  raise EgdcBase.CreateObj(E, Self);
          { TODO : тут временно! после того как все базы с апгрейдим -- убрать }
        end;
      finally
        if DidActivate then
          Transaction.Commit;
        q.Free;
      end;
    end;
  end;
  FOldValues.Clear;
end;

procedure TgdcBase.Assign(Source: TPersistent);
begin
  Assert(InheritsFrom(Source.ClassType));
  Close;
  Transaction := (Source as TgdcBase).Transaction;
  SubType := (Source as TgdcBase).SubType;
  if HasSubSet('ByID') then
    ParamByName(GetKeyField(SubType)).AsInteger := (Source as TgdcBase).ID
  else if HasSubSet('ByName') then
    ParamByName(GetListField(SubType)).AsString := (Source as TgdcBase).ObjectName
  else
    SubSet := (Source as TgdcBase).SubSet;
end;

procedure TgdcBase.SyncField(Field: TField);
begin
  if (not (sSyncControls in FBaseState))
    and (sDialog in FBaseState)
    and (FDlgStack.Peek is Tgdc_dlgG) then
  begin
    Include(FBaseState, sSyncControls);
    try
      (FDlgStack.Peek as Tgdc_dlgG).SyncControls;
    finally
      Exclude(FBaseState, sSyncControls);
    end;
  end;
end;

function TgdcBase.FieldChanged(const AFieldName: String): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to FOldValues.Count - 1 do
    if AnsiCompareText((FOldValues[I] as TFieldValue).FieldName, AFieldName) = 0 then
    begin
      Result := True;
      exit;
    end;
end;

function TgdcBase.GetCustomProcess: TgsCustomProcesses;
begin
  Result := FCustomProcess;
end;

procedure TgdcBase.SetCustomProcess(const Value: TgsCustomProcesses);
begin
  FCustomProcess := Value;
end;

procedure TgdcBase._CustomInsert(Buff: Pointer);
begin
  CustomInsert(Buff);
  DoAfterCustomProcess(Buff, cpInsert);
end;

procedure TgdcBase._CustomModify(Buff: Pointer);
begin
  CustomModify(Buff);
  DoAfterCustomProcess(Buff, cpModify);
end;

procedure TgdcBase._CustomDelete(Buff: Pointer);
begin
  try
    CustomDelete(Buff);
  except
    on Ex: EIBError do
    begin
      if Ex.IBErrorCode = isc_foreign_key then
      begin
        isUse;
        Abort;
      end else
        raise;
    end;
  end;
  DoAfterCustomProcess(Buff, cpDelete);
end;

class function TgdcBase.GetSubTypeList(SubTypeList: TStrings): Boolean;
begin
  SubTypeList.Clear;
  Result := False;
end;

function TgdcBase.GetNextID(const Increment: Boolean): Integer;
var
  q: TIBSQL;
begin
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := ReadTransaction;
    if Increment then
      q.SQL.Text := 'SELECT GEN_ID(gd_g_unique, 1) + GEN_ID(gd_g_offset, 0) FROM rdb$database'
    else
      q.SQL.Text := 'SELECT GEN_ID(gd_g_unique, 0) + GEN_ID(gd_g_offset, 0) FROM rdb$database';
    q.ExecQuery;
    Result := q.Fields[0].AsInteger;
    q.Close;
  finally
    q.Free;
  end;
end;

{procedure TgdcBase._CommitRollback(const ACommit: Boolean;
  const AType: TgsCommitType);
var
  WasActive: Boolean;
  Bm: TBookmarkStr;
  L, ParamL: TObjectList;
  I, J: Integer;
  SL, OwnParams: TStringList;
  D: TIBCustomDataSetCrack;
  RC: Integer;
begin
  Transaction.CheckInTransaction;
  RC := 0;

  if State in dsEditModes then
  begin
    if ACommit then
      Post
    else
      Cancel;
  end;

  if CachedUpdates and UpdatesPending then
  begin
    if ACommit then
      ApplyUpdates
    else
      CancelUpdates;
  end;

  WasActive := Active;

  case AType of
    ctHard, ctHardReopen:
    begin
      if Active then
      begin
        Bm := Bookmark;
        RC := RecordCount;
      end;

      if AType = ctHardReopen then
      begin
        L := TObjectList.Create(False);
        ParamL := TObjectList.Create(True);
        for I := 0 to Transaction.SQLObjectCount - 1 do
          if (Transaction.SQLObjects[I] <> nil) and
            (Transaction.SQLObjects[I].Owner is TIBCustomDataSet) and
            TIBCustomDataSet(Transaction.SQLObjects[I].Owner).Active then
          begin
            D := TIBCustomDataSetCrack(Transaction.SQLObjects[I].Owner);
            L.Add(D);
            SL := TStringList.Create;
            ParamL.Add(SL);
            (* TODO : НУЛЛ ТУТ НЕ СОХРАНЯЕТСЯ! *)
            for J := 0 to D.Params.Count - 1 do
              if SL.IndexOfName(D.Params[J].Name) = -1 then
                SL.Add(D.Params[J].Name + '=' + D.Params[J].AsString);
          end;

        OwnParams := TStringList.Create;
        for I := 0 to Params.Count - 1 do
          if OwnParams.IndexOfName(Params[I].Name) = -1 then
            OwnParams.Add(Params[I].Name + '=' + Params[I].AsString);
      end else
      begin
        L := nil;
        ParamL := nil;
        OwnParams := nil;
      end;

      try
        if ACommit then
          Transaction.Commit
        else
          Transaction.Rollback;

        if AType = ctHardReopen then
        begin
          Transaction.StartTransaction;

          if OwnParams <> nil then
            for I := 0 to OwnParams.Count - 1 do
              ParamByName(OwnParams.Names[I]).AsString := OwnParams.Values[OwnParams.Names[I]];

          for I := 0 to L.Count - 1 do
          begin
            D := TIBCustomDataSetCrack(L[I]);

            if not D.Active then
            begin
              SL := ParamL[I] as TStringList;

              for J := 0 to SL.Count - 1 do
              begin
                D.Params.ByName(SL.Names[J]).AsString := SL.Values[SL.Names[J]];
              end;
            end;
          end;


          //
          // Отслеживаем ситуации при master-detail, когда в detail-части
          // срабатывает commit и осуществляется переоткрытие detail-dataset-а.
          // Если есть master-часть осуществляем открытие ее, а она уже сама
          // откроет detail-часть

          if
            Assigned(FgdcDataLink.DataSet) and
            not FgdcDataLink.DataSet.Active and
            WasActive
          then
            FgdcDataLink.DataSet.Active := True;

          Active := WasActive;

          if Active then
          begin
            MoveBy(RC);
            if BookmarkValid(Pointer(Bm)) then
              Bookmark := Bm;
          end;

          for I := 0 to L.Count - 1 do
          begin
            (L[I] as TIBCustomDataSet).Open;
          end;
        end;
      finally
        L.Free;
        ParamL.Free;
        OwnParams.Free;
      end;
    end;

    ctRetaining, ctRetainingReopen:
    begin
      // пройдемся по всем объектам, которые висят на нашей
      // транзакции и выйдем из режима редактирования
      for I := 0 to Transaction.SQLObjectCount - 1 do
        if (Transaction.SQLObjects[I] <> nil)
          and (Transaction.SQLObjects[I].Owner <> Self)
          and (Transaction.SQLObjects[I].Owner <> nil)
          and (Transaction.SQLObjects[I].Owner is TIBCustomDataSet)
          and ((Transaction.SQLObjects[I].Owner as TIBCustomDataSet).State in dsEditModes) then
        begin
          if ACommit then
            (Transaction.SQLObjects[I].Owner as TIBCustomDataSet).Post
          else
            (Transaction.SQLObjects[I].Owner as TIBCustomDataSet).Cancel;
        end;

      if ACommit then
        Transaction.CommitRetaining
      else
        Transaction.RollbackRetaining;

      if (AType = ctRetainingReopen) and (not (sDialog in FBaseState)) then
        CloseOpen;

      FDSModified := False;

      (* TODO :
может лучше сделать протектед метод для изменения состояния
ДСМодифайд, а не вызывать ОнАфтерТрЕнд?? *)
      for I := 0 to Transaction.SQLObjectCount - 1 do
        if (Transaction.SQLObjects[I] <> nil)
          and (Transaction.SQLObjects[I].Owner <> Self)
          and (Transaction.SQLObjects[I].Owner <> nil)
          and (Transaction.SQLObjects[I].Owner is TgdcBase) then
        begin
          (Transaction.SQLObjects[I].Owner as TgdcBase).DoAfterTransactionEnd(nil);
        end;
    end;
  end;
end;
}

class function TgdcBase.GetTableInfos(const ASubType: String): TgdcTableInfos;
var
  R: TatRelation;
begin
  Assert(Assigned(atDatabase));
  R := atDatabase.Relations.ByRelationName(GetListTable(ASubType));
  Result := [];
  if (R <> nil) and (R.RelationFields <> nil) then
  begin
    if R.RelationFields.ByFieldName(GetKeyField(ASubType)) <> nil then
      Include(Result, tiID);
    if (R.RelationFields.ByFieldName('creationdate') <> nil)
        and (R.RelationFields.ByFieldName('creatorkey') <> nil) then
      Include(Result, tiCreationInfo);
    if (R.RelationFields.ByFieldName('editiondate') <> nil)
        and (R.RelationFields.ByFieldName('editorkey') <> nil) then
      Include(Result, tiEditionInfo);
    if R.RelationFields.ByFieldName('aview') <> nil then
      Include(Result, tiAView);
    if R.RelationFields.ByFieldName('achag') <> nil then
      Include(Result, tiAChag);
    if R.RelationFields.ByFieldName('afull') <> nil then
      Include(Result, tiAFull);
  end;
end;

function TgdcBase.HasAttribute: Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to FieldCount - 1 do
    if AnsiCompareText(System.Copy(Fields[I].FieldName, 1, 4), UserPrefix) = 0 then
    begin
      Result := True;
      exit;
    end;
end;


procedure TgdcBase.DoAfterCustomProcess(Buff: Pointer;
  Process: TgsCustomProcess);
begin
  // should be overridden by descendant classes
end;

{procedure TgdcBase.SetDialogActions(const Value: TgsDialogActions);
begin
  if FDialogActions <> Value then
    FDialogActions := Value;
end;}

{ EgdcBase }

constructor EgdcBase.CreateObj(const AMessage: String; AnObj: TgdcBase);
begin
  if AnObj <> nil then
    CreateFmt('%s'#13#10#13#10'Class: %s'#13#10'Object: %s'#13#10'SubType: %s'#13#10'SubSet: %s'#13#10'ID: %s'#13#10,
      [AMessage, AnObj.ClassName, AnObj.Name, AnObj.SubType, AnObj.SubSet, IntToStr(AnObj.ID)])
  else
    Create(AMessage);

  FIBError := False;
end;

constructor EgdcBase.CreateObj(E: Exception; AnObj: TgdcBase);
begin
  Assert(Assigned(E));
  if E is EgdcBase then
    Create(E.Message)
  else
    CreateObj(E.Message, AnObj);
  if E is EIBError then
  begin
    FIBErrorCode := (E as EIBError).IBErrorCode;
    FSQLCode := (E as EIBError).SQLCode;
    FIBError := True;
  end;
end;

procedure TgdcBase.DoAfterShowDialog(DlgForm: TCreateableForm;
  IsOk: Boolean);
begin
  if Assigned(FAfterShowDialog) then
    FAfterShowDialog(Self, DlgForm, IsOk);
end;

procedure TgdcBase.DoBeforeShowDialog(DlgForm: TCreateableForm);
begin
  if Assigned(FBeforeShowDialog) then
    FBeforeShowDialog(Self, DlgForm);
end;

class function TgdcBase.GetSubSetList: String;
begin
  Result := 'All;ByID;ByName;OnlySelected;';
end;

procedure TgdcBase.SetSearchSubSet(const Value: TgdcSubSet);
begin
  if FSearchSubset <> Value then
  begin
    if (Value = '') or CheckSubSet(Value) then
      FSearchSubSet := Value
    else
      raise EgdcBase.CreateObj(Format('Invalid search subset "%s" specified.', [Value]), Self);
  end;
end;

{ TgdcObjectSet }

constructor TgdcObjectSet.Create(AgdClass: CgdcBase; const ASubType: TgdcSubType; const ASize: Integer = 32);
begin
  FgdClass := AgdClass;
  FSubType := ASubType;
  FCount := 0;
  SetLength(FArray, ASize);
end;

destructor TgdcObjectSet.Destroy;
begin
  inherited;
  SetLength(FArray, 0);
end;

function TgdcObjectSet.Get_gdClass: CgdcBase;
begin
  Result := FgdClass;
end;

function TgdcObjectSet.Get_gdClassName: String;
begin
  if FgdClass <> nil then
    Result := FgdClass.ClassName
  else
    Result := '';
end;

function TgdcObjectSet.GetCount: Integer;
begin
  Result := FCount;
end;

function TgdcObjectSet.GetItems(Index: Integer): TID;
begin
  if (Index < 0) or (Index >= FCount) then
    raise Exception.Create(GetGsException(Self, 'Invalid index'));
  Result := FArray[Index];
end;

procedure TgdcObjectSet.Set_gdClass(const Value: CgdcBase);
begin
  if FgdClass <> Value then
  begin
    FgdClass := Value;
    FCount := 0;
  end;  
end;

function TgdcObjectSet.Add(const AnID: TID): Integer;
begin
  Result := Find(AnID);
  if Result = -1 then
  begin
    if FCount = Size then
      SetLength(FArray, (Size + 1) * 2);
    FArray[FCount] := AnID;
    Result := FCount;
    Inc(FCount);
  end;  
end;

function TgdcObjectSet.GetSize: Integer;
begin
  Result := High(FArray) - Low(FArray) + 1;
end;

class function TgdcBase.GetListTable(const ASubType: String): String;
begin
  //raise EgdcBase.Create(Self.ClassName + ': GetListTable is not defined');
  Result := '';
end;

class function TgdcBase.GetListField(const ASubType: String): String;
begin
  Result := '';
end;

procedure TgdcBase.GetDistinctColumnValues(const AFieldName: String;
  S: TStrings; const DoSort: Boolean);
var
  q: TIBSQL;
begin
  Assert(S <> nil);
  Assert(AFieldName > '');

  S.Clear;
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := ReadTransaction;
    q.SQL.Text := 'SELECT DISTINCT ' + AFieldName + ' FROM ' + GetListTable(SubType);
    if DoSort then
      q.SQL.Text := q.SQL.Text + ' ORDER BY 1';
    q.ExecQuery;
    while not q.EOF do
    begin
      S.Add(q.Fields[0].AsString);
      q.Next;
    end;
    q.Close;
  finally
    q.Free;
  end;
end;

function TgdcBase.GetFieldNameComparedToParam(
  const AParamName: String): String;

{ TODO :
ограничения: мы не поддерживаем IN, BETWEEN
}

{ TODO : 
внимание! есть ошибка! если в запросе несколько
одноименных полей, то может вернуть неправильное
значение!

поскольку мы не можем найти имя таблицы, а только ее алиас...

}

  function _Sub(const S, AParamName: String; out ARelationName, AFieldName: String): Boolean;
  var
    B, E: Integer;
    Found: Boolean;
  begin
    if AParamName > '' then
    begin
      E := Pos(':' + UpperCase(AParamName), UpperCase(S)) - 1;
      B := 0;
      Found := True;
      repeat
        while (E > 0) and (S[E] in [' ', '=', '!', '<', '>', ')', '+', '-', '*', '/', '|', '"', #9, #13, #10]) do
          Dec(E);
        if E > 0 then
        begin
          B := E - 1;
          if S[E + 1] = '"' then
          begin
            while (B > 0) and (S[B] <> '"') do
              Dec(B);
          end else
          begin
            while (B > 0) and (S[B] in ['A'..'Z', 'a'..'z', '0'..'9', '_', '$']) do
              Dec(B);
          end;

          AFieldName := System.Copy(S, B + 1, E - B);

          if (B > 0) and (S[B] = '"') then
            Dec(B);

          if (AFieldName > '')
            and (not (AFieldName[1] in ['A'..'Z', 'a'..'z', '_']))
            and (S[E + 1] <> '"') then
          begin
            E := B;
            Found := False;
          end else
          begin
            Found := True;
            if S[E + 1] = '"' then
              AFieldName := '"' + AFieldName + '"';
          end;
        end else
          AFieldName := '';
      until Found;

      if (B > 1) and (S[B] = '.') then
      begin
        Dec(B);
        if S[B] = '"' then
          Dec(B);
        E := B;
        if S[E + 1] = '"' then
          while (B > 0) and (S[B] <> '"') do
            Dec(B)
        else
          while (B > 0) and (S[B] in ['A'..'Z', 'a'..'z', '0'..'9', '_', '$']) do
            Dec(B);
        ARelationName := System.Copy(S, B + 1, E - B);
        if S[E + 1] = '"' then
          ARelationName := '"' + ARelationName + '"';
      end else
        ARelationName := '';
    end else
    begin
      AFieldName := '';
      ARelationName := '';
    end;

    Result := AFieldName > '';
  end;

var
  RN: String;
  F: TField;
begin
  if _Sub(GetFromClause + GetWhereClause, AParamName, RN, Result) then
  begin
    if RN > '' then
      F := FindField({RN,} Result)
    else
      F := FindField(Result);
    if F <> nil then
      Result := F.FieldName
    else
      Result := '';  
  end else
    Result := '';
end;

procedure TgdcBase.LoadDialogDefaults(F: TgsStorageFolder; Dlg: TForm);
var
  L{, L2}: TList;
  I: Integer;
  {PropInfo: PPropInfo;}
  {Fld: TField;}
begin
  L := TList.Create;
  //L2 := TList.Create;
  try
    GetFieldList(L, GetDialogDefaultsFields);

    // the intention here is to store only those
    // field values which controls are on the form
    (*
    with Dlg do
      for I := 0 to ComponentCount - 1 do
      begin
        PropInfo := GetPropInfo(Components[I].ClassInfo, 'DataSource');
        if (PropInfo <> nil)
          and (PropInfo^.PropType^.Kind = tkClass)
          and (GetTypeData(PropInfo^.PropType^).ClassType.InheritsFrom(TDataSource)) then
        begin
          PropInfo := GetPropInfo(Components[I].ClassInfo, 'DataField');
          if (PropInfo <> nil) and (PropInfo^.PropType^.Kind = tkLString) then
          begin
            Fld := Self.FindField(GetStrProp(Components[I], PropInfo));
            if (Fld <> nil) and (L.IndexOf(Fld) <> -1) then
              L2.Add(Fld);
          end;
        end;
      end;
    *)

    for I := 0 to L{2}.Count - 1 do
      if TField(L{2}[I]).IsNull then
      begin
        if F.ValueExists(TField(L{2}[I]).FieldName) then
          TField(L{2}[I]).AsString := F.ReadString(TField(L{2}[I]).FieldName);
      end;
  finally
    L.Free;
    //L2.Free;
  end;
end;

procedure TgdcBase.SaveDialogDefaults(F: TgsStorageFolder; Dlg: TForm);
var
  L, L2: TList;
  I: Integer;
  PropInfo: PPropInfo;
  Fld: TField;
begin
  L := TList.Create;
  L2 := TList.Create;
  try
    GetFieldList(L, GetDialogDefaultsFields);

    // the intention here is to store only those
    // field values which controls are on the form
    { TODO : 
это не помогает. надо бы проверять только контролы
которые могут менять данные. а так подхватываются
и ДБЛэйблы, а это все портит }
    with Dlg do
      for I := 0 to ComponentCount - 1 do
      begin
        PropInfo := GetPropInfo(Components[I].ClassInfo, 'DataSource');
        if (PropInfo <> nil)
          and (PropInfo^.PropType^.Kind = tkClass)
          and (GetTypeData(PropInfo^.PropType^).ClassType.InheritsFrom(TDataSource)) then
        begin
          PropInfo := GetPropInfo(Components[I].ClassInfo, 'DataField');
          if (PropInfo <> nil) and (PropInfo^.PropType^.Kind = tkLString) then
          begin
            Fld := Self.FindField(GetStrProp(Components[I], PropInfo));
            if (Fld <> nil) and (L.IndexOf(Fld) <> -1) then
              L2.Add(Fld);
          end;
        end;
      end;

    for I := 0 to L2.Count - 1 do
    begin
      if TField(L2[I]).IsNull then
        F.DeleteValue(TField(L2[I]).FieldName)
      else
        F.WriteString(TField(L2[I]).FieldName, TField(L2[I]).AsString);
    end;
  finally
    L.Free;
    L2.Free;
  end;
end;

function TgdcBase.GetDialogDefaultsFields: String;
const
  Prohibited = ';ID;NAME;AFULL;ACHAG;AVIEW;RESERVED;PARENT;';
var
  SL: TStringList;
  I: Integer;
  F: TField;
begin
  if FGetDialogDefaultsFieldsCached then
    Result := FGetDialogDefaultsFieldsCache
  else begin
    Result := '';
    SL := TStringList.Create;
    try
      Database.GetFieldNames(GetListTable(SubType), SL);
      for I := 0 to SL.Count - 1 do
        if Pos(';' + SL[I] + ';', ';' + GetListField(SubType) + Prohibited) = 0 then
        begin
          F := FindField(SL[I]);
          if (F <> nil) and (F.DefaultExpression = '') and (not (F is TBlobField)) and (F.Size < 64) then
            Result := Result + F.FieldName + ';';
        end;
    finally
      SL.Free;
    end;

    FGetDialogDefaultsFieldsCached := True;
    FGetDialogDefaultsFieldsCache := Result;
  end;
end;

function TgdcBase.ShowFieldInGrid(AField: TField): Boolean;
var
  AFieldName: String;
begin
  Assert((AField <> nil) and (AField.DataSet = Self));
  AFieldName := System.Copy(AField.Origin, Pos('.', AField.Origin) + 2, 255);
  SetLength(AFieldName, Length(AFieldName) - 1);
  Result := StrIPos(';' + AFieldName + ';', ';' + HideFieldsList) = 0;
end;

function TgdcBase.HideFieldsList: String;
begin
  Result := 'afull;achag;aview;';
end;

function TgdcObjectSet.Find(const AnID: TID): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if Items[I] = AnID then
    begin
      Result := I;
      break;
    end;
end;

procedure TgdcObjectSet.LoadFromStream(S: TStream);
var
  I: Integer;
  ID: TID;
  St: String;
begin
  S.Read(I, SizeOf(I));
  SetLength(St, I);
  S.Read(St[1], I);
  FgdClass := CgdcBase(FindClass(St));
  FCount := 0;
  S.Read(I, SizeOf(I));
  while I > 0 do
  begin
    S.Read(ID, SizeOf(ID));
    Add(ID);
    Dec(I);
  end;
end;

procedure TgdcObjectSet.SaveToStream(S: TStream);
var
  I: Integer;
  ID: TID;
begin
  I := Length(gdClassName);
  S.Write(I, SizeOf(I));
  S.Write(gdClassName[1], I);
  I := Count;
  S.Write(I, SizeOf(I));
  for I := 0 to Count - 1 do
  begin
    ID := Items[I];
    S.Write(ID, SizeOf(ID));
  end;
end;

procedure TgdcObjectSet.Remove(const AnID: TID);
var
  I: Integer;
begin
  I := Find(AnID);
  if I <> -1 then
    Delete(I);
end;

procedure TgdcObjectSet.Delete(const Index: Integer);
var
  J: Integer;
begin
  if (Index < 0) or (Index >= Count) then
    raise Exception.Create(GetGsException(Self, 'Index is out of bounds'));
  for J := Index to Count - 2 do
    FArray[J] := FArray[J + 1];
  Dec(FCount);
end;

function TgdcObjectSet.GetSubType: TgdcSubType;
begin
  Result := FSubType;
end;

procedure TgdcObjectSet.SetSubType(const Value: TgdcSubType);
begin
  if Value <> FSubType then
  begin
    FSubType := Value;
    FCount := 0;
  end;
end;

{ TgdcObjectSets }

constructor TgdcObjectSets.Create;
begin
  inherited Create(True);
end;

function TgdcObjectSets.Find(C: TgdcFullClass): TgdcObjectSet;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
  begin
    Result := (Items[I] as TgdcObjectSet);
    if (Result.gdClass = C.gdClass) and (Result.SubType = C.SubType) then
      exit;
  end;
  Result := nil;
end;

procedure TgdcObjectSets.LoadFromStream(S: TStream);
var
  I: Integer;
  ObjectSet: TgdcObjectSet;
begin
  Clear;
  S.Read(I, SizeOf(I));
  if I <> $66778899 then
    raise Exception.Create(GetGsException(Self, 'Invalid stream format'));
  S.Read(I, SizeOf(I));
  while I > 0 do
  begin
    ObjectSet := TgdcObjectSet.Create(TgdcBase, '');
    ObjectSet.LoadFromStream(S);
    Add(ObjectSet);
    Dec(I);
  end;
end;

procedure TgdcObjectSets.SaveToStream(S: TStream);
var
  I: Integer;
begin
  I := $66778899;
  S.Write(I, SizeOf(I));
  I := Count;
  S.Write(I, SizeOf(I));
  for I := 0 to Count - 1 do
    (Items[I] as TgdcObjectSet).SaveToStream(S);
end;

function TgdcBase.FindField(ARelationName,
  AFieldName: String): TField;
var
  I, P, L: Integer;
  Origin: String;
begin
  Result := nil;
  ARelationName := UpperCase(ARelationName);
  AFieldName := UpperCase(AFieldName);
  L := Length(ARelationName) + Length(AFieldName) + 5; // 5 = Length('"".""')
  for I := 0 to FieldCount - 1 do
  begin
    Origin := UpperCase(Fields[I].Origin);
    P := Pos(ARelationName, Origin);
    if (P > 0) and (Pos(AFieldName, Origin) > P) and (Length(Origin) = L) then
    begin
      Result := Fields[I];
      break;
    end;
  end;

(*
  if ARelationName = '' then
    Result := FindField(AFieldName)
  else begin
    Result := nil;
    for I := 0 to FieldCount - 1 do
      if (AnsiCompareText(AFieldName, FieldNameByAliasName(Fields[I].FieldName)) = 0)
        and (AnsiCompareText(ARelationName, RelationByAliasName(Fields[I].FieldName)) = 0) then
    begin
      Result := Fields[I];
      break;
    end;
  end;
*)
end;

function TgdcBase.FieldByName(const ARelationName,
  AFieldName: String): TField;
begin
  Result := FindField(ARelationName, AFieldName);
  if Result = nil then
    raise EgdcBase.CreateObj(
      Format('Field "%s" (relation "%s") not found',
        [AFieldName, ARelationName]), Self);
end;

function TgdcBase.IsReverseOrder(const AFieldName: String): Boolean;
begin
  Result := False;
end;

procedure TgdcBase.LoadFromFile(const AFileName: String);
var
  S: TStream;
  FN: String;
begin
  FN := QueryLoadFileName(AFileName);
  if FN > '' then
  begin
    S := TFileStream.Create(FN, fmOpenRead);
    try
      LoadFromStream(S);
    finally
      S.Free;
    end;
  end;  
end;

procedure TgdcBase.SaveToFile(const AFileName: String);
var
  S: TStream;
  FN: String;
begin
  FN := QuerySaveFileName(AFileName);
  if FN > '' then
  begin
    S := TFileStream.Create(FN, fmCreate);
    try
      SaveToStream(S, nil);
    finally
      S.Free;
    end;
  end;
end;

procedure TgdcBase.SaveToStream(Stream: TStream;  DetailDS: TgdcBase; const OnlyCurrent: Boolean = True);
var
  MS: TMemoryStream;
  OS: TgdcObjectSet;
  Bm: TBookmarkStr;

  procedure SaveDetail;
  var
    DBm: TBookmarkStr;
  begin
    if DetailDS <> nil then
    begin
      DBm := DetailDS.Bookmark;
      DetailDS.First;
      while not DetailDS.EOF do
      begin
        DetailDS._SaveToStream(MS, OS);
        DetailDS.Next;
      end;
      DetailDS.Bookmark := DBm;
    end;
  end;

begin
  MS := TMemoryStream.Create;
  OS := TgdcObjectSet.Create(TgdcBase, '');
  try
    if DetailDS <> nil then
      DetailDS.DisableControls;
    try
      if OnlyCurrent then
      begin
        _SaveToStream(MS, OS);
        SaveDetail;
      end else begin
        Bm := Bookmark;
        DisableControls;
        try
          First;
          while not EOF do
          begin
            _SaveToStream(MS, OS);
            SaveDetail;
            Next;
          end;
        finally
          Bookmark := Bm;
          EnableControls;
        end;
      end;
    finally
      if DetailDS <> nil then
        DetailDS.EnableControls;
    end;

    // в процессе сохранения мы генерировали РУИДы
    // сохраним теперь их окончательно
    if Transaction.InTransaction then
      Transaction.CommitRetaining;
  finally
    OS.SaveToStream(Stream);
    Stream.CopyFrom(MS, 0);

    MS.Free;
    OS.Free;
  end;
end;

procedure TgdcBase.LoadFromStream(Stream: TStream);
var
  OS: TgdcObjectSet;
begin
  OS := TgdcObjectSet.Create(TgdcBase, '');
  try
    OS.LoadFromStream(Stream);
    _LoadFromStream(Stream, nil, OS, nil);
  finally
    OS.Free;
  end;
end;

function TgdcBase.QuerySaveFileName(const AFileName: String): String;
begin
  if AFileName = '' then
    with TSaveDialog.Create(FParentForm) do
    try
      Options := [ofOverwritePrompt,ofHideReadOnly,ofPathMustExist,ofNoReadOnlyReturn,ofEnableSizing];
      DefaultExt := 'dat';
      Filter := 'Dat files|*.dat';
      {$IFDEF GEDEMIN}
      if Assigned(UserStorage) then
      begin
        InitialDir := UserStorage.ReadString(Self.ClassName + SubType, 'SaveDir', '');
        FileName := UserStorage.ReadString(Self.ClassName + SubType, 'SaveFileName', '');
      end;
      {$ENDIF}
      if not Execute then
      begin
        Result := '';
        exit;
      end;
      {$IFDEF GEDEMIN}
      if Assigned(UserStorage) then
      begin
        UserStorage.WriteString(Self.ClassName + SubType, 'SaveDir', InitialDir);
        UserStorage.WriteString(Self.ClassName + SubType, 'SaveFileName', FileName);
      end;
      {$ENDIF}
      Result := FileName;
    finally
      Free;
    end
  else
    Result := AFileName;
end;

function TgdcBase.QueryLoadFileName(const AFileName: String): String;
begin
  Result := AFileName;

  while (Result = '') or (not FileExists(Result)) do
    with TOpenDialog.Create(FParentForm) do
    try
      Options := [ofPathMustExist,ofFileMustExist,ofEnableSizing];
      DefaultExt := 'dat';
      Filter := 'Dat files|*.dat';
      {$IFDEF GEDEMIN}
      if (AFileName = '') and Assigned(UserStorage) then
      begin
        InitialDir := UserStorage.ReadString(Self.ClassName + SubType, 'SaveDir', '');
        FileName := UserStorage.ReadString(Self.ClassName + SubType, 'SaveFileName', '');
      end else
      {$ENDIF}
        FileName := Result;
      if not Execute then
      begin
        Result := '';
        exit;
      end;
      {$IFDEF GEDEMIN}
      if (AFileName = '') and Assigned(UserStorage) then
      begin
        UserStorage.WriteString(Self.ClassName + SubType, 'SaveDir', InitialDir);
        UserStorage.WriteString(Self.ClassName + SubType, 'SaveFileName', FileName);
      end;
      {$ENDIF}
      Result := FileName;
    finally
      Free;
    end;
end;

procedure TgdcBase.GetWhereClauseConditions(S: TStrings);
var
  I: Integer;
  Str: String;
begin
  { TODO : 
сабсет бый ид может быть перекрыт!
например в выписках для ускорения }
  if HasSubSet('ByID') then
    S.Add(Format('%s.%s=:%s', [GetListTableAlias, GetKeyField(SubType), GetKeyField(SubType)]))
  else if HasSubSet('ByName') then
    S.Add(Format('%s.%s=:%s', [GetListTableAlias, GetListField(SubType), GetListField(SubType)]))
  else if HasSubSet('OnlySelected') then
  begin
    Str := '';
    for I := 0 to FSelectedID.Count - 1 do
    begin
      if Length(Str) >= 8192 then break;
      Str := Str + IntToStr(FSelectedID[I]) + ',';
    end;
    if Str = '' then
      Str := '-1'
    else
      SetLength(Str, Length(Str) - 1);
    S.Add(Format('%s.%s IN (%s)', [GetListTableAlias, GetKeyField(SubType), Str]));
  end;

  { TODO : 
добавлять так просто нельзя
в некоторых случаях рестрикт кондитион 
будет задаваться джоином }
  //S.Add(GetRestrictCondition(GetListTable(SubType), SubType));
end;

function TgdcBase.GetCreationDate: TDateTime;
begin
  if tiCreationInfo in gdcTableInfos then
    Result := FieldByName('creationdate').AsDateTime
  else
    Result := GetEditionDate;
end;

function TgdcBase.GetCreatorKey: TID;
begin
  if tiCreationInfo in gdcTableInfos then
    Result := FieldByName('creatorkey').AsInteger
  else
    Result := GetEditorKey;
end;

function TgdcBase.GetCreatorName: String;
var
  q: TIBSQL;
begin
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := ReadTransaction;
    q.SQL.Text := 'SELECT name FROM gd_contact WHERE id=:ID';
    q.Params[0].AsInteger := CreatorKey;
    q.ExecQuery;
    if q.EOF then
      Result := ''
    else
      Result := q.Fields[0].AsString;
  finally
    q.Free;
  end;
end;

function TgdcBase.GetEditionDate: TDateTime;
var
  q: TIBSQL;
begin
  if tiEditionInfo in gdcTableInfos then
    Result := FieldByName('editiondate').AsDateTime
  else begin
    q := TIBSQL.Create(nil);
    try
      q.Database := Database;
      q.Transaction := ReadTransaction;
      q.SQL.Text := 'SELECT modified FROM gd_ruid WHERE id=:ID';
      q.Params[0].AsInteger := ID;
      q.ExecQuery;
      if not q.EOF then
        Result := q.Fields[0].AsDateTime
      else
        Result := Now;
    finally
      q.Free;
    end;
  end;
end;

function TgdcBase.GetEditorKey: TID;
var
  q: TIBSQL;
begin
  if tiEditionInfo in gdcTableInfos then
    Result := FieldByName('editorkey').AsInteger
  else begin
    q := TIBSQL.Create(nil);
    try
      q.Database := Database;
      q.Transaction := ReadTransaction;
      q.SQL.Text := 'SELECT editorkey FROM gd_ruid WHERE id=:ID';
      q.Params[0].AsInteger := ID;
      q.ExecQuery;
      if not q.EOF then
        Result := q.Fields[0].AsInteger
      else  
        Result := IBLogin.ContactKey;
    finally
      q.Free;
    end;
  end;
end;

function TgdcBase.GetEditorName: String;
var
  q: TIBSQL;
begin
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := ReadTransaction;
    q.SQL.Text := 'SELECT name FROM gd_contact WHERE id=:ID';
    q.Params[0].AsInteger := EditorKey;
    q.ExecQuery;
    if q.EOF then
      Result := ''
    else
      Result := q.Fields[0].AsString;
  finally
    q.Free;
  end;
end;

function TgdcBase.GetExtraConditions: TStrings;
begin
  Result := FExtraConditions;
end;

procedure TgdcBase.DoAfterExtraChanged(Sender: TObject);
var
  WasActive: Boolean;
begin
  WasActive := Active;
  Close;
  FSQLInitialized := False;
  Active := WasActive;
end;

function TgdcBase.GetDSModified: Boolean;
begin
  Result := FDSModified or
    (State = dsInsert) or
    (FOldValues.Count > 0) or
    (CachedUpdates and UpdatesPending);
end;

procedure TgdcBase.DoAfterTransactionEnd(Sender: TObject);
  {@CALL MACRO INH_PARAMS (var)}
begin
  {@CALL MACRO INH_BODY(GDC_BASE, GDC_DOAFTERTRANSACTIONEND)}

  inherited;
  FDSModified := False;

  {@CALL MACRO INH_FINALLY(GDC_BASE, GDC_DOAFTERTRANSACTIONEND)}
end;

function TgdcBase.GetSelectedID: TgdKeyArray;
begin
  Result := FSelectedID;
end;

procedure TgdcBase.AddToSelectedID(const AnID: Integer = -1);
var
  AddId: Integer;
begin
  if AnID = -1 then
    AddId := ID
  else
    AddId := AnID;

  if FSelectedID.IndexOf(AddId) = -1 then
    FSelectedID.Add(AddId);
  FSQLInitialized := False;
end;

procedure TgdcBase.AddToSelectedID(ASelectedID: TgdKeyArray);
var
  I: Integer;
begin
  for I := 0 to ASelectedID.Count - 1 do
    if FSelectedID.IndexOf(ASelectedID.Keys[I]) = -1 then
      FSelectedID.Add(ASelectedID.Keys[I]);
  FSQLInitialized := False;
end;

procedure TgdcBase.RemoveFromSelectedID(const AnID: Integer = -1);
var
  DelId: Integer;
begin
  if AnID = -1 then
    DelId := ID
  else
    DelId := AnID;

  FSelectedID.Remove(DelId);

  { TODO :
тут большая проблема которую еще предстоит решить
поскольку набор выделенных ИД задается не через
параметры а через условие в запросе с непосредстенным
подставлением ИД, то приходится каждый раз переформировать
запрос, что может быть очень больно! }
  FSQLInitialized := False;
end;

function TgdcBase.CheckTheSame: Boolean;
var
  q: TIBSQL;
begin
  if State <> dsInsert then
    raise EgdcBase.CreateObj('Object must be in dsInsert state', Self);
  if SubSet <> 'All' then
    raise EgdcBase.CreateObj('Object must has "All" subset', Self);

  Result := False;
  if CheckTheSameStatement > '' then
  begin
    q := TIBSQL.Create(nil);
    try
      q.Database := Database;
      q.Transaction := ReadTransaction;
      q.SQL.Text := CheckTheSameStatement;
      q.ExecQuery;
      q.Next;
      if q.RecordCount = 1 then
      begin
        Cancel;
        Result := Locate(GetKeyField(SubType), q.Fields[0].AsInteger, []);
      end;
    finally
      q.Free;
    end;
  end;
end;

function TgdcBase.CheckTheSameStatement: String;
begin
  Result := Format('SELECT %s FROM %s WHERE UPPER(%s)=''%s'' ',
    [GetKeyField(SubType), GetListTable(SubType), GetListField(SubType),
     AnsiUpperCase(ObjectName)]);
end;

class function TgdcBase.CommitRequired: Boolean;
begin
  Result := False;
end;

procedure TgdcBase.ExecSingleQuery(const S: String; Param: Variant);
var
  q: TIBSQL;
  I: Integer;
  DidActivate: Boolean;
begin
  DidActivate := False;
  q := TIBSQL.Create(nil);
  try
    q.Database := Database;
    q.Transaction := Transaction;
    DidActivate := ActivateTransaction;
    q.SQL.Text := S;
    q.Prepare;
    if q.Params.Count = 1 then
      q.Params[0].AsVariant := Param
    else
      for I := 0 to q.Params.Count - 1 do
        q.Params[I].AsVariant := Param[I];
    try
      q.ExecQuery;
    except
      if DidActivate then
        Transaction.RollBack;
      raise;
    end;
  finally
    if DidActivate and Transaction.InTransaction then
      Transaction.Commit;
    q.Free;
  end;
end;

function TgdcBase.GetFromClause: String;
begin
  Result := Format('FROM %s %s ', [GetListTable(SubType), GetListTableAlias]);
end;

procedure TgdcBase.InternalSetFieldData(Field: TField; Buffer: Pointer);
var
  I: Integer;
  Found: Boolean;
  FV: TFieldValue;
begin
  if FDataTransfer then
    inherited InternalSetFieldData(Field, Buffer)
  else begin
    if State = dsEdit then
    begin
      Found := False;
      for I := 0 to FOldValues.Count - 1 do
        if AnsiCompareText((FOldValues[I] as TFieldValue).FieldName, Field.FieldName) = 0 then
        begin
          // если поле редактировали дважды и второй раз восстановили
          // первоначальное значение то считаем, что поле не трогали вообще
          if ((FOldValues[I] as TFieldValue).Value = Field.AsString) and
            ((FOldValues[I] as TFieldValue).IsNull = Field.IsNull) then
            FOldValues.Delete(I);
          Found := True;
          break;
        end;
      if not Found then
      begin
        FV := TFieldValue.Create;
        FV.FieldName := Field.FieldName;
        FV.Value := Field.AsString;
        FV.IsNull := Field.IsNull;
        FOldValues.Add(FV);
      end;
    end;
    inherited InternalSetFieldData(Field, Buffer);
    if not (sSyncControls in FBaseState) then
      SyncField(Field);
  end;    
end;

procedure TgdcBase.InternalPrepare;
var
  I, J: Integer;
begin
  if not FSQLInitialized then
    InitSQL;

  inherited InternalPrepare;

  { TODO : 
сохранять-восстанавливать надо только те параметры
которые не участвуют в связи мастер-дитэйл }
  if FSavedParams.Count > 0 then
  begin
    for I := 0 to FSavedParams.Count - 1 do
      for J := 0 to Params.Count - 1 do
        with FSavedParams[I] as TFieldValue do
          if AnsiCompareText(Params[J].Name, FieldName) = 0 then
          begin
            if IsNull then
              Params[J].Clear
            else
              Params[J].AsString := Value;
            break;  
          end;

    FSavedParams.Clear;
  end;
end;

procedure TgdcBase.UnPrepare;
begin
  InternalUnprepare;
end;

procedure TgdcBase.InternalOpen;
begin
  ActivateConnection;
  ActivateReadTransaction;
  if not FSQLInitialized then
    InitSQL;
  InternalSetParamsFromCursor;
  try
    inherited InternalOpen;
  except
    on E: EIBError do
    begin
      if E.IBErrorCode = 335544344 then
      begin
        MessageBox(ParentHandle,
          'Произошла ошибка при создании файла сортировки.'#13#10 +
          'Вероятно закончилось свободное место на диске, где'#13#10 +
          'находится каталог для временных файлов сервера'#13#10 +
          'Interbase/Firebird. Освободите место, увеличте размер'#13#10 +
          'диска или переформулируйте запрос, чтобы он приводил'#13#10 +
          'к меньшей выборке данных.',
          'Ошибка',
          MB_OK or MB_ICONHAND);
        Abort;
      end else
        raise;
    end;
  end;
end;

procedure TgdcBase._DoOnNewRecord;
var
  FN: String;
  Fld: TField;
  I: Integer;
  MO: TDataSet;
begin
  // проверим права на создание записи
  if not TestRightForOp([opAccess, opCreate]) then
    raise EgdcBase.CreateObj('Access denied', Self);

  // присваиваем уникальный идентификатор записи
  if tiID in gdcTableInfos then
  begin
    FieldByName(GetKeyField(SubType)).AsInteger := GetNextID;
  end;

  { TODO : вообще, то надо засунуть его в ТаблеИнфо }
  // если есть поле Дизэйблед, то присваиваем его
  Fld := FindField('disabled');
  if Fld <> nil then
    Fld.AsInteger := 0;

  // присваиваем права записи по-умолчанию
  if Assigned(IBLogin) then
  begin
    if tiCreationInfo in gdcTableInfos then
    begin
      FieldByName('CREATORKEY').AsInteger := IBLogin.ContactKey;
      FieldByName('CREATIONDATE').AsDateTime := Now;
    end;

    if tiEditionInfo in gdcTableInfos then
    begin
      FieldByName('EDITORKEY').AsInteger := IBLogin.ContactKey;
      FieldByName('EDITIONDATE').AsDateTime := Now;
    end;

    if tiAView in gdcTableInfos then
      FieldByName('aview').AsInteger := IBLogin.InGroup;
    if tiAChag in gdcTableInfos then
      FieldByName('achag').AsInteger := IBLogin.InGroup;
    if tiAFull in gdcTableInfos then
      FieldByName('afull').AsInteger := IBLogin.InGroup;
  end else
    raise EgdcBase.CreateObj('IBLogin is not assigned', Self);

  // если объект связан с другим объектом, то проинициализируем ссылку
  if (MasterSource <> nil)
    and (MasterSource.DataSet <> nil)
    and MasterSource.DataSet.Active then
    MO := MasterSource.DataSet
  else
    MO := nil;

  if (MO <> nil) and (MO.State <> dsSetKey) then
    with FgdcDataLink do
  begin
    if FSetTable = '' then
    begin
      for I := 0 to FDetailField.Count - 1 do
        if (UpperCase(FDetailField[I]) <> 'LB') and (UpperCase(FDetailField[I]) <> 'RB') then
        begin
          FN := GetFieldNameComparedToParam(FDetailField[I]);
          if FindField(FN) <> nil then
          begin
            FieldByName(FN).Assign(MO.FieldByName(FMasterField[I]));
          end else
            { TODO :
не всегда надо присваивать детальные поля!
может вместо эксепшена ничего не делать? }
            raise EgdcBase.CreateObj(Format('Detail field "%s" to set not found.', [FN]), Self);
        end
    end else begin
      { TODO : непосредственно прописываем имя поля ИД }
      FieldByName(FSetMasterField).AsInteger := MO.FieldByName('id').AsInteger;
      FieldByName(FSetItemField).AsInteger := ID;
    end;
  end;
end;

class function TgdcBase.GetViewFormClassName(
  const ASubType: TgdcSubType): String;
begin
  Result := '';
end;

class function TgdcBase.IsAbstractClass: Boolean;
begin
  Result := Self.ClassNameIs('TgdcBase');
end;

function TgdcBase.GetSubSet: TgdcSubSet;
begin
  if Assigned(FSubSets) then
    Result := FSubSets.CommaText
  else
    Result := '';
end;

function TgdcBase.GetSubSetCount: Integer;
begin
  Result := FSubSets.Count;
end;

function TgdcBase.GetSubSets(Index: Integer): TgdcSubSet;
begin
  Result := FSubSets[Index];
end;

procedure TgdcBase.SetSubSets(Index: Integer; const Value: TgdcSubSet);
begin
  if CheckSubSet(Value) then
    FSubSets[Index] := Value
  else
    raise EgdcBase.CreateObj('Invalid sub set', Self);  
end;

procedure TgdcBase.DeleteSubSet(const Index: Integer);
var
  WasActive: Boolean;
begin
  WasActive := Active;
  Close;
  FSubSets.Delete(Index);
  FSQLInitialized := False;
  Active := WasActive;
end;

function TgdcBase.HasSubSet(const ASubSet: TgdcSubSet): Boolean;
begin
  Result := FSubSets.IndexOf(ASubSet) <> -1;
end;

procedure TgdcBase.RemoveSubSet(const ASubSet: TgdcSubSet);
begin
  DeleteSubSet(FSubSets.IndexOf(ASubSet));
end;

procedure TgdcBase.AddSubSet(const ASubSet: TgdcSubSet);
var
  WasActive: Boolean;
begin
  if CheckSubSet(ASubSet) and (FSubSets.IndexOf(ASubSet) = -1) then
  begin
    WasActive := Active;
    Close;
    FSubSets.Add(ASubSet);
    FSQLInitialized := False;
    Active := WasActive;
  end else
    raise EgdcBase.CreateObj('Invalid sub set', Self);
end;

procedure TgdcBase.ClearSubSets;
var
  WasActive: Boolean;
begin
  WasActive := Active;
  Close;
  FSubSets.Clear;
  FSubSets.Add('All');
  FSQLInitialized := False;
  Active := WasActive;
end;

procedure TgdcBase.InternalUnPrepare;
var
  I: Integer;
  FV: TFieldValue;
  SL: TStringList;
begin
  FSavedParams.Clear;
  SL := TStringList.Create;
  try
    for I := 0 to Params.Count - 1 do
    begin
      if SL.IndexOf(Params[I].Name) = -1 then
      begin
        FV := TFieldValue.Create;
        FV.FieldName := Params[I].Name;
        FV.Value := Params[I].AsString;
        FV.IsNull := Params[I].IsNull;
        FSavedParams.Add(FV);
        SL.Add(Params[I].Name);
      end;
    end;
  finally
    SL.Free;
  end;

  inherited;
end;

procedure TgdcBase.LoadDialogDefaults;
{$IFDEF GEDEMIN}
var
  F: TgsStorageFolder;
  DlgForm: TForm;
{$ENDIF}
begin
  if FDlgStack.Count > 0 then
  begin
    {$IFDEF GEDEMIN}
    DlgForm := FDlgStack.Peek as TForm;

    if Assigned(UserStorage) then
    begin
      F := UserStorage.OpenFolder(ClassName + SubType + '\' + DlgForm.ClassName, False, False);
      try
        if F <> nil then
          LoadDialogDefaults(F, DlgForm);
      finally
        UserStorage.CloseFolder(F);
      end;
    end;
    {$ENDIF}
  end else
    raise Exception.Create(GetGsException(Self, 'No dialog form found'));
end;

procedure TgdcBase.SaveDialogDefaults;
{$IFDEF GEDEMIN}
var
  DlgForm: TForm;
  F: TgsStorageFolder;
{$ENDIF}
begin
  if FDlgStack.Count > 0 then
  begin
    {$IFDEF GEDEMIN}
    DlgForm := FDlgStack.Peek as TForm;

    if Assigned(UserStorage) and (GetDialogDefaultsFields > '') then
    begin
      F := UserStorage.OpenFolder(ClassName + SubType + '\' + DlgForm.ClassName, True, False);
      try
        if F <> nil then
          SaveDialogDefaults(F, DlgForm);
  { TODO :  тут надо проверить и если ничего не сохранено удалить папку }
      finally
        UserStorage.CloseFolder(F);
      end;
    end;
    {$ENDIF}
  end else
    raise Exception.Create(GetGsException(Self, 'No dialog form found'));
end;

function TgdcBase.CreateReadIBSQL: TIBSQL;
begin
  Result := TIBSQL.Create(nil);
  Result.Database := Database;
  Result.Transaction := ReadTransaction;
end;

function TgdcBase.CreateReadIBSQL(out DidActivate: Boolean): TIBSQL;
begin
  Result := CreateReadIBSQL;
  DidActivate := ActivateReadTransaction;
end;

class function TgdcBase.CreateSingularByID(AnOwner: TComponent;
  const AnID: TID; const ASubType: String): TgdcBase;
begin
  Result := Self.CreateSubType(AnOwner, ASubType, 'ByID');
  Result.ParamByName('id').AsInteger := AnID;
  Result.Open;
  Result.Next;
  if Result.RecordCount <> 1 then
  begin
    Result.Free;
    raise EgdcBase.Create(Self.ClassName + ': ID not found (' + IntToStr(AnID) + ')');
  end else
    Result.First;
end;

procedure TgdcBase.SetTransaction(Value: TIBTransaction);
begin
  if Transaction <> Value then
  begin
    // если мы пытаемся присвоить другую транзакцию взамен
    // внутренней и внутренняя транзакция используется только
    // у нас и она открыта, то выдадим ошибку.
    // такая ситуация говорит о том, что программист начал
    // сложную операцию, вовлекающую несколько датасетов,
    // открыл вручную транзакцию и, не закрыв ее, т.е. не
    // завершив сложной операции пытается переприсвоить
    // транзакцию
    if Assigned(Transaction) and (Transaction = FInternalTransaction)
      and Transaction.InTransaction
      and (Transaction.SQLObjectCount = 1) then
    begin
      if Transaction <> ReadTransaction then
        raise Exception.Create(GetGsException(Self, 'Transaction active'))
      else
        Transaction.Commit;
    end;

    inherited;
  end;
end;

procedure TgdcBase.InternalSetParamsFromCursor;
var
  i: Integer;
  cur_param: TIBXSQLVAR;
  cur_field: TField;
  s: TStream;
begin
  if FQSelect.SQL.Text = '' then
    IBError(ibxeEmptyQuery, [nil]);
  {if not FInternalPrepared then
    InternalPrepare;}
  if (SQLParams.Count > 0) and (FgdcDataLink <> nil) and (FgdcDataLink.DataSet <> nil) then
  begin
    for I := 0 to FgdcDataLink.FMasterField.Count - 1 do
    begin
      cur_field := FgdcDataLink.DataSet.FindField(FgdcDataLink.FMasterField[I]);
      cur_param := ParamByName(FgdcDataLink.FDetailField[I]);
      if (cur_field <> nil) then
      begin
        if (cur_field.IsNull) then
          cur_param.IsNull := True
        else case cur_field.DataType of
          ftString:
            cur_param.AsString := cur_field.AsString;
          ftBoolean, ftSmallint, ftWord:
            cur_param.AsShort := cur_field.AsInteger;
          ftInteger:
            cur_param.AsLong := cur_field.AsInteger;
          ftLargeInt:
            cur_param.AsInt64 := TLargeIntField(cur_field).AsLargeInt;
          ftFloat, ftCurrency:
           cur_param.AsDouble := cur_field.AsFloat;
          ftBCD:
            cur_param.AsCurrency := cur_field.AsCurrency;
          ftDate:
            cur_param.AsDate := cur_field.AsDateTime;
          ftTime:
            cur_param.AsTime := cur_field.AsDateTime;
          ftDateTime:
            cur_param.AsDateTime := cur_field.AsDateTime;
          ftBlob, ftMemo:
          begin
            s := nil;
            try
              s := DataSource.DataSet.
                     CreateBlobStream(cur_field, bmRead);
              cur_param.LoadFromStream(s);
            finally
              s.free;
            end;
          end;
          else
            IBError(ibxeNotSupported, [nil]);
        end;
      end;
    end;

    {
    for i := 0 to SQLParams.Count - 1 do
    begin
      cur_field := DataSource.DataSet.FindField(SQLParams[i].Name);
      cur_param := SQLParams[i];
      if (cur_field <> nil) then
      begin
        if (cur_field.IsNull) then
          cur_param.IsNull := True
        else case cur_field.DataType of
          ftString:
            cur_param.AsString := cur_field.AsString;
          ftBoolean, ftSmallint, ftWord:
            cur_param.AsShort := cur_field.AsInteger;
          ftInteger:
            cur_param.AsLong := cur_field.AsInteger;
          ftLargeInt:
            cur_param.AsInt64 := TLargeIntField(cur_field).AsLargeInt;
          ftFloat, ftCurrency:
           cur_param.AsDouble := cur_field.AsFloat;
          ftBCD:
            cur_param.AsCurrency := cur_field.AsCurrency;
          ftDate:
            cur_param.AsDate := cur_field.AsDateTime;
          ftTime:
            cur_param.AsTime := cur_field.AsDateTime;
          ftDateTime:
            cur_param.AsDateTime := cur_field.AsDateTime;
          ftBlob, ftMemo:
          begin
            s := nil;
            try
              s := DataSource.DataSet.
                     CreateBlobStream(cur_field, bmRead);
              cur_param.LoadFromStream(s);
            finally
              s.free;
            end;
          end;
          else
            IBError(ibxeNotSupported, [nil]);
        end;
      end;
    end;
    }
  end;
end;

procedure TgdcBase.RefreshParams;
var
  DataSet: TDataSet;

  function NeedsRefreshing : Boolean;
  var
    i : Integer;
    cur_param: TIBXSQLVAR;
    cur_field: TField;
  begin
    Result := true;
    i := 0;
    while (i < FgdcDataLink.FMasterField.Count) and (Result) do
    begin
      cur_field := MasterSource.DataSet.FindField(FgdcDataLink.FMasterField[I]);
      cur_param := ParamByName(FgdcDataLink.FDetailField[I]);
      if (cur_field <> nil) then
      begin
        if (cur_field.IsNull) then
          Result := Result and cur_param.IsNull
        else
        case cur_field.DataType of
          ftString:
            Result := Result and (cur_param.AsString = cur_field.AsString);
          ftBoolean, ftSmallint, ftWord:
            Result := Result and (cur_param.AsShort = cur_field.AsInteger);
          ftInteger:
            Result := Result and (cur_param.AsLong = cur_field.AsInteger);
          ftLargeInt:
            Result := Result and (cur_param.AsInt64 = TLargeIntField(cur_field).AsLargeInt);
          ftFloat, ftCurrency:
            Result := Result and (cur_param.AsDouble = cur_field.AsFloat);
          ftBCD:
            Result := Result and (cur_param.AsCurrency = cur_field.AsCurrency);
          ftDate:
            Result := Result and (cur_param.AsDate = cur_field.AsDateTime);
          ftTime:
            Result := Result and (cur_param.AsTime = cur_field.AsDateTime);
          ftDateTime:
            Result := Result and (cur_param.AsDateTime = cur_field.AsDateTime);
          else
            Result := false;
        end;
      end;
      Inc(i);
    end;
    Result := not Result;
  end;

begin
  DisableControls;
  try
    if Assigned(FgdcDataLink) and (FgdcDataLink.DataSource <> nil) then
    begin
      DataSet := FgdcDataLink.DataSource.DataSet;
      if DataSet <> nil then
        if DataSet.Active and (DataSet.State <> dsSetKey) and NeedsRefreshing then
        begin
          Close;
          Open;
        end;
    end;
  finally
    EnableControls;
  end;
end;

function TgdcBase.OnInvoker(const Name: WideString; AnParams: OleVariant): OleVariant;
var
  LBuff: Pointer;
  LSender: TObject;
begin
  // проверка имени метода
  if  AnsiUpperCase(Name) = GDC_CUSTOMINSERT then
  begin
    // преобразование параметров для метода Делфи
    LBuff := Pointer(Integer(AnParams[1]));
    // вызов метода Делфи с актуальными параметрами
    // если это фунция, то вызов: Result  := Метод Делфи, если нет, то Метод Делфи
    CustomInsert(LBuff);
    // если есть var параметры обратное передача параметров из метода в вариантнвй массив AnParams
    { AnParams[..] := ...;
      ....
    }
  end else
  if  AnsiUpperCase(Name) = GDC_CUSTOMDELETE then
  begin
    LBuff := Pointer(Integer(AnParams[1]));
    CustomDelete(LBuff);
  end else
  if  AnsiUpperCase(Name) = GDC_CUSTOMMODIFY then
  begin
    LBuff := Pointer(Integer(AnParams[1]));
    CustomModify(LBuff);
  end else
  if  AnsiUpperCase(Name) = GDC_DoAfterDelete then
  begin
    DoAfterDelete;
  end else
  if  AnsiUpperCase(Name) = GDC_DOAFTERINSERT then
  begin
    DoAfterInsert;
  end else
  if  AnsiUpperCase(Name) = GDC_DOAFTEROPEN then
  begin
    DoAfterOpen;
  end else
  if  AnsiUpperCase(Name) = GDC_DOAFTERPOST then
  begin
    DoAfterPost;
  end else
  if  AnsiUpperCase(Name) = GDC_DOAFTERTRANSACTIONEND then
  begin
    LSender := InterfaceToObject(AnParams[1]);

    DoAfterTransactionEnd(LSender);
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFORECLOSE then
  begin
    DoBeforeClose;
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFOREDELETE then
  begin
    DoBeforeDelete;
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFOREEDIT then
  begin
    DoBeforeEdit;
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFOREINSERT then
  begin
    DoBeforeInsert;
  end else
  if  AnsiUpperCase(Name) = GDC_DOBEFOREPOST then
  begin
    DoBeforePost;
  end else
  if  AnsiUpperCase(Name) = GDC_DOONNEWRECORD then
  begin
    DoOnNewRecord;
  end else
  if  AnsiUpperCase(Name) = GDC_GETNOTCOPYFIELD then
  begin
    Result := GetNotCopyField;
  end else
{  if  AnsiUpperCase(Name) = GDC_GETNOTCOPYFIELD then
  begin
    ValidateField;
  end else}
  ;

end;

class procedure TgdcBase.RegisterMethod;
begin
  RegisterClassMethod(TgdcBase, 'CustomInsert', 'Self: Object; Buff: Variable', '');
  RegisterClassMethod(TgdcBase, 'CustomModify', 'Self: Object; Buff: Variable', '');
  RegisterClassMethod(TgdcBase, 'CustomDelete', 'Self: Object; Buff: Variable', '');

  RegisterClassMethod(TgdcBase, 'DoAfterDelete', 'Self: Object', '');
  RegisterClassMethod(TgdcBase, 'DoAfterInsert', 'Self: Object', '');
  RegisterClassMethod(TgdcBase, 'DoAfterOpen', 'Self: Object', '');
  RegisterClassMethod(TgdcBase, 'DoAfterPost', 'Self: Object', '');
  RegisterClassMethod(TgdcBase, 'DoBeforeClose', 'Self: Object', '');
  RegisterClassMethod(TgdcBase, 'DoBeforeDelete', 'Self: Object', '');
  RegisterClassMethod(TgdcBase, 'DoBeforeEdit', 'Self: Object', '');
  RegisterClassMethod(TgdcBase, 'DoBeforeInsert', 'Self: Object', '');
  RegisterClassMethod(TgdcBase, 'DoBeforePost', 'Self: Object', '');
  RegisterClassMethod(TgdcBase, 'DoAfterTransactionEnd', 'Self: Object; ASender: Object', '');

  RegisterClassMethod(TgdcBase, 'GetNotCopyField', 'Self: Object', 'Integer');

  RegisterClassMethod(TgdcBase, 'DoOnNewRecord', 'Self: Object', '');

//  RegisterClassMethod(TgdcBase, 'ValidateField', 'Self: Object; Sender: Object', '');

{
//  RegisterClassMethod(TgdcBase, 'CustomInsert', 'Self: TObject; Buff: Integer', '');
  RegisterClassMethod(TgdcBase, 'CustomModify', 'Self: TObject; Buff: Integer', '');
  RegisterClassMethod(TgdcBase, 'CustomDelete', 'Self: TObject; Buff: Integer', '');

  RegisterClassMethod(TgdcBase, 'DoAfterDelete', 'Self: TObject', '');
  RegisterClassMethod(TgdcBase, 'DoAfterInsert', 'Self: TObject', '');
  RegisterClassMethod(TgdcBase, 'DoAfterOpen', 'Self: TObject', '');
  RegisterClassMethod(TgdcBase, 'DoAfterPost', 'Self: TObject', '');
  RegisterClassMethod(TgdcBase, 'DoBeforeClose', 'Self: TObject', '');
  RegisterClassMethod(TgdcBase, 'DoBeforeDelete', 'Self: TObject', '');
  RegisterClassMethod(TgdcBase, 'DoBeforeEdit', 'Self: TObject', '');
  RegisterClassMethod(TgdcBase, 'DoBeforeInsert', 'Self: TObject', '');
  RegisterClassMethod(TgdcBase, 'DoBeforePost', 'Self: TObject', '');

  RegisterClassMethod(TgdcBase, 'DoAfterTransactionEnd', 'Self: TObject; ASender: TObject', '');
 }
end;

{ TClassListForMethod }


function TgdcBase.IsSubSetStored: Boolean;
begin
  Result := SubSet <> 'All';
end;

function TgdcBase.IsNameInScriptStored: Boolean;
begin
  Result := FNameInScript > '';
end;

function TgdcBase.IsReadTransactionStored: Boolean;
{var
  DS: TIBCustomDataSet;}
begin
  {if (FgdcDataLink <> nil) and (FgdcDataLink.DataSet is TIBCustomDataSet) then
    DS := FgdcDataLink.DataSet as TIBCustomDataSet
  else
    DS := nil;}

  Result := {((DS = nil) or (DS.ReadTransaction <> ReadTransaction)) and}
    ((gdcBaseManager = nil) or (gdcBaseManager.ReadTransaction <> ReadTransaction));
end;

function TgdcBase.IsTransactionStored: Boolean;
{var
  DS: TIBCustomDataSet;}
begin
  {if (FgdcDataLink <> nil) and (FgdcDataLink.DataSet is TIBCustomDataSet) then
    DS := FgdcDataLink.DataSet as TIBCustomDataSet
  else
    DS := nil;}

  Result := (Transaction <> FInternalTransaction) {and}
    {(MasterSource = nil)}
    {((DS = nil) or (DS.Transaction <> Transaction))};
end;

procedure TgdcBase.CheckCurrentRecord;
begin
  CheckActive;
  if IsEmpty then
    raise Exception.Create(GetGsException(Self, 'Record is not accessible'));
end;

{ TClassListForMethod }

{function TClassListForMethod.Add(const S: string): Integer;
begin
  Result := IndexOf(S);
  if Result = -1 then
    Result := inherited Add(S)
end;
 }
{ TgdcTransactionGuard }

constructor TgdcTransactionGuard.Create(ATransaction: TIBTransaction);
begin
  FTransaction := ATransaction;
  if FTransaction.InTransaction then
    FDidActivate := False
  else begin
    FDidActivate := True;
    FTransaction.StartTransaction;
  end;
  FAction := taCommit;
end;

destructor TgdcTransactionGuard.Destroy;
begin
  if FDidActivate and FTransaction.InTransaction then
    case FAction of
      taCommit: FTransaction.Commit;
      taRollback: FTransaction.Rollback;
      taCommitRetaining: FTransaction.CommitRetaining;
      taRollbackRetaining: FTransaction.RollbackRetaining;
    end;
  inherited;
end;

function TgdcTransactionGuard.GetAction: TTransactionAction;
begin
  Result := FAction;
end;

function TgdcTransactionGuard.GetTransaction: TIBTransaction;
begin
  Result := FTransaction;
end;

procedure TgdcTransactionGuard.SetAction(AnAction: TTransactionAction);
begin
  FAction := AnAction;
end;

{ TgdcQTransactionGuard }

constructor TgdcQTransactionGuard.Create(ATransaction: TIBTransaction);
begin
  inherited Create(ATransaction);
  Fq := TIBSQL.Create(nil);
  Fq.Transaction := Transaction;
end;

destructor TgdcQTransactionGuard.Destroy;
begin
  FreeAndNil(Fq);
  inherited;
end;

function TgdcQTransactionGuard.GetQ: TIBSQL;
begin
  Result := Fq;
end;

function TgdcBase.GetReductionCondition: String;
begin
  Result := '';
end;

function TgdcBase.GetReductionTable: String;
begin
  Result := GetListTable(SubType);
end;

procedure TgdcBase.ClearMacrosStack(const AClass, AMethod: String);
var
  Index: Integer;
begin
  Index := FunctionClassList.IndexOf(AClass + '.' + AMethod);
  if Index > -1 then
  begin
    FunctionClassList.Delete(Index);
    Index := LastCallClass.IndexOf(AMethod);
    if Index > -1 then
    begin
      TStrings(LastCallClass.Objects[LastCallClass.IndexOf(AMethod)]).Free;
      LastCallClass.Delete(LastCallClass.IndexOf(AMethod));
    end;
  end;
end;

procedure TgdcBase.SetFirstClassMethod(const AClass, AMethod: String);
var
  Index: Integer;
begin
  if FunctionClassList.Count = 0 then
    FunctionClassList.Add(AClass + '.' + AMethod)
  else
    for Index := 0 to FunctionClassList.Count - 1 do
      if Pos(AMethod, FunctionClassList[Index]) = 0 then
        FunctionClassList.Add(UpperCase(AClass + '.' + AMethod));
end;

procedure TgdcBase.SetSelectedID(const Value: TgdKeyArray);
begin
  FSelectedID.Assign(Value);
  FSQLInitialized := False;
end;

{DoProcess указывает, вызывать ли метод для обработки выбранных записей}
procedure TgdcBase.ChooseItems(DoProcess: Boolean = True);
var
  C: TPersistentClass;
begin
  FSelectedID.Clear;
  C := GetClass(GetViewFormClassName(''));
  if (C <> nil) and C.InheritsFrom(Tgdc_frmG) then
    with CCreateableForm(C).Create(Application) as Tgdc_frmG do
    begin
      try
        SetChoose(Self);
        if ShowModal = mrOk then
        begin
          FSelectedID.Assign(gdcChooseObject.SelectedID);
          try
            if DoProcess then
              ProcessChooseItems(Self);
          except
            raise EgdcException.Create('Ошибка при вставке записи в группу!');
          end;
          FDSModified := True;
          CloseOpen;
        end
        else
          FSelectedID.Add(-1);
      finally
        Free;
      end;
    end;
end;

function TgdcBase.ChooseItems(Cl: CgdcBase; out KeyArray: TgdKeyArray; DoProcess: Boolean): Boolean;
var
  Obj: TgdcBase;
  C: TPersistentClass;
begin
  Result := False;
  Obj := Cl.CreateWithParams(Owner, Database, Transaction);
  try
    Obj.SelectedID.Clear;
    Obj.Open;
    C := GetClass(Obj.GetViewFormClassName(''));
    if (C <> nil) and C.InheritsFrom(Tgdc_frmG) then
      with CCreateableForm(C).Create(Application) as Tgdc_frmG do
      begin
        try
          SetChoose(Obj);
          if ShowModal = mrOk then
          begin
            Obj.SelectedID.Assign(gdcChooseObject.SelectedID);
            Obj.Close;
            Obj.SubSet := 'OnlySelected';
            Obj.Open;
            try
              if DoProcess then
                ProcessChooseItems(Obj);
            except
              raise EgdcException.Create('Ошибка при вставке записи в группу!');
            end;
            FDSModified := True;
            CloseOpen;
            Result := True;
          end
          else
            Obj.SelectedID.Add(-1);
        finally
          Free;
        end;
      end;
    KeyArray.Assign(Obj.SelectedID);
  finally
    Obj.Free;
  end;
end;

procedure TgdcBase.ProcessChooseItems(AnObject: TgdcBase);
begin
  //
end;

procedure TgdcBase.DeleteChooseItems(BL: TBookmarkList);
var
  I: Integer;
begin
  if (BL = nil) or (BL.Count <= 1) then
  begin
    if (RecordCount > 0) and
       (
         (not (sView in BaseState)) or
         (MessageBox(ParentHandle, PChar(Format('Удалить выделенную запись "%s"?', [ObjectName])), 'Внимание!', MB_YESNO + MB_ICONQUESTION) = IDYES)
       ) then
    begin
      try
        DeleteChoose;
      except
        raise EgdcException.Create('Ошибка при удалении записи из группы!');
      end;
    end;
  end
  else
    if (not (sView in BaseState)) or (MessageBox(ParentHandle,
          PChar(Format('Выделено записей: %d'#13#10'Удалить?', [BL.Count])),
          'Внимание!',
          MB_YESNO + MB_ICONQUESTION) = IDYES) then
    begin
      DisableControls;
      try
        for I := 0 to BL.Count - 1 do
        begin
          Bookmark := BL[I];
          try
            DeleteChoose;
          except
            raise EgdcException.Create('Ошибка при удалении записи из группы!');
          end;
        end;
      finally
        EnableControls;
      end;
    end;
  FDSModified := True;
  CloseOpen;
end;

procedure TgdcBase.DeleteChoose;
begin
//
end;


procedure TgdcBase.SetSetTable(const Value: String);
begin
  CheckDataSetClosed;
  if FSetTable <> Value then
  begin
    FSetTable := Value;
    if FSetTable > '' then
    begin
      MasterField := 'ID';
      DetailField := 'MASTER_RECORD_ID';
    end;
    FSetMasterField := '';
    FSetItemField := '';  
    FSQLInitialized := False;
  end;
end;

procedure TgdcBase.SetExclude(const AnID: TID);
var
  Bm: String;
begin
  CheckBrowseMode;

  ExecSingleQuery(Format('DELETE FROM %s WHERE %s = %d AND %s = %d',
    [FSetTable, FSetMasterField, ParamByName('MASTER_RECORD_ID').AsInteger,
     FSetItemField, AnID]));

  FDataTransfer := True;
  try
    Bm := Bookmark;
    DisableControls;
    try
      if Locate(GetKeyField(SubType), AnID, []) then
      begin
        Delete;
      end;
      if BookmarkValid(Pointer(Bm)) then
        Bookmark := Bm;
    finally
      EnableControls;
    end;
  finally
    FDataTransfer := False;
  end;
end;

procedure TgdcBase.SetInclude(const AnID: TID);
begin
  { TODO : нужна проверка находимся ли мы в режиме множества. }
  CheckBrowseMode;

  try
    ExecSingleQuery(Format('INSERT INTO %s (%s, %s) VALUES (%d, %d)',
      [FSetTable, FSetMasterField, FSetItemField,
       ParamByName('MASTER_RECORD_ID').AsInteger, AnID]));
       
    DisableControls;
    try
      Close;
      Open;
      Locate(FSetItemField, AnID, []);
    finally
      EnableControls;
    end;
  except
    on E: EIBError do
    begin
      // при попытке добавить элемент второй раз
      // будет исключение
      // подавим его
      if E.IBErrorCode <> 335544665 then
        raise;
    end;
  end;
end;

function TgdcBase.GetMethodControl: IMethodControl;
begin
  Result := nil;
  if Assigned(MethodControl) and (not UnMethodMacro) then
    Result := MethodControl;
end;

function TgdcBase.GetGdcInterface(Source: TObject): IDispatch;
begin
  Result := GetGdcOLEObject(Source) as IDispatch;
end;

initialization
  gdcClipboardFormat := RegisterClipboardFormat(gdcClipboardFormatName);

  RegisterGDCClasses([TgdcBase]);

  // Регистрация методов TgdcBase для перекрытия их из макросов
  TgdcBase.RegisterMethod;

finalization

  UnRegisterGDCClass(TgdcBase);

{***@DECLARE MACRO Inh_Params (%Var%)
%Var%
  Params, LResult: Variant;
  Index: Integer;
  InheritedFlag: Boolean;
END MACRO}

{***@DECLARE MACRO Inh_Body(%ClassName%, %MethodName%)
  try
    if Assigned(MethodControl) then
    begin
      InheritedFlag := False;
      SetFirstClassMethod(%ClassName%, %MethodName%);
      Index := LastCallClass.IndexOf(%MethodName%);
      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcOLEObject(Self) as IDispatch]);
        if MethodControl.ExecuteMethod(LastCallClass, Self, %ClassName%,
          %MethodName%, Params, LResult) then exit;
      end else
        if (TStrings(LastCallClass.Objects[Index]).IndexOf(%ClassName%) > -1) and
          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
          <> %ClassName%) then
        begin
          InheritedFlag := True;
        end;
    end else
      InheritedFlag := True;

    if InheritedFlag then
    begin
END MACRO}

{***@DECLARE MACRO Inh_Finally (%ClassName%, %MethodName%)
    end;
  finally
    if Assigned(MethodControl) then
      ClearMacrosStack(%ClassName%, %MethodName%);
  end;
END MACRO}


//For methods without parameters
{@DECLARE MACRO INH_ORIG_WITHOUTPARAM(%ClassName%, %MethodName%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstClassMethod(%ClassName%, %MethodName%);
      Index := LastCallClass.IndexOf(%MethodName%);
      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self)]);
        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, %ClassName%,
          %MethodName%, Params, LResult) then
          exit;
      end else
        //
        if (TStrings(LastCallClass.Objects[Index]).IndexOf(%ClassName%) > -1) and
          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
          <> UpperCase(%ClassName%)) then
        begin
          if MethodWithInherited.IndexOf(%ClassName% + '.' + %MethodName%) > -1 then
            Inherited;
          Exit;
        end;
        MethodWithInherited.Add(%ClassName% + '.' + %MethodName%);
    end;
END MACRO}


//FOR CustomInsert
{@DECLARE MACRO Inh_Orig_CustomInsert(%ClassName%, %MethodName%)
  try
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      SetFirstClassMethod(%ClassName%, %MethodName%);
      Index := LastCallClass.IndexOf(%MethodName%);
      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf(%ClassName%) = -1) then
      begin
        Params := VarArrayOf([GetGdcInterface(Self), Integer(Buff)]);
        if gdcBaseMethodControl.ExecuteMethod(LastCallClass, Self, %ClassName%,
          %MethodName%, Params, LResult) then
          exit;
      end else
        //
        if (TStrings(LastCallClass.Objects[Index]).IndexOf(%ClassName%) > -1) and
          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
          <> UpperCase(%ClassName%)) then
        begin
          if MethodWithInherited.IndexOf(%ClassName% + '.' + %MethodName%) > -1 then
            Inherited;
          Exit;
        end;
        MethodWithInherited.Add(%ClassName% + '.' + %MethodName%);
    end;
END MACRO}

{@DECLARE MACRO Inh_Orig_Params(%Var%)
%Var%
  Params, LResult: Variant;
  Index: Integer;
END MACRO}

{@DECLARE MACRO Inh_Orig_Finally(%ClassName%, %MethodName%)
  finally
    if (not FDataTransfer) and Assigned(gdcBaseMethodControl) then
    begin
      if MethodWithInherited.IndexOf(%ClassName% +
        '.' + %MethodName%) > - 1 then
        MethodWithInherited.Delete(MethodWithInherited.IndexOf(%ClassName% +
          '.' + %MethodName%));
      ClearMacrosStack(%ClassName%, %MethodName%);
    end;
  end;
END MACRO}

// болванка для перекрытия методов
(*
var
  Params, LResult: Variant;
  Index: Integer;
begin
  try
    // Начало обработки перекрытия метода
    if Assigned(MethodControl) then
    begin
      // установка первого вызова
      SetFirstClassMethod(GDC_BASE, GDC_METHOD);
      // получаем индекс метода в стека
      Index := LastCallClass.IndexOf(GDC_METHOD);
      // если метода нет в стеке, то вызываем макрос
      // если метод есть в стеке, то метод вызван из инхирит макроса
      if (Index = -1) or (TStrings(LastCallClass.Objects[Index]).IndexOf(GDC_BASE) = -1) then
      begin
        // формирование вариантного массива параметров для вызова макроса
        // Self передается всегда, далее параметры метода, если они есть
        Params := VarArrayOf([GetGdcOLEObject(Self) as IDispatch]);
        if MethodControl.ExecuteMethod(LastCallClass, Self, GDC_BASE,
          GDC_METHOD, Params, LResult) then
          exit;
      end else
        //
        if (TStrings(LastCallClass.Objects[Index]).IndexOf(GDC_BASE) > -1) and
          (TStrings(LastCallClass.Objects[Index])[TStrings(LastCallClass.Objects[Index]).Count - 1]
          <> UpperCase(GDC_BASE)) then
        begin
          // Если класс.метод есть в списке значит в сюда попали через
          // Inherited метода данного класса, следовательно переходим
          // к методу родителя
          if MethodWithInherited.IndexOf(%ClassName% + '.'
            + %MethodName%) > -1 then
          // доступ из макроса к методу родителя класса идет через Inherited
            Inherited;
          Exit;
        end;
        // перед выполнение тела метода Делфи заносим информацию
        // класс.метод в список
        MethodWithInherited.Add(%ClassName% + '.' + %MethodName%);
    end;
    // Конец обработки перекрытия метода
    // далее следует код метода Делфи, где обязательно должен быть ClearMacrosStack

    ShowMessage('Delphi TgdcBase.');

    CodeMethod;

  finally
    // !!! очистка стека обязательна, т.к.
    // если стек не обнулится, то при следующем вызове метода он не отработает
    // весь код метода включается в блок try finally, где в finally ClearMacrosStack
    if Assigned(MethodControl) then
      // если класс.метод есть в списке, то удаляем его
      if MethodWithInherited.IndexOf(%ClassName% +
        '.' + %MethodName%) > - 1 then
        MethodWithInherited.Delete(MethodWithInherited.IndexOf(%ClassName% +
          '.' + %MethodName%));
      // очистка стека
      ClearMacrosStack(GDC_BASE, GDC_METHOD);
  end;
end;
*)
end.



