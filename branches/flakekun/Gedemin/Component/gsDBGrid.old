
{++


  Copyright (c) 2000 by Golden Software of Belarus

  Module

    gsDBGrid.pas

  Abstract

    Original Delphi's DBGrid with additional options.

  Author

    Romanovski Denis (31-08-2000)

  Revisions history

    Initial  31-08-2000  Dennis  Initial version.


--}

unit gsDBGrid;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  Grids, DBGrids, StdCtrls, ComCtrls, Menus, ActnList, DB, xCalc, Imglist;


const
  DefStripeEven = $00D6E7E7;
  DefStripeOdd = $00E7F3F7;


///////////////////////////////////////////////////////
// Вид меню для класса TCustomgsDBgrid
// imkSubMenu - добавление меню группой
// imkWithSeparator - добавление меню через разделитель

type
  TInternalMenuKind = (imkSubMenu, imkWithSeparator);

//////////////////////////////////////////////
// Вид условия для TCondition
// ckEqual - равно
// ckNotEqual - не равно
// ckIn - внутри
// ckOut - вне
// ckBigger - больше
// ckSmaller меньше
// ckBiggerEqual - больше или равно
// ckSmallerEqual - меньше или равно
// ckStarts - начинается с (только для текста)
// ckContains - содержит (только для текста)

type
  TConditionKind =
    (
    ckEqual, ckNotEqual, ckIn, ckOut, ckBigger, ckSmaller,
    ckBiggerEqual, ckSmallerEqual, ckStarts, ckContains, ckExist, ckNotExist, ckNone
    );

//////////////////////////////////////////    
// Опции отображения для класса TCondition
// doColor - отображать цвет
// doFont - отображать шрифт

type
  TDisplayOption = (doColor, doFont);
  TDisplayOptions = set of TDisplayOption;

/////////////////////////////////////////////////////////////////////////////
// Состояние условия для класса TCondition
// csPrepared - условие подготовлено и меожет быть использовано
// csUnPrepared - условие необходимо подготовить
// csError - условие содержит ошибку и не может быть использовано
// csFormula - условие вычисляет формулу. Условие подготавливается каждый раз

type
  TConditionState = (csPrepared, csUnPrepared, csFormula, csError);

///////////////////////////////////////////////////////////
// Вид сравнения условия со значением поля класс TCondition
// cckNumeric - сравнение чисел
// cckDateTime - сравнение времени
// cckString - сравнение строк
// cckNone - сравнение не установлено

type
  TConditionCompareKind = (cckNumeric, cckDateTime, cckString, cckNone);

//////////////////////////////////////////////////////////////////
// Опции для расширенного отображения класс TColumnExpand
// ceoAddField - дополнительная колонка
// ceoAddFieldMultiline - дополнительная колонка в несколько строк
// ceoMultiline - основная колонка в несколько строк

type
  TColumnExpandOption = (ceoAddField, ceoAddFieldMultiline, ceoMultiline);
  TColumnExpandOptions = set of TColumnExpandOption;

type
  TCheckBoxEvent = procedure (Sender: TObject; CheckID: String;
    var Checked: Boolean) of object;

type
  TCustomgsDBGrid = class;
  TGridConditions = class;

  TGridCheckBox = class(TPersistent)
  private
    FDisplayField: String; // Колонка, в которой отображать CheckBox
    FFieldName: String; // Поле данных с уникальным идентификатором
    FVisible: Boolean; // Видим ли CheckBox
    FCheckList: TStringList; // Список идентификаторов
    FOwner: TCustomgsDBGrid; // Владелец
    FGlyphChecked: TBitmap; // Рисунок с "галочкой"
    FGlyphUnChecked: TBitmap; // Рисунок без "галочки"
    FStoreGlyphChecked, FStoreGlyphUnChecked: Boolean; // Сохранять ли рисунки
    FCheckBoxEvent: TCheckBoxEvent; // Событие по добавлению элемента в список CheckBox-ов

    function GetCheckCount: Integer;
    function GetStrCheck(AnIndex: Integer): String;
    function GetIntCheck(AnIndex: Integer): Integer;

    procedure SetDisplayField(const Value: String);
    procedure SetFieldName(const Value: String);
    procedure SetVisible(const Value: Boolean);
    procedure SetCheckList(const Value: TStringList);

    procedure SetGlyphChecked(const Value: TBitmap);
    procedure SetGlyphUnChecked(const Value: TBitmap);

    function GetRecordChecked: Boolean;

  protected
    function GetOwner: TPersistent; override;

    procedure DoOnChange(Sender: TObject);

  public
    constructor Create(AnOwner: TCustomgsDBgrid);
    destructor Destroy; override;

    procedure Assign(Source: TPersistent); override;
    function GetNamePath: string; override;

    procedure AddCheck(const Value: String); overload;
    procedure AddCheck(const Value: Integer); overload;

    procedure DeleteCheck(const Value: String); overload;
    procedure DeleteCheck(const Value: Integer); overload;

    procedure Clear;

    procedure BeginUpdate;
    procedure EndUpdate;

    // Таблица, которой принадлежит данный класс
    property Grid: TCustomgsDBGrid read FOwner;

    // Количество идентификаторов
    property CheckCount: Integer read GetCheckCount;
    // Идентификатор в виде строки по индексу
    property StrCheck[Index: Integer]: String read GetStrCheck;
    // Идентификатор в виде числа по индексу
    property IntCheck[Index: Integer]: Integer read GetIntCheck; default;
    // Отмечена ли запись (сохранен ли ее идентификатор)
    property RecordChecked: Boolean read GetRecordChecked;

  published
    // Поле, где выводится CheckBox
    property DisplayField: String read FDisplayField write SetDisplayField;
    // Поле, откуда береться уникальный идентификатор
    property FieldName: String read FFieldName write SetFieldName;
    // Видим ли CheckBox
    property Visible: Boolean read FVisible write SetVisible;
    // Список идентификаторов
    property CheckList: TStringList read FCheckList write SetCheckList;
    // Рисунок с "галочкой"
    property GlyphChecked: TBitmap read FGlyphChecked write SetGlyphChecked
      stored FStoreGlyphChecked;
    // Рисунок без "галочки"
    property GlyphUnChecked: TBitmap read FGlyphUnChecked write SetGlyphUnChecked
      stored FStoreGlyphUnChecked;
    // Событие по добавлению элемента в список CheckBox-ов
    property CheckBoxEvent: TCheckBoxEvent read FCheckBoxEvent write FCheckBoxEvent;

  end;

  ///////////////////////////////////////////////
  // Событие - проверка пользовательского условия
  // для класса TCondition

  TOnUserCondition = function
  (
    Sender: TObject;
    Field: TField
  ):
    Boolean
  of object;


  TCondition = class(TCollectionItem)
  private
    FConditionState: TConditionState; // Состояние условия

    FConditionName: String; // Наименование условия

    FDisplayFields: String; // Поля, в которых будут отображаться условия
    FFieldName: String; // Поле, на основе которого будет строиться условие

    FFont: TFont; // Шрифт условия
    FColor: TColor; // Цвет условия

    FExpression1: String; // Первое выражение
    FExpression2: String; // Второе выражение

    FConditionKind: TConditionKind; // Вид условия
    FDisplayOptions: TDisplayOptions; // Опции отображения

    FEvaluateFormula: Boolean; // Рассчитывать формулы

    FUserCondition: Boolean; // Использовать пользовательское условие
    FOnUserCondition: TOnUserCondition; // Событие на проверку пользовательского условия

    // Методы реализации свойств

    function GetGrid: TCustomgsDBGrid;
    function GetDataLink: TGridDataLink;
    function GetField: TField;

    procedure SetConditionName(const Value: String);

    procedure SetDisplayFields(const Value: String);
    procedure SetFieldName(const Value: String);

    procedure SetFont(const Value: TFont);
    procedure SetColor(const Value: TColor);

    procedure SetExpression1(const Value: String);
    procedure SetExpression2(const Value: String);

    procedure SetConditionKind(const Value: TConditionKind);
    procedure SetDisplayOptions(const Value: TDisplayOptions);

    procedure SetEvaluateFormula(const Value: Boolean);

    procedure SetUserCondition(const Value: Boolean);
    procedure SetOnUserCondition(const Value: TOnUserCondition);

    function GetIsValid: Boolean;

  protected
    FCompareValue1, FCompareValue2: Extended; // Значения для сравнения (числовые)
    FCompareDate1, FCompareDate2: TDateTime; // Значения дл сравнения (дата/время)
    FConditionCompareKind1, FConditionCompareKind2: TConditionCompareKind; // Вид сравнения данных

    FFoCal: TxFoCal; // Класс расчета математичсеких выражений

    function GetDisplayName: string; override;

    procedure Prepare;
    procedure CheckAndApply;

    // Соединение с источником данных
    property DataLink: TGridDataLink read GetDataLink;
    // Возвращает поле данных для услоавия
    property Field: TField read GetField;
    // Вид сравнения данных
    property ConditionCompareKind1: TConditionCompareKind read FConditionCompareKind1;
    // Вид сравнения данных
    property ConditionCompareKind2: TConditionCompareKind read FConditionCompareKind2;

  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;

    procedure Assign(Source: TPersistent); override;

    function Suits(const DisplayField: TField): Boolean;

    // Таблица, которой принадлежит данная коллекция
    property Grid: TCustomgsDBgrid read GetGrid;
    // Состояние условия
    property ConditionState: TConditionState read FConditionState;
    // Чисто ли условие, или есть название
    property IsValid: Boolean read GetIsValid;

  published
    // Название условия
    property ConditionName: String read FConditionName write SetConditionName;

    // Поля, в которых будут отображаться условия
    property DisplayFields: String read FDisplayFields write SetDisplayFields;
    // Поле, на основе которого будет строиться условие
    property FieldName: String read FFieldName write SetFieldName;

    // Шрифт условия
    property Font: TFont read FFont write SetFont;
    // Цвет условия
    property Color: TColor read FColor write SetColor;

    // Первое выражение
    property Expression1: String read FExpression1 write SetExpression1;
    // Второе выражение
    property Expression2: String read FExpression2 write SetExpression2;

    // Вид условия
    property ConditionKind: TConditionKind read FConditionKind write SetConditionKind;
    // Опции отображения
    property DisplayOptions: TDisplayOptions read FDisplayOptions write SetDisplayOptions;
    // расчитывать формулы
    property EvaluateFormula: Boolean read FEvaluateFormula write SetEvaluateFormula;

    // Использовать пользовательское условие
    property UserCondition: Boolean read FUserCondition write SetUserCondition;
    // Событие на проверку пользовательского условия
    property OnUserCondition: TOnUserCondition read FOnUserCondition write SetOnUserCondition;

  end;

  TGridConditions = class(TCollection)
  private
    FGrid: TCustomgsDBGrid; // Таблица, которой принадлежит данный список

    function GetCondition(Index: Integer): TCondition;
    procedure SetCondition(Index: Integer; const Value: TCondition);

  protected
    function GetOwner: TPersistent; override;
    procedure Update(Item: TCollectionItem); override;

  public
    constructor Create(Grid: TCustomgsDBGrid);
    destructor Destroy; override;

    function  Add: TCondition;

    // Таблица, которой принадлежит коллекция
    property Grid: TCustomgsDBGrid read FGrid;
    // Элемент коллекции по индексу
    property Items[Index: Integer]: TCondition read GetCondition write SetCondition; default;
  end;


  TColumnExpands = class;

  TColumnExpand = class(TCollectionItem)
  private
    FDisplayField: String; // Отображать в поле
    FFieldName: String; // Брать данные из поля
    FLineCount: Integer; // Кол-во строчек для расширенного отображения
    FOptions: TColumnExpandOptions; // Опции расширенного отображения

    procedure SetDisplayField(const Value: String);
    procedure SetFieldName(const Value: String);
    procedure SetLineCount(const Value: Integer);

    function GetGrid: TCustomgsDBGrid;

    procedure SetOptions(const Value: TColumnExpandOptions);

  protected
    function GetDisplayName: string; override;

  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;

    procedure Assign(Source: TPersistent); override;
    function IsExpandValid(ADataLink: TGridDataLink): Boolean;

    // Таблица, которой принадлежит данная коллекция
    property Grid: TCustomgsDBgrid read GetGrid;

  published
    // Отображать в поле
    property DisplayField: String read FDisplayField write SetDisplayField;
    // Брать данные из поля
    property FieldName: String read FFieldName write SetFieldName;
    // Кол-во строчек для расширенного отображения
    property LineCount: Integer read FLineCount write SetLineCount;
    // Опции расширенного отображения
    property Options: TColumnExpandOptions read FOptions write SetOptions;

  end;

  TColumnExpands = class(TCollection)
  private
    FGrid: TCustomgsDBGrid; // Таблица, которой принадлежит данный список

    function GetExpand(Index: Integer): TColumnExpand;
    procedure SetExpand(Index: Integer; const Value: TColumnExpand);

  protected
    function GetOwner: TPersistent; override;
    procedure Update(Item: TCollectionItem); override;

  public
    constructor Create(Grid: TCustomgsDBGrid);
    destructor Destroy; override;

    function  Add: TColumnExpand;

    // Таблица, которой принадлежит коллекция
    property Grid: TCustomgsDBGrid read FGrid;
    // Элемент коллекции по индексу
    property Items[Index: Integer]: TColumnExpand read GetExpand write SetExpand; default;

  end;

  TgsStoreColumnTitle = class(TColumnTitle)
  public
    procedure Assign(Source: TPersistent); override;

  published
    property Alignment stored True;
    property Caption stored True;
    property Color stored True;
    property Font stored True;

  end;

  TgsStoreColumn = class(TColumn)
  private
    FDisplayFormat: String;
    FAssigningFlag: Boolean;

    procedure SetDisplayFormat(const Value: String);
    function GetIsStored: Boolean;

  protected
    function CreateTitle: TColumnTitle; override;

    property IsStored read GetIsStored;

  public
    constructor Create(Collection: TCollection); override;
    procedure Assign(Source: TPersistent); override;
    procedure RestoreDefaults; override;

    procedure UpdateDisplayFormat(ADataLink: TGridDataLink);
    function IsValidField(ADataLink: TGridDataLink): Boolean;

  published
    // формат отображения текста поля в колонке
    property DisplayFormat: String read FDisplayFormat write SetDisplayFormat
      stored True;
    property Alignment stored True;
    property Color stored True;
    property FieldName stored True;
    property Font stored True;
    property Width stored True;
    property Visible stored True;

  end;

  TgsColumn = class(TColumn)
  private
    FBlock: Boolean;
    FUnassigned: Boolean;

  protected
    property IsStored;
    property Unassigned: Boolean read FUnassigned write FUnassigned;

  public
    constructor Create(Collection: TCollection); override;
    procedure RestoreDefaults; override;

  end;

  
  TStripeKind = (skOdd, skEven, skNone);
  TRefreshType = (rtRefresh, rtCloseOpen);

  TgsDBGridClass = class of TCustomgsDBGrid;

  TCustomgsDBGrid = class(TCustomDBGrid)
  private
    FInternalMenuKind: TInternalMenuKind; // Вид внутреннего меню
    FActionList: TActionList; // Список команд меню для таблицы
    FImages: TImageList; // Список рисунков для списка действий

    FMasterAct, FRefreshAct, FFindAct, FPanelAct: TAction; // Указатели на действия

    FInternalColumns: TDBGridColumns; // Список колонок для всех полей

    FSelectedFont: TFont; // Шрифт выделенного текста
    FSelectedColor: TColor; // Цвет выдлеленного текста

    FStriped: Boolean; // Режим полосатой таблицы
    FStripeOdd: TColor; // Первая полоса
    FStripeEven: TColor; // Вторая полоса

    FMyOdd, FMyEven: TStripeKind; // Текущие значения полос

    FExpands: TColumnExpands; // Настройки расширенного отображения.
    FExpandsActive: Boolean; // Используется ли расширенное отображение
    FExpandsSeparate: Boolean; // Использовать резделитель элементов расширенного отображения

    FConditions: TGridConditions; // Коллекция условий
    FConditionsActive: Boolean; // Используются ли уловия

    FCheckBox: TGridCheckBox; // Класс работы со списком CheckBox-ов

    FScaleColumns: Boolean; // Режим растягивания колонок
    FCanScale: Boolean; // Можно ли расятгивать колонки
    FBlockSettings: Boolean; // Блокировка внутренних установок

    FSizedIndex: Integer; // Индекс колонки, размер которой изменялся
    FSizedOldWidth: Integer; // Старный размер колонки, которую меняли
    FLastRemain: Integer; // Индекс колонки, которой в последний раз добавляли больше
    FRestrictModify: Boolean; // Запрет на редактирование

    FMinColWidth: Integer; // Минимальный размер колонки

    FFormName: String; // Храним название формы

    FToolBar: TToolBar; // Панель инструментов для данной таблицы

    FFinishDrawing: Boolean; // Заканчивать ли рисование до края таблицы вертикально
    FRefreshType: TRefreshType; // Тип обновления данных

    FRememberPosition: Boolean; // Запоминать ли позицию
    FRememberField: String; // Поля позиционирования

    // Методы обработки свойств компонента

    function GetTableFont: TFont;
    procedure SetTableFont(const Value: TFont);

    function GetTableColor: TColor;
    procedure SetTableColor(const Value: TColor);

    function GetSelectedFont: TFont;
    procedure SetSelectedFont(const Value: TFont);

    function GetSelectedColor: TColor;
    procedure SetSelectedColor(const Value: TColor);

    function GetTitleFont: TFont;
    procedure SetTitleFont(const Value: TFont);

    function GetTitleColor: TColor;
    procedure SetTitleColor(const Value: TColor);

    procedure SetDataSource(Value: TDataSource);

    procedure SetStriped(const Value: Boolean);
    procedure SetStripeOdd(const Value: TColor);
    procedure SetStripeEven(const Value: TColor);

    function GetLineCount: Integer;
    function GetVisibleColumnCount: Integer;

    procedure SetColumnExpands(const Value: TColumnExpands);
    procedure SetExpandsActive(const Value: Boolean);
    procedure SetExpandsSeparate(const Value: Boolean);

    procedure SetConditions(const Value: TGridConditions);
    procedure SetConditionsActive(const Value: Boolean);

    procedure SetCheckBox(const Value: TGridCheckBox);
    procedure SetScaleColumns(const Value: Boolean);
    procedure SetMinColWidth(const Value: Integer);

    procedure SetToolBar(const Value: TToolBar);
    procedure SetFinishDrawing(const Value: Boolean);

    // Внутренние методы компонента

    procedure CreateActionList;
    procedure FullFillMenu(PopupColumn: TColumn; APopupMenu: TPopupMenu; Items: TList);

    procedure FreeColumnsInfo;
    procedure UpdateColumns;
    procedure RememberColumns;

    procedure SetupActions(AToolBar: TToolBar);
    procedure RemoveActions(AToolBar: TToolBar);

    procedure DoShowMaster(Sender: TObject);
    procedure DoApplyMaster(Sender: TObject);

    procedure DoOnFindExecute(Sender: TObject);
    procedure DoOnFind(Sender: TObject);
    procedure DoOnRefresh(Sender: TObject);
    procedure DoOnPanel(Sender: TObject);

    procedure CountStripes(Distance: Integer);

    procedure GetExpandsList(Field: TField; List: TList);
    function FindMainExpand(List: TList): TColumnExpand;
    function GetDefaultRowHeight: Integer;

    procedure CMParentFontChanged(var Message: TMessage);
      message CM_PARENTFONTCHANGED;
    procedure WMChar(var Message: TWMChar);
      message WM_CHAR;
    procedure WMEraseBkgnd(var Message: TWmEraseBkgnd);
      message WM_ERASEBKGND;

    procedure DoOnFontChanged(Sender: TObject);
    procedure CountScaleColumns;

    function NotParentFont: Boolean;
    function ColumnByField(AField: TField): TColumn;

  protected
    FFindDlg: TFindDialog; // Диалоговое окно поиска

    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure Paint; override;

    class function GridClassType: TgsDBGridClass; virtual;

    procedure DrawCell(ACol, ARow: Longint; ARect: TRect;
      AState: TGridDrawState); override;

    procedure LinkActive(Active: Boolean); override;
    procedure Scroll(Distance: Integer); override;
    procedure LayoutChanged; override;

    procedure RowHeightsChanged; override;
    procedure ColWidthsChanged; override;

    procedure CalcSizingState(X, Y: Integer; var State: TGridState;
      var Index: Longint; var SizingPos, SizingOfs: Integer;
      var FixedInfo: TGridDrawInfo); override;

    procedure KeyDown(var Key: Word; Shift: TShiftState); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure DblClick; override;
    function CanEditShow: Boolean; override;

    procedure ColEnter; override;
    function  CreateColumns: TDBGridColumns; override;

    procedure UpdateRowCount;
    function GetFullCaption(AColumn: TColumn): String;
    procedure GetColumnFields(AColumn: TColumn; Fields: TList);
    procedure UpdateColumnWithInternalOne(Column: TColumn);

    procedure SetParent(AParent: TWinControl); override;

    procedure SetColumnAttributes; override;

    // Список колонок для всех полей
    property InternalColumns: TDBGridColumns read FInternalColumns;

    // Вычисляет кол-во линий
    property LineCount: Integer read GetLineCount;
    // Возвращает кол-во видимых колонок
    property VisibleColumnCount: Integer read GetVisibleColumnCount;

    // Шрифт таблицы
    property TableFont: TFont read GetTableFont write SetTableFont
      stored NotParentFont;
    // Цвет таблицы
    property TableColor: TColor read GetTableColor write SetTableColor
      default clWindow;

    // Шрифт выделенного текста
    property SelectedFont: TFont read GetSelectedFont write SetSelectedFont
      stored NotParentFont;
    // Цвет выделенного текста
    property SelectedColor: TColor read GetSelectedColor write SetSelectedColor
      default clHighlight;

    // Шрифт заглавий
    property TitleFont read GetTitleFont write SetTitleFont
      stored NotParentFont;
    // Цвет заглавий
    property TitleColor: TColor read GetTitleColor write SetTitleColor
      default clBtnFace;

    // Режим полосатой таблицы
    property Striped: Boolean read FStriped write SetStriped;
    // Первая полоса
    property StripeOdd: TColor read FStripeOdd write SetStripeOdd default DefStripeOdd;
    // Вторая полоса
    property StripeEven: TColor read FStripeEven write SetStripeEven default DefStripeEven;

    // Вид внутреннего меню
    property InternalMenuKind: TInternalMenuKind read FInternalMenuKind write FInternalMenuKind;

    // Настройки для расширенного отображения
    property Expands: TColumnExpands read FExpands write SetColumnExpands;
    // Использовать расширенное отображение или нет
    property ExpandsActive: Boolean read FExpandsActive write SetExpandsActive;
    // Использовать резделитель элементов расширенного отображения
    property ExpandsSeparate: Boolean read FExpandsSeparate write SetExpandsSeparate;

    // Коллекция условий
    property Conditions: TGridConditions read FConditions write SetConditions;
    // Используются ли уловия
    property ConditionsActive: Boolean read FConditionsActive write SetConditionsActive;

    // Класс работы со списком CheckBox-ов
    property CheckBox: TGridCheckBox read FCheckBox write SetCheckBox;

    // Режим растягивания колонок
    property ScaleColumns: Boolean read FScaleColumns write SetScaleColumns;
    // Минимальный размер колонки
    property MinColWidth: Integer read FMinColWidth write SetMinColWidth;
    // Панель инструментов для данной таблицы
    property ToolBar: TToolBar read FToolBar write SetToolBar;

    // Родитель таблицы
    property Parent write SetParent;

    // Заканчивать ли рисование до края таблицы вертикально
    property FinishDrawing: Boolean read FFinishDrawing write SetFinishDrawing
      default True;
    // Тип обновления данных
    property RefreshType: TRefreshType read FRefreshType write FRefreshType
      default rtCloseOpen;
    // Необходимо ли позиционировать после фильтра
    property RememberPosition: Boolean read FRememberPosition write FRememberPosition;
    // Поля позиционирования
    property RememberField: String read FRememberField write FRememberField;
    // Источник данных
    property DataSource write SetDataSource;

  public
    constructor Create(AnOwner: TComponent); override;
    destructor Destroy; override;

    procedure PrepareMaster(AMaster: TForm); virtual;
    procedure SetupGrid(AMaster: TForm; const UpdateGrid: Boolean = True); virtual;

    procedure DefaultHandler(var Msg); override;
    procedure SetBounds(ALeft, ATop, AWidth, AHeight: Integer); override;

    procedure Read(Reader: TReader); virtual;
    procedure Write(Writer: TWriter); virtual;

    procedure LoadFromStream(Stream: TStream);
    procedure SaveToStream(Stream: TStream);

    function GridCoordFromMouse: TGridCoord;

    // Наименование формы
    property FormName: String read FFormName;

  end;

type
  TgsDBGrid = class(TCustomgsDBGrid)
  protected
    class function GridClassType: TgsDBGridClass; override;

  public
    property Canvas;
    property SelectedRows;
    
  published

    // Свойства, перешедшие из стандартного TCustomDBGrid

    property Align;
    property Anchors;
    property BiDiMode;
    property BorderStyle;
    property Columns stored False;
    property Constraints;
    property Ctl3D;
    property DataSource;
    property DefaultDrawing;
    property DragCursor;
    property DragKind;
    property DragMode;
    property Enabled;
    property ImeMode;
    property ImeName;
    property Options;
    property ParentBiDiMode;
    property ParentColor;
    property ParentCtl3D;
    property ParentFont;
    property ParentShowHint;
    property PopupMenu;
    property ReadOnly;
    property ScrollBars;
    property ShowHint;
    property TabOrder;
    property TabStop;
    property Visible;
    property OnCellClick;
    property OnColEnter;
    property OnColExit;
    property OnColumnMoved;
    property OnDrawDataCell;
    property OnDrawColumnCell;
    property OnDblClick;
    property OnDragDrop;
    property OnDragOver;
    property OnEditButtonClick;
    property OnEndDock;
    property OnEndDrag;
    property OnEnter;
    property OnExit;
    property OnKeyDown;
    property OnKeyPress;
    property OnKeyUp;
    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
    property OnStartDock;
    property OnStartDrag;
    property OnTitleClick;

    // Свойства добавленные и измененные TCustomgsDBGrid

    property TableFont;
    property TableColor;

    property SelectedFont;
    property SelectedColor;

    property TitleFont;
    property TitleColor;

    property Striped;
    property StripeOdd;
    property StripeEven;

    property InternalMenuKind;

    property Expands;
    property ExpandsActive;
    property ExpandsSeparate;

    property Conditions;
    property ConditionsActive;

    property CheckBox;

    property ScaleColumns;
    property MinColWidth;
    property ToolBar;

    property FinishDrawing;

    property RememberPosition;
    property RememberField;
  end;

type
  EgsDBGridException = class(Exception);

procedure Register;

implementation

{$R GSDBGRID.RES}

uses
  JclStrings, Math, DsgnIntf, TypInfo, gsDBGrid_dlgMaster;

const
  MENU_MASTER = 'Мастер установок';
  MENU_REFRESH = 'Обновить данные';
  MENU_FIND = 'Найти';
  MENU_PANEL = 'Панель инструментов';


function AnsiUpperPos(S1, S2: String): Integer;
begin
  Result := StrIPos(S1, S2);
end;



{
    -------------------------------------
    ----    TGridCheckBox Class    ----
    -------------------------------------
}

{
  Производит загрузку стандартных рисунокв CheckBox
}

const
 CHECK_WIDTH = 13;
 CHECK_HEIGHT = 13;

procedure LoadCheckBox(ABitmap: TBitmap; Checked: Boolean);
var
  B: TBitmap;
  R: TRect;
begin
  B := TBitmap.Create;

  try
    B.Handle := LoadBitmap(0, MAKEINTRESOURCE(OBM_CHECKBOXES));

    ABitmap.Width := CHECK_WIDTH;
    ABitmap.Height := CHECK_HEIGHT;

    if Checked then
      R := Rect(CHECK_WIDTH, 0, CHECK_WIDTH * 2, CHECK_HEIGHT)
    else
      R := Rect(0, 0, 13, 13);

    ABitmap.Canvas.CopyRect(Rect(0, 0, CHECK_WIDTH, CHECK_HEIGHT), B.Canvas, R);
  finally
    B.Free;
  end;
end;


{
  *********************
  ***  Public Part  ***
  *********************
}

constructor TGridCheckBox.Create(AnOwner: TCustomgsDBgrid);
begin
  FDisplayField := '';
  FFieldName := '';
  FVisible := False;
  FCheckList := TStringList.Create;
  FCheckList.OnChange := DoOnChange;
  FOwner := AnOwner;

  FGlyphChecked := TBitmap.Create;
  FGlyphUnChecked := TBitmap.Create;

  LoadCheckBox(FGlyphChecked, True);
  LoadCheckBox(FGlyphUnChecked, False);

  FStoreGlyphChecked := False;
  FStoreGlyphUnChecked := False;

  FCheckBoxEvent := nil;
end;

destructor TGridCheckBox.Destroy;
begin
  FCheckList.Free;
  
  FGlyphChecked.Free;
  FGlyphUnChecked.Free;

  inherited Destroy;
end;

{
  Производим присваивание свойств от другого такого же класса.
}

procedure TGridCheckBox.Assign(Source: TPersistent);
begin
  if Source is TGridCheckBox then
  begin
    FDisplayField := (Source as TGridCheckBox).DisplayField;
    FFieldName := (Source as TGridCheckBox).FieldName;
    FVisible := (Source as TGridCheckBox).Visible;
    FCheckList.Assign((Source as TGridCheckBox).CheckList);
    FGlyphChecked.Assign((Source as TGridCheckBox).GlyphChecked);
    FGlyphUnChecked.Assign((Source as TGridCheckBox).GlyphUnChecked);
  end else
    inherited Assign(Source);
end;

function TGridCheckBox.GetNamePath: string;
begin
  Result := 'CheckBox';
end;

{
  Добавление идентификатора в виде строки.
}

procedure TGridCheckBox.AddCheck(const Value: String);
var
  Checked: Boolean;
begin
  if FCheckList.IndexOf(Value) = -1 then
  begin
    Checked := True;

    if Assigned(FCheckBoxEvent) then
      FCheckBoxEvent(Self, Value, Checked);

    if Checked then
      FCheckList.Add(Value);
  end;
end;

{
  Добавление идентификатора в виде числа.
}

procedure TGridCheckBox.AddCheck(const Value: Integer);
var
  Checked: Boolean;
begin
  if FCheckList.IndexOf(IntToStr(Value)) = -1 then
  begin
    Checked := True;

    if Assigned(FCheckBoxEvent) then
      FCheckBoxEvent(Self, IntToStr(Value), Checked);

    if Checked then
      FCheckList.Add(IntToStr(Value));
  end;
end;

{
  Удаление идентификатора в виде строки.
}

procedure TGridCheckBox.DeleteCheck(const Value: String);
var
  I: Integer;
  Checked: Boolean;
begin
  I := FCheckList.IndexOf(Value);
  if I <> -1 then
  begin
    Checked := False;

    if Assigned(FCheckBoxEvent) then
      FCheckBoxEvent(Self, Value, Checked);

    if not Checked then
      FCheckList.Delete(I);
  end;
end;

{
  Удаление идентификатора в виде числа.
}

procedure TGridCheckBox.DeleteCheck(const Value: Integer);
var
  I: Integer;
  Checked: Boolean;
begin
  I := FCheckList.IndexOf(IntToStr(Value));
  if I <> -1 then
  begin
    Checked := False;

    if Assigned(FCheckBoxEvent) then
      FCheckBoxEvent(Self, IntToStr(Value), Checked);

    if not Checked then
      FCheckList.Delete(I);
  end;
end;

procedure TGridCheckBox.Clear;
begin
  FCheckList.Clear;
end;

procedure TGridCheckBox.BeginUpdate;
begin
  FCheckList.BeginUpdate;
end;

procedure TGridCheckBox.EndUpdate;
begin
  FCheckList.EndUpdate;

  if FOwner.UpdateLock = 0 then
    FOwner.Invalidate;
end;

{
  ************************
  ***  Protected Part  ***
  ************************
}

function TGridCheckBox.GetOwner: TPersistent;
begin
  Result := FOwner;
end;

{
  Если были изменения в списке идентификаторов производим перерисовку.
}

procedure TGridCheckBox.DoOnChange(Sender: TObject);
begin
  if Assigned(FOwner) and (FOwner.UpdateLock = 0) then
    FOwner.Invalidate;
end;

{
  **********************
  ***  Private Part  ***
  **********************
}

{
  Кол-во идентификаторов.
}

function TGridCheckBox.GetCheckCount: Integer;
begin
  Result := FCheckList.Count;
end;

{
  Возвращает идентификатор в виде строки.
}

function TGridCheckBox.GetStrCheck(AnIndex: Integer): String;
begin
  Result := FCheckList[AnIndex];
end;

{
  Возвращает идентификатор в виде числа.
}

function TGridCheckBox.GetIntCheck(AnIndex: Integer): Integer;
var
  err: Integer;
begin
  Val(FCheckList[AnIndex], Result, err);
end;

{
  Устанавливает поле отображения.
}

procedure TGridCheckBox.SetDisplayField(const Value: String);
begin
  if FDisplayField <> Value then
  begin
    FDisplayField := Value;

    if Assigned(FOwner) and (FOwner.UpdateLock = 0) then
      FOwner.Invalidate;
  end;
end;

{
  Устанавливает поле, где брать данные идентификаторов.
}

procedure TGridCheckBox.SetFieldName(const Value: String);
begin
  if FFieldName <> Value then
  begin
    FFieldName := Value;

    if Assigned(FOwner) and (FOwner.UpdateLock = 0) then
      FOwner.Invalidate;
  end;
end;

{
  Устанавливает режим отображения CheckBox.
}

procedure TGridCheckBox.SetVisible(const Value: Boolean);
begin
  if FVisible <> Value then
  begin
    FVisible := Value;
    
    if Assigned(FOwner) and (FOwner.UpdateLock = 0) then
      FOwner.Invalidate;
  end;
end;

{
  Устанавливает список идентификаторов.
}

procedure TGridCheckBox.SetCheckList(const Value: TStringList);
begin
  FCheckList.Assign(Value);
end;

{
  Рисунок с "галочкой"
}

procedure TGridCheckBox.SetGlyphChecked(const Value: TBitmap);
begin
  FGlyphChecked.Assign(Value);

  if FGlyphChecked.Empty then
  begin
    LoadCheckBox(FGlyphChecked, True);
    FStoreGlyphChecked := False;
  end else
    FStoreGlyphChecked := True;

  if Assigned(FOwner) and (FOwner.UpdateLock = 0) then
    FOwner.Invalidate;
end;

{
  Рисунок без "галочки"
}

procedure TGridCheckBox.SetGlyphUnChecked(const Value: TBitmap);
begin
  FGlyphUnChecked.Assign(Value);

  if FGlyphUnChecked.Empty then
  begin
    LoadCheckBox(FGlyphUnChecked, False);
    FStoreGlyphUnChecked := False;
  end else
    FStoreGlyphUnChecked := True;

  if Assigned(FOwner) and (FOwner.UpdateLock = 0) then
    FOwner.Invalidate;
end;

{
  Отмечена ли запись (сохранен ди ее идентификатор)
}

function TGridCheckBox.GetRecordChecked: Boolean;
var
  TheField: TField;
begin
  TheField := FOwner.DataLink.DataSet.FindField(FFieldName);
  if Assigned(TheField) then
    Result := FCheckList.IndexOf(TheField.DisplayText) <> -1
  else
    Result := False;
end;

{
    --------------------------------
    ----    TCondition Class    ----
    --------------------------------
}

{
  *********************
  ***  Public Part  ***
  *********************
}

constructor TCondition.Create(Collection: TCollection);
begin
  inherited Create(Collection);

  FConditionState := csUnPrepared;
  FConditionCompareKind1 := cckNone;
  FConditionCompareKind2 := cckNone;

  FConditionName := '';

  FDisplayFields := '';
  FFieldName := '';

  FFont := TFont.Create;
  FColor := clWhite;

  FExpression1 := '';
  FExpression2 := '';

  FConditionKind := ckNone;
  FDisplayOptions := [];

  FUserCondition := False;
  FOnUserCondition := nil;

  FCompareValue1 := 0;
  FCompareValue2 := 0;

  FCompareDate1 := 0;
  FCompareDate2 := 0;

  FFoCal := nil;
end;

destructor TCondition.Destroy;
begin
  if Assigned(Font) then Font.Free;
  if Assigned(FFoCal) then FFoCal.Free;

  inherited Destroy;
end;

{
  Присваивание объектов.
}

procedure TCondition.Assign(Source: TPersistent);
begin
  if Source is TCondition then
  begin
    FConditionName := (Source as TCondition).ConditionName;

    FDisplayFields := (Source as TCondition).DisplayFields;
    FFieldName := (Source as TCondition).FieldName;

    FFont.Assign((Source as TCondition).Font);
    FColor := (Source as TCondition).Color;

    FExpression1 := (Source as TCondition).Expression1;
    FExpression2 := (Source as TCondition).Expression2;

    FConditionKind := (Source as TCondition).ConditionKind;
    FDisplayOptions := (Source as TCondition).DisplayOptions;

    EvaluateFormula := (Source as TCondition).EvaluateFormula;

    FUserCondition := (Source as TCondition).UserCondition;
    FOnUserCondition := (Source as TCondition).OnUserCondition;
  end else
    inherited Assign(Source);
end;

{
  Проверка, следует ли применять условие на данное поле.
}

function TCondition.Suits(const DisplayField: TField): Boolean;
begin
  Result := AnsiUpperPos(DisplayField.FieldName, FDisplayFields) > 0;
end;


{
  ************************
  ***  Protected Part  ***
  ************************
}

function TCondition.GetDisplayName: string;
begin
  Result := FConditionName;
  if Result = '' then
    Result := inherited GetDisplayName;
end;

{
  Подготавливает условие к работе.
}

procedure TCondition.Prepare;
var
  TheField: TField;
  OkStatus: Boolean;

  // Проверка строки на совместимость с числовым типом поля
  function IsNumericCompatible(Text: String; var Value: Extended): Boolean;
  begin
    if TheField.DataType = ftCurrency then
      Result := TextToFloat(PChar(Text), Value, fvCurrency)
    else
      Result := TextToFloat(PChar(Text), Value, fvExtended);
  end;

  // Проверка строки на совместимость с датой
  function IsDateCompatible(Text: String; var Value: TDateTime): Boolean;
  begin
    try
      Value := StrToDate(Text);
      Result := True;
    except
      Result := False;
    end;
  end;

  // Проверка строки на совместимость со временем
  function IsTimeCompatible(Text: String; var Value: TDateTime): Boolean;
  begin
    try
      Value := StrToTime(Text);
      Result := True;
    except
      Result := False;
    end;
  end;

  // Проверка строки на совместимость с датой, временем
  function IsDateTimeCompatible(Text: String; var Value: TDateTime): Boolean;
  begin
    try
      Value := StrToDateTime(Text);
      Result := True;
    except
      Result := False;
    end;
  end;

  // Производит проверку выражения
  function CheckExpression(
    AnExpression: String;
    var NumValue: Extended;
    var DateValue: TDateTime;
    var CompareKind: TConditionCompareKind): Boolean;
  begin
    case TheField.DataType of
      ftSmallint, ftInteger, ftWord, ftAutoInc,
      ftLargeint, ftFloat, ftCurrency, ftBoolean:
      begin
        Result := IsNumericCompatible(AnExpression, NumValue);
        CompareKind := cckNumeric;
      end;
      ftString, ftMemo, ftFixedChar, ftWideString:
      begin
        Result := True;
        CompareKind := cckString;
      end;
      ftDate:
      begin
        Result := IsDateCompatible(AnExpression, DateValue);
        CompareKind := cckDateTime;
      end;
      ftTime:
      begin
        Result := IsTimeCompatible(AnExpression, DateValue);
        CompareKind := cckDateTime;
      end;
      ftDateTime:
      begin
        Result := IsDateTimeCompatible(AnExpression, DateValue);
        CompareKind := cckDateTime;
      end;
      else begin
        Result := False;
      end;
    end;
  end;

begin
  TheField := Field;

  if Assigned(TheField) then
  begin

    ////////////////////////////////////
    // Вариант пользовательского условия

    if UserCondition then
    begin
      if Assigned(FOnUserCondition) then
        FConditionState := csPrepared
      else
        FConditionState := csError;
    end else

    ///////////////////////////
    // Вариант обычного условия

    if not FEvaluateFormula then
    begin
      case ConditionKind of
        ckEqual, ckNotEqual, ckBigger, ckSmaller, ckBiggerEqual,
        ckSmallerEqual, ckStarts, ckContains:
          OkStatus :=
            CheckExpression(FExpression1, FCompareValue1, FCompareDate1,
              FConditionCompareKind1);
        ckIn, ckOut:
          OkStatus :=
            CheckExpression(FExpression1, FCompareValue1, FCompareDate1,
              FConditionCompareKind1)
              and
            CheckExpression(FExpression2, FCompareValue2, FCompareDate2,
              FConditionCompareKind2);
        ckExist, ckNotExist:
          OkStatus := True;
        else
          OkStatus := False;
      end;

      if OkStatus then
        FConditionState := csPrepared
      else
        FConditionState := csError;
    end;
  end else
    FConditionState := csError;
end;

{
  Применить условие к данному полю.
}

procedure TCondition.CheckAndApply;
var
  I: Integer;
  OkStatus: Boolean;
  TheField: TField;
  CompareResult: Boolean;

  // Устанавливает фришт и цвет условия
  procedure Apply;
  begin
    if doFont in FDisplayOptions then
      Grid.Canvas.Font := Font;
    if doColor in FDisplayOptions then
      Grid.Canvas.Brush.Color := Color;
  end;

  // Рассчитывает формулу
  function Calculate(
    AnExpression: String;
    var NumValue: Extended;
    var DateValue: TDateTime;
    var CompareKind: TConditionCompareKind): Boolean;
  begin
    try
      FFoCal.Expression := FExpression1;

      if FFoCal.Value = 0 then
        Result := AnsiCompareText(FFoCal.Expression, 'Error') <> 0
      else
        Result := True;

      case TheField.DataType of
        ftSmallint, ftInteger, ftWord, ftAutoInc,
        ftLargeint, ftFloat, ftCurrency, ftBoolean:
          NumValue := FFoCal.Value;
        ftDate, ftTime, ftDateTime:
          DateValue := FFoCal.Value;
        else begin
          Result := False;
        end;
      end;
    except
      Result := False;
    end;
  end;

begin
  // Игонорирует условия с ошибками
  if FConditionState = csError then Exit;

  // Для ускорения запоминаем указатель на поле
  TheField := Field;

  ////////////////////////////////////////////
  // Исли не используется условие пользователя

  if not FUserCondition then
  begin

    ///////////////////////////////////////
    // Если необходимо рассчитывать формулы

    if FEvaluateFormula then
    begin
      // Очищаем старый список переменных
      FFoCal.ClearVariablesList;

      // Добавляем новый список переменных
      for I := 0 to DataLink.DataSet.FieldCount - 1  do
        if
          DataLink.DataSet.Fields[I].DataType
            in
          [
            ftSmallint, ftInteger, ftWord, ftAutoInc, ftLargeint,
            ftFloat, ftCurrency, ftBoolean, ftDate, ftTime, ftDateTime
          ]
        then
          FFoCal.AssignVariable(DataLink.DataSet.Fields[I].FieldName,
            DataLink.DataSet.Fields[I].AsFloat);


      case FConditionKind of
        ckEqual, ckNotEqual, ckBigger, ckSmaller, ckBiggerEqual,
        ckSmallerEqual, ckStarts, ckContains:
          OkStatus :=
            Calculate(FExpression1, FCompareValue1, FCompareDate1,
              FConditionCompareKind1);
        ckIn, ckOut:
          OkStatus :=
            Calculate(FExpression1, FCompareValue1, FCompareDate1,
              FConditionCompareKind1)
              and
            Calculate(FExpression2, FCompareValue2, FCompareDate2,
              FConditionCompareKind2);
        ckExist, ckNotExist:
          OkStatus := True;
        else
          OkStatus := False;
      end;

      if not OkStatus then
        FConditionState := csError;
    end;

    //////////////////////////////////////////
    // Сравнение данных условия с данными поля

    case FConditionKind of
      ckEqual:
        case FConditionCompareKind1 of
          cckNumeric:
            CompareResult := FCompareValue1 = TheField.AsFloat;
          cckDateTime:
            CompareResult := FCompareDate1 = TheField.AsDateTime;
          cckString:
          begin
            if TheField.Datatype = ftMemo then
              CompareResult := AnsiCompareText(FExpression1, TheField.AsString) = 0
            else
              CompareResult := AnsiCompareText(FExpression1, TheField.DisplayText) = 0;
          end else
            CompareResult := False;
        end;
      ckNotEqual:
        case FConditionCompareKind1 of
          cckNumeric:
            CompareResult := FCompareValue1 <> TheField.AsFloat;
          cckDateTime:
            CompareResult := FCompareDate1 <> TheField.AsDateTime;
          cckString:
          begin
            if TheField.Datatype = ftMemo then
              CompareResult := AnsiCompareText(FExpression1, TheField.AsString) <> 0
            else
              CompareResult := AnsiCompareText(FExpression1, TheField.DisplayText) <> 0;
          end else
            CompareResult := False;
        end;
      ckIn:
      begin
        case FConditionCompareKind1 of
          cckNumeric:
            CompareResult :=
              (FCompareValue1 <= TheField.AsFloat)
                and
              (FCompareValue2 >= TheField.AsFloat);
          cckDateTime:
            CompareResult :=
              (FCompareDate1 <= TheField.AsDateTime)
                and
              (FCompareDate2 >= TheField.AsDateTime);
          cckString:
          begin
            if TheField.Datatype = ftMemo then
              CompareResult :=
                (FExpression1 <= TheField.AsString)
                  and
                (FExpression2 >= TheField.AsString)
            else
              CompareResult :=
                (FExpression1 <= TheField.DisplayText)
                  and
                (FExpression2 >= TheField.DisplayText);
          end else
            CompareResult := False;
        end;
      end;
      ckOut:
      begin
        case FConditionCompareKind1 of
          cckNumeric:
            CompareResult :=
              (FCompareValue1 > TheField.AsFloat)
                or
              (FCompareValue2 < TheField.AsFloat);
          cckDateTime:
            CompareResult :=
              (FCompareDate1 > TheField.AsDateTime)
                or
              (FCompareDate2 < TheField.AsDateTime);
          cckString:
            if TheField.Datatype = ftMemo then
              CompareResult :=
                (FExpression1 > TheField.AsString)
                  and
                (FExpression2 < TheField.AsString)
            else
              CompareResult :=
                (FExpression1 > TheField.DisplayText)
                  and
                (FExpression2 < TheField.DisplayText);
          else
            CompareResult := False;
        end;
      end;
      ckBigger:
        case FConditionCompareKind1 of
          cckNumeric:
            CompareResult := FCompareValue1 < TheField.AsFloat;
          cckDateTime:
            CompareResult := FCompareDate1 < TheField.AsDateTime;
          cckString:
          begin
            if TheField.Datatype = ftMemo then
              CompareResult := FExpression1 < TheField.AsString
            else
              CompareResult := FExpression1 < TheField.DisplayText;
          end else
            CompareResult := False;
        end;
      ckSmaller:
        case FConditionCompareKind1 of
          cckNumeric:
            CompareResult := FCompareValue1 > TheField.AsFloat;
          cckDateTime:
            CompareResult := FCompareDate1 > TheField.AsDateTime;
          cckString:
          begin
            if TheField.Datatype = ftMemo then
              CompareResult := FExpression1 > TheField.AsString
            else
              CompareResult := FExpression1 > TheField.DisplayText;
          end else
            CompareResult := False;
        end;
      ckBiggerEqual:
        case FConditionCompareKind1 of
          cckNumeric:
            CompareResult := FCompareValue1 <= TheField.AsFloat;
          cckDateTime:
            CompareResult := FCompareDate1 <= TheField.AsDateTime;
          cckString:
          begin
            if TheField.Datatype = ftMemo then
              CompareResult := FExpression1 <= TheField.AsString
            else
              CompareResult := FExpression1 <= TheField.DisplayText;
          end else
            CompareResult := False;
        end;
      ckSmallerEqual:
        case FConditionCompareKind1 of
          cckNumeric:
            CompareResult := FCompareValue1 >= TheField.AsFloat;
          cckDateTime:
            CompareResult := FCompareDate1 >= TheField.AsDateTime;
          cckString:
          begin
            if TheField.Datatype = ftMemo then
              CompareResult := FExpression1 >= TheField.AsString
            else
              CompareResult := FExpression1 >= TheField.DisplayText;
          end else
            CompareResult := False;
        end;
      ckContains:
        case FConditionCompareKind1 of
          cckString:
          begin
            if TheField.Datatype = ftMemo then
              CompareResult := AnsiUpperPos(FExpression1, TheField.AsString) > 0
            else
              CompareResult := AnsiUpperPos(FExpression1, TheField.DisplayText) > 0;
          end else
            CompareResult := False;
        end;
      ckStarts:
        case FConditionCompareKind1 of
          cckString:
          begin
            if TheField.Datatype = ftMemo then
              CompareResult := AnsiUpperPos(FExpression1, TheField.AsString) = 1
            else
              CompareResult := AnsiUpperPos(FExpression1, TheField.DisplayText) = 1;
          end else
            CompareResult := False;
        end;
      ckExist:
        CompareResult := not TheField.IsNull;
      ckNotExist:
        CompareResult := TheField.IsNull;
      else
        CompareResult := False;
    end;
  end else begin

    /////////////////////////////////////////////////
    // Если присвоено событие пользоватьского условия
    // выполняем его

    if Assigned(OnUserCondition) then
      CompareResult := OnUserCondition(Self, TheField)
    else
      CompareResult := False;
  end;

  //////////////////////////////////////
  // Если условие выполнено, то изменять
  // установки цвета и шрифта

  if CompareResult then
    Apply;
end;

{
  **********************
  ***  Private Part  ***
  **********************
}

{
  Возвращает таблицу.
}

function TCondition.GetGrid: TCustomgsDBGrid;
begin
  Result := (Collection as TGridConditions).Grid;
end;

{
  Возвращает соединение с источником данных.
}

function TCondition.GetDataLink: TGridDataLink;
begin
  if Assigned(Grid) then
    Result := Grid.DataLink
  else
    Result := nil;   
end;

{
  Возвращает поле для условия.
}

function TCondition.GetField: TField;
begin
  if Assigned(DataLink) and Assigned(DataLink.DataSet) then
    Result := DataLink.DataSet.FindField(FFieldName)
  else
    Result := nil;
end;

{
  Если новое имя условия, о устатавливаем его.
}

procedure TCondition.SetConditionName(const Value: String);
begin
  if FConditionName <> Value then
  begin
    FConditionName := Value;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Поля, в которых будут отображаться условия
}

procedure TCondition.SetDisplayFields(const Value: String);
begin
  if FDisplayFields <> Value then
  begin
    FDisplayFields := Value;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Поле, на основе которого будет строиться условие
}

procedure TCondition.SetFieldName(const Value: String);
begin
  if FFieldName <> Value then
  begin
    FFieldName := Value;

    if not FEvaluateFormula then
      FConditionState := csUnPrepared;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Шрифт условия
}

procedure TCondition.SetFont(const Value: TFont);
begin
  FFont.Assign(Value);

  if Assigned(Grid) then
    Grid.Invalidate;
end;

{
  Цвет условия
}

procedure TCondition.SetColor(const Value: TColor);
begin
  if FColor <> Value then
  begin
    FColor := Value;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Первое выражение
}

procedure TCondition.SetExpression1(const Value: String);
begin
  if FExpression1 <> Value then
  begin
    FExpression1 := Value;

    if not FEvaluateFormula then
      FConditionState := csUnPrepared;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Второе выражение
}

procedure TCondition.SetExpression2(const Value: String);
begin
  if FExpression2 <> Value then
  begin
    FExpression2 := Value;

    if not FEvaluateFormula then
      FConditionState := csUnPrepared;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Вид условия
}

procedure TCondition.SetConditionKind(const Value: TConditionKind);
begin
  if FConditionKind <> Value then
  begin
    FConditionKind := Value;

    if not FEvaluateFormula then
      FConditionState := csUnPrepared;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Опции отображения
}

procedure TCondition.SetDisplayOptions(const Value: TDisplayOptions);
begin
  if FDisplayOptions <> Value then
  begin
    FDisplayOptions := Value;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Устаналивает режим расчета формул.
}

procedure TCondition.SetEvaluateFormula(const Value: Boolean);
begin
  if FEvaluateFormula <> Value then
  begin
    FEvaluateFormula := Value;

    if FEvaluateFormula and not Assigned(FFoCal) then
    begin
      FFoCal := TxFoCal.Create(nil);
      FConditionState := csFormula;
      FConditionCompareKind1 := cckNumeric;
      FConditionCompareKind2 := cckNumeric;
    end else begin
      if not FEvaluateFormula and Assigned(FFoCal) then
        FreeAndNil(FFoCal);

      FConditionState := csUnprepared;
    end;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Использовать пользовательское условие
}

procedure TCondition.SetUserCondition(const Value: Boolean);
begin
  if FUserCondition <> Value then
  begin
    FUserCondition := Value;
    FConditionState := csUnPrepared;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Событие на проверку пользовательского условия
}

procedure TCondition.SetOnUserCondition(const Value: TOnUserCondition);
begin
  FOnUserCondition := Value;
  FConditionState := csUnPrepared;

  if Assigned(Grid) then
    Grid.Invalidate;
end;

{

}

function TCondition.GetIsValid: Boolean;
begin
  Result := not
  (
    (FDisplayFields = '') or (FFieldName = '') or
    (FConditionKind = ckNone) or (FExpression1 = '')
  );
end;


{
    -------------------------------------
    ----    TGridConditions Class    ----
    -------------------------------------
}

{
  *********************
  ***  Public Part  ***
  *********************
}

constructor TGridConditions.Create(Grid: TCustomgsDBGrid);
begin
  inherited Create(TCondition);

  FGrid := Grid; 
end;

destructor TGridConditions.Destroy;
begin
  inherited Destroy;
end;

{
  Добавление нового элемента.
}

function  TGridConditions.Add: TCondition;
begin
  Result := TCondition(inherited Add);
end;

{
  Возвращает владельца коллекции.
}

function TGridConditions.GetOwner: TPersistent;
begin
  Result := FGrid;
end;

{
  Производит обновление владельца коллекции.
}

procedure TGridConditions.Update(Item: TCollectionItem);
begin
  if (FGrid = nil) or (csLoading in FGrid.ComponentState) then Exit;
  FGrid.Invalidate;
end;

{
  **********************
  ***  Private Part  ***
  **********************
}

{
  Условие по индексу.
}

function TGridConditions.GetCondition(Index: Integer): TCondition;
begin
  Result := TCondition(inherited Items[Index]);
end;

{
  Устанавливает условие по индексу.
}

procedure TGridConditions.SetCondition(Index: Integer; const Value: TCondition);
begin
  Items[Index].Assign(Value);
end;


{
    -----------------------------------
    ----    TColumnExpand Class    ----
    -----------------------------------
}


{
  *********************
  ***  Public Part  ***
  *********************
}

constructor TColumnExpand.Create(Collection: TCollection);
begin
  FDisplayField := '';
  FFieldName := '';
  FLineCount := 1;
  FOptions := [];

  inherited Create(Collection);
end;

destructor TColumnExpand.Destroy;
begin
  inherited Destroy;
end;

{
  Присваивание объектов.
}

procedure TColumnExpand.Assign(Source: TPersistent);
begin
  if Source is TColumnExpand then
  begin
    FOptions := (Source as TColumnExpand).Options;
    FDisplayField := (Source as TColumnExpand).DisplayField;
    FFieldName := (Source as TColumnExpand).FieldName;
    FLineCount := (Source as TColumnExpand).LineCount;
  end else
    inherited Assign(Source);
end;

{
  Есть ли поля, необходимые для работы данного
  элемента расширенного отображения.
}

function TColumnExpand.IsExpandValid(ADataLink: TGridDataLink): Boolean;
begin
  Result := ADataLink.DataSet.FindField(FDisplayField) <> nil;
end;

{
  ************************
  ***  Protected Part  ***
  ************************
}

{
  Заголовок в дизайнере.
}

function TColumnExpand.GetDisplayName: string;
begin
  Result := FDisplayField;
  if Result = '' then
    Result := inherited GetDisplayName;
end;


{
  **********************
  ***  Private Part  ***
  **********************
}

{
  Устанавливает колонку, в которой выводить расширенное отображение.
}

procedure TColumnExpand.SetDisplayField(const Value: String);
begin
  if FDisplayField <> Value then
  begin
    FDisplayField := Value;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Устанавливает поле данных, откуда брать текст для расширенного отображения.
}

procedure TColumnExpand.SetFieldName(const Value: String);
begin
  if FFieldName <> Value then
  begin
    FFieldName := Value;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Устанавливает кол-во линий.
}

procedure TColumnExpand.SetLineCount(const Value: Integer);
begin
  if FLineCount <> Value then
  begin
    if Value < 1 then Exit;
    FLineCount := Value;

    if Assigned(Grid) then
      Grid.Invalidate;
  end;
end;

{
  Возвращает таблицу.
}

function TColumnExpand.GetGrid: TCustomgsDBGrid;
begin
  Result := (Collection as TColumnExpands).Grid;
end;

{
  Опции расширенного отображения
}

procedure TColumnExpand.SetOptions(const Value: TColumnExpandOptions);
var
  NewOptions: TColumnExpandOptions;
begin
  if FOptions <> Value then
  begin
    NewOptions := Value;

    if ceoAddField in NewOptions then
      NewOptions := NewOptions - [ceoMultiline];

    if ceoMultiline in NewOptions then
    begin
      NewOptions := NewOptions - [ceoAddFieldMultiline, ceoAddField];
      FieldName := '';
    end;

    if
      (ceoAddFieldMultiline in Options)
        and
      not (ceoAddField in Options)
    then
      NewOptions := NewOptions - [ceoAddFieldMultiline];

    if NewOptions <> FOptions then
    begin
      FOptions := NewOptions;
      
      if Assigned(Grid) then
        Grid.Invalidate;
    end;
  end;
end;

{
    ------------------------------------
    ----    TColumnExpands Class    ----
    ------------------------------------
}


{
  *********************
  ***  Public Part  ***
  *********************
}


constructor TColumnExpands.Create(Grid: TCustomgsDBGrid);
begin
  inherited Create(TColumnExpand);

  FGrid := Grid;
end;

destructor TColumnExpands.Destroy;
begin
  inherited Destroy;
end;

{
  Добавляет новый элемент коллекции.
}

function  TColumnExpands.Add: TColumnExpand;
begin
  Result := TColumnExpand(inherited Add);
end;

{
  ************************
  ***  Protected Part  ***
  ************************
}

{
  Возвращает владельца коллекции.
}

function TColumnExpands.GetOwner: TPersistent;
begin
  Result := FGrid;
end;

{
  Вызываем перерисовку таблицы после произведенных изменений.
}

procedure TColumnExpands.Update(Item: TCollectionItem);
begin
  if (FGrid = nil) or (csLoading in FGrid.ComponentState) then Exit;
  FGrid.Invalidate;
end;


{
  **********************
  ***  Private Part  ***
  **********************
}

{
  Возвращаем элемент коллекции по индексу.
}

function TColumnExpands.GetExpand(Index: Integer): TColumnExpand;
begin
  Result := TColumnExpand(inherited Items[Index]);
end;

{
  Устанавливаем значения элемента по индексу.
}

procedure TColumnExpands.SetExpand(Index: Integer; const Value: TColumnExpand);
begin
  Items[Index].Assign(Value);
end;


{
    ------------------------------------
    ----    TgsStoreColumnTitle Class    ----
    ------------------------------------
}

{
  *********************
  ***  Public Part  ***
  *********************
}

procedure TgsStoreColumnTitle.Assign(Source: TPersistent);
begin
  if Source is TColumnTitle then
  begin
    inherited Assign(Source);

    Alignment := (Source as TColumnTitle).Alignment;
    Caption := (Source as TColumnTitle).Caption;
    Color := (Source as TColumnTitle).Color;
    Font := (Source as TColumnTitle).Font;
  end else
    inherited Assign(Source);
end;


{
    -------------------------------
    ----    TgsStoreColumn Class    ----
    -------------------------------
}

{
  *********************
  ***  Public Part  ***
  *********************
}

constructor TgsStoreColumn.Create(Collection: TCollection);
begin
  inherited Create(Collection);

  IsStored := True;
  FAssigningFlag := False;
end;

{
  Присваивание объектов.
}

procedure TgsStoreColumn.Assign(Source: TPersistent); 
begin
  if Source is TColumn then
  begin
    FAssigningFlag := True;

    inherited Assign(Source);

    if Source is TgsStoreColumn then
      FDisplayFormat := (Source as TgsStoreColumn).DisplayFormat;

    Alignment := (Source as TColumn).Alignment;
    Color := (Source as TColumn).Color;
    FieldName := (Source as TColumn).FieldName;
    Font := (Source as TColumn).Font;
    Width := (Source as TColumn).Width;
    Visible := (Source as TColumn).Visible;

    FAssigningFlag := False;
  end else
    inherited Assign(Source);
end;

procedure TgsStoreColumn.RestoreDefaults;
begin
  if FAssigningFlag then
    inherited RestoreDefaults;
end;

{
  Устанавливает формат отображения своему полю.
}

procedure TgsStoreColumn.UpdateDisplayFormat(ADataLink: TGridDataLink);
begin
  Field := ADataLink.DataSet.FindField(FieldName);

  if Assigned(Field) and (Field.FieldName <> '') then
  begin
    if Field is TNumericField then
      (Field as TNumericField).DisplayFormat := FDisplayFormat
    else if Field is TDateTimeField then
      (Field as TDateTimeField).DisplayFormat := FDisplayFormat;
  end;
end;

{
  Существует ли поле данной колонки или нет.
}

function TgsStoreColumn.IsValidField(ADataLink: TGridDataLink): Boolean;
begin
  Result := ADataLink.DataSet.FindField(FieldName) <> nil;
end;

{
  Создаем собственный класс для заглавий.
}

function TgsStoreColumn.CreateTitle: TColumnTitle;
begin
  Result := TgsStoreColumnTitle.Create(Self);
end;

{
  **********************
  ***  Private Part  ***
  **********************
}

procedure TgsStoreColumn.SetDisplayFormat(const Value: String);
begin
  if FDisplayFormat <> Value then
    FDisplayFormat := Value;
end;

function TgsStoreColumn.GetIsStored: Boolean;
begin
  Result := True;
end;

{
    ------------------------------
    ----    TgsColumn Class   ----
    ------------------------------
}

constructor TgsColumn.Create(Collection: TCollection);
begin
  inherited Create(Collection);

  FUnassigned := True;
  FBlock := False;
end;

procedure TgsColumn.RestoreDefaults;
begin
  inherited RestoreDefaults;

  if Assigned(Grid) and not (csDesigning in Grid.ComponentState) and not FBlock then
  begin
    FBlock := True;
    IsStored := True;

    (Grid as TCustomgsDBGrid).UpdateColumnWithInternalOne(Self);

    FBlock := False;
  end;
end;

{
    ------------------------------------
    ----    TCustomgsDBGrid Class   ----
    ------------------------------------
}


{
  *********************************************
  ***  Additional Procedures and functions  ***
  *********************************************
}

var
  DrawBitmap: TBitmap; // Общий BITMAP для рисования текста
  UserCount: Integer; // Кол-во пользователей BITMAP

{
  Увеличивает счетчик кол-во пользователей BITMAP.
}

procedure UsesBitmap;
begin
  if UserCount = 0 then
    DrawBitmap := TBitmap.Create;
  Inc(UserCount);
end;

{
  Уменьшает счетчик пользователей BITMAP.
}

procedure ReleaseBitmap;
begin
  Dec(UserCount);
  if UserCount = 0 then DrawBitmap.Free;
end;

{
  Процедура рисования текста. Взята из модуля DBGrids с
  изменениями.
}

procedure WriteText(ACanvas: TCanvas; const ARect, ADrawRect: TRect; DX, DY: Integer;
  const Text: string; Alignment: TAlignment; ARightToLeft, Multiline: Boolean);
const
  AlignFlags : array [TAlignment] of Integer =
    ( DT_LEFT or DT_WORDBREAK or DT_EXPANDTABS or DT_NOPREFIX,
      DT_RIGHT or DT_WORDBREAK or DT_EXPANDTABS or DT_NOPREFIX,
      DT_CENTER or DT_WORDBREAK or DT_EXPANDTABS or DT_NOPREFIX );
  RTL: array [Boolean] of Integer = (0, DT_RTLREADING);
  MultilineFlag: array[Boolean] of Integer =
    (0, DT_EDITCONTROL);
var
  B, R: TRect;
  Left: Integer;
  I: TColorRef;
begin
  I := ColorToRGB(ACanvas.Brush.Color);
  
  if (GetNearestColor(ACanvas.Handle, I) = I) and not Multiline then
  begin                       { Use ExtTextOut for solid colors }
    { In BiDi, because we changed the window origin, the text that does not
      change alignment, actually gets its alignment changed. }

    if (ACanvas.CanvasOrientation = coRightToLeft) and (not ARightToLeft) then
      ChangeBiDiModeAlignment(Alignment);

    case Alignment of
      taLeftJustify:
        Left := ARect.Left + DX;
      taRightJustify:
        Left := ARect.Right - ACanvas.TextWidth(Text) - 3;
    else { taCenter }
      Left := ARect.Left + (ARect.Right - ARect.Left) shr 1
        - (ACanvas.TextWidth(Text) shr 1);
    end;

    ACanvas.TextRect(ARect, Left, ARect.Top + DY, Text);
  end else begin
    DrawBitmap.Canvas.Lock;

    try
      if Multiline then
        with ADrawRect do
          B := Rect(0, 0, Right - Left, Bottom - Top)
      else
        with ARect do
          B := Rect(0, 0, Right - Left, Bottom - Top);

      with DrawBitmap do
      begin
        Width := Max(Width, B.Right);
        Height := Max(Height, B.Bottom);

        with ARect do
          R := Rect(DX, DY, Right - Left - 1, Bottom - Top - 1);
      end;

      with DrawBitmap.Canvas do
      begin
        Font := ACanvas.Font;
        Font.Color := ACanvas.Font.Color;
        Brush := ACanvas.Brush;
        Brush.Style := bsSolid;
        FillRect(B);
        SetBkMode(Handle, TRANSPARENT);

        if (ACanvas.CanvasOrientation = coRightToLeft) then
          ChangeBiDiModeAlignment(Alignment);

        DrawText(Handle, PChar(Text), Length(Text), R,
          AlignFlags[Alignment] or RTL[ARightToLeft] or MultilineFlag[Multiline]);
      end;

      ACanvas.CopyRect(ADrawRect, DrawBitmap.Canvas, B);
    finally
      DrawBitmap.Canvas.Unlock;
    end;
  end;
end;


{
  *********************
  ***  Public Part  ***
  *********************
}

constructor TCustomgsDBGrid.Create(AnOwner: TComponent);
begin
  inherited Create(AnOwner);

  UsesBitmap;

  FInternalMenuKind := imkWithSeparator;

  FRememberPosition := False;
  FRememberField := 'ID';

  FMasterAct := nil;
  FRefreshAct := nil;
  FFindAct := nil;
  FPanelAct := nil;

  // В режиме запуска программы создаем список действий
  if not (csDesigning in ComponentState) then
  begin
    FActionList := TActionList.Create(Self);
    FImages := TImageList.Create(Self);

    CreateActionList;
  end else begin
    FActionList := nil;
    FImages := nil;
  end;

  FInternalColumns := TDBGridColumns.Create(nil, TgsStoreColumn);

  FSelectedFont := TFont.Create;
  FSelectedFont.Color := clHighlightText;
  FSelectedFont.OnChange := DoOnFontChanged;

  FSelectedColor := clHighlight;

  FStriped := False;
  FStripeOdd := DefStripeOdd;
  FStripeEven := DefStripeEven;

  FMyOdd := skOdd;
  FMyEven := skEven;

  FExpands := TColumnExpands.Create(Self);
  FExpandsActive := False;

  FConditions := TGridConditions.Create(Self);
  FConditionsActive := False;

  if not (csDesigning in ComponentState) then
  begin
    FFindDlg := TFindDialog.Create(Self);
    FFindDlg.OnFind := DoOnFind;
    FFindDlg.Options := FFindDlg.Options;
  end else
    FFindDlg := nil;

  FCheckBox := TGridCheckBox.Create(Self);

  FScaleColumns := False;
  FCanScale := False;

  FSizedIndex := -1;
  FSizedOldWidth := -1;
  FLastRemain := -1;
  FRestrictModify := False;

  FMinColWidth := 40;
  FFormName := '';

  FFinishDrawing := True;
  FRefreshType := rtCloseOpen;

  FBlockSettings := False;
end;

destructor TCustomgsDBGrid.Destroy;
begin
  FSelectedFont.Free;
  FExpands.Free;
  FCheckBox.Free;
  FInternalColumns.Free;
  FreeAndNil(FFindDlg);

  inherited Destroy;

  ReleaseBitmap;
end;

{
  Подготовка мастера перед выводом на экран.
}

procedure TCustomgsDBGrid.PrepareMaster(AMaster: TForm);
begin
  with AMaster as TdlgMaster do
  begin
    DataLink := Self.DataLink;

    TableFont := Self.Font;
    TableColor := Self.Color;

    TitleFont := Self.TitleFont;
    TitleColor := Self.TitleColor;

    SelectedFont := Self.SelectedFont;
    SelectedColor := Self.SelectedColor;

    Striped := Self.FStriped;
    StripeEven := Self.FStripeOdd;
    StripeOdd := Self.FStripeEven;

    ExpandsActive := Self.FExpandsActive;
    ExpandsSeparate := Self.FExpandsSeparate;

    ConditionsActive := Self.FConditionsActive;
    ScaleColumns := Self.ScaleColumns;

    if Self.DataLink.Active then
      RememberColumns;

    SetOldColumns(FInternalColumns);
    SetOldExpands(FExpands);
    SetOldConditions(FConditions);

    actApply.OnExecute := DoApplyMaster;
  end;  
end;

{
  Установка паремтров мастера в визуальную таблицу.
}

procedure TCustomgsDBGrid.SetupGrid(AMaster: TForm; const UpdateGrid: Boolean = True);
var
  I: Integer;
begin
  with AMaster as TdlgMaster do
  begin
    BeginLayout;
    FCanScale := False;

    try
      Self.Font := TableFont;
      Self.Color := TableColor;

      Self.TitleFont := TitleFont;
      Self.TitleColor := TitleColor;

      Self.SelectedFont := SelectedFont;
      Self.SelectedColor := SelectedColor;

      Self.Striped := Striped;
      Self.StripeOdd := StripeEven;
      Self.StripeEven := StripeOdd;

      Self.ExpandsActive := ExpandsActive;
      Self.ExpandsSeparate := ExpandsSeparate;

      Self.ConditionsActive := ConditionsActive;
      Self.ScaleColumns := ScaleColumns;

      if Self.DataLink.Active then
      begin
        FInternalColumns.Assign(NewColumns);

        // Т.к. пока что формат отображения колонки хранится
        // в моих настройках - после присвоения настроек необходимо
        // установить данный формат соответствующей колонки TCustomDBGrid класса

        for I := 0 to FInternalColumns.Count - 1 do
          (FInternalColumns[I] as TgsStoreColumn).UpdateDisplayFormat(Self.DataLink);
            
        Expands := NewExpands;
        Conditions := NewConditions;

        UpdateColumns;
      end;

    finally
      FCanScale := True;
      EndLayout;
      
      if UpdateGrid then
      begin
        UpdateRowCount;
        CountScaleColumns;
      end;
    end;
  end;
end;

{
  Обрабатывает операции, связанные с выводом меню
  на экран.
}

procedure TCustomgsDBGrid.DefaultHandler(var Msg);
type
  TMenuCreateKind = (mckUser, mckInternal);

var
  P: TPopupMenu;
  Cell: TGridCoord;
  Column: TColumn;
  MenuCreateKind: TMenuCreateKind;
  Items: TList;
  I: Integer;
begin
  // Реагируем только на сообщения о правой кнопке мыши
  if TMessage(Msg).Msg = wm_RButtonUp then
  begin
    with TWMRButtonUp(Msg) do
    begin
      // Определяем колонку
      Cell := MouseCoord(XPos, YPos);

      // Определяем меню
      if
        (Cell.X < Integer(dgIndicator in Options))
          or
        (Cell.Y < 0)
      then begin
        P := nil;
        Column := nil;
      end else begin
        Column := Columns[RawToDataColumn(Cell.X)];
        P := Column.PopupMenu;
      end;

      if not Assigned(P) then
      begin
        if Assigned(PopupMenu) then
        begin
          P := PopupMenu;
          MenuCreateKind := mckUser;
        end else begin
          P := TPopupMenu.Create(Self);
          MenuCreateKind := mckInternal;
        end;
      end else
        MenuCreateKind := mckUser;

      Items := TList.Create;

      try
        // Заполняем меню
        FullFillMenu(Column, P, Items);

        // Активируем меню колонки
        if (P <> nil) and P.AutoPopup then
        begin
          SendCancelMode(nil);
          P.PopupComponent := Self;

          with ClientToScreen(SmallPointToPoint(Pos)) do P.Popup(X, Y);
          Application.ProcessMessages;
        end;
      finally
        Result := 0;

        if Assigned(P) then
        begin
          if MenuCreateKind = mckInternal then
            FreeAndNil(P)
          else
            for I := 0 to Items.Count - 1 do
            begin
              P.Items.Remove(Items[I]);
              TObject(Items[I]).Free;
            end;
        end;

        Items.Free;
      end;
    end;
  end else
    inherited DefaultHandler(Msg);
end;

{
  При изменении размеров окна осуществляем
  расчет размера колонок.
}

procedure TCustomgsDBGrid.SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
begin
  inherited SetBounds(ALeft, ATop, AWidth, AHeight);
  CountScaleColumns;
end;

{
  Восстановление настроек из потока.
}

procedure TCustomgsDBGrid.Read(Reader: TReader);
var
  I: Integer;

  function ReadColor(DefColor: TColor): TColor;
  begin
    try
      Result := StringToColor(Reader.ReadString);
    except
      Result := DefColor;
    end;
  end;

  procedure ReadFont(AFont: TFont);
  var
    Pitch: TFontPitch;
    Style: TFontStyles;
  begin
    Reader.ReadListBegin;

    try
      AFont.Name := Reader.ReadString;
      AFont.Color := ReadColor(AFont.Color);
      AFont.Height := Reader.ReadInteger;
      Reader.Read(Pitch, SizeOf(TFontPitch));
      AFont.Pitch := Pitch;
      AFont.Size := Reader.ReadInteger;
      Reader.Read(Style, SizeOf(TFontStyles));
      AFont.Style := Style;
      AFont.CharSet := Reader.ReadInteger;
      Reader.ReadListEnd;
    except
      Reader.ReadListEnd;
    end;
  end;

begin
  BeginLayout;
  
  try
    Reader.ReadSignature;

    ReadFont(TableFont);
    TableColor := ReadColor(TableColor);

    ReadFont(SelectedFont);
    SelectedColor := ReadColor(SelectedColor);

    ReadFont(TitleFont);
    TitleColor := ReadColor(TitleColor);

    Striped := Reader.ReadBoolean;
    StripeOdd := ReadColor(StripeOdd);
    StripeEven := ReadColor(StripeEven);

    if Reader.ReadValue = vaCollection then Reader.ReadCollection(FExpands);
    ExpandsActive := Reader.ReadBoolean;
    ExpandsSeparate := Reader.ReadBoolean;

    if Reader.ReadValue = vaCollection then Reader.ReadCollection(FConditions);
    ConditionsActive := Reader.ReadBoolean;

    if Reader.ReadValue = vaCollection then Reader.ReadCollection(FInternalColumns);

    // Т.к. пока что формат отображения колонки хранится
    // в моих настройках - после загрузки данных необходимо
    // установить данный формат соответствующей колонки TCustomDBGrid класса

    for I := 0 to FInternalColumns.Count - 1 do
      (FInternalColumns[I] as TgsStoreColumn).UpdateDisplayFormat(DataLink);

    // Если элемент расширенного отображения содержит колонки, которые
    // отсутствуют после загрузки, то этот элемент не может использоваться
    // следовательно - его следует удалить

    if DataLink.Active then
      for I := FExpands.Count - 1 downto 0 do
        if not FExpands[I].IsExpandValid(DataLink) then
          FExpands[I].Free;

    ScaleColumns := Reader.ReadBoolean;
  finally
    EndLayout;

    if DataLink.Active then UpdateColumns;
    
    if Assigned(Parent) and (LayoutLock = 0) then
    begin
      UpdateRowCount;
      CountScaleColumns;
    end;  
  end;
end;

{
  Сохранение даных в поток.
}

procedure TCustomgsDBGrid.Write(Writer: TWriter);
var
  I: Integer;

  procedure WriteFont(AFont: TFont);
  var
    Pitch: TFontPitch;
    Style: TFontStyles;
  begin
    Writer.WriteListBegin;

    Writer.WriteString(AFont.Name);
    Writer.WriteString(ColorToString(AFont.Color));
    Writer.WriteInteger(AFont.Height);
    Pitch := AFont.Pitch;
    Writer.Write(Pitch, SizeOf(TFontPitch));
    Writer.WriteInteger(AFont.Size);
    Style := AFont.Style;
    Writer.Write(Style, SizeOf(TFontStyles));
    Writer.WriteInteger(AFont.CharSet);

    Writer.WriteListEnd;
  end;

begin
  //////////////////////////////////////////////////////
  // Если до сохранения не был отключен источник данных,
  // следовательно нужно сохранить инфо о колонках

  if DataLink.Active then
    RememberColumns;

  Writer.WriteSignature;

  WriteFont(TableFont);
  Writer.WriteString(ColorToString(TableColor));

  WriteFont(SelectedFont);
  Writer.WriteString(ColorToString(SelectedColor));

  WriteFont(TitleFont);
  Writer.WriteString(ColorToString(TitleColor));

  Writer.WriteBoolean(Striped);
  Writer.WriteString(ColorToString(StripeOdd));
  Writer.WriteString(ColorToString(StripeEven));

  Writer.WriteCollection(FExpands);
  Writer.WriteBoolean(ExpandsActive);
  Writer.WriteBoolean(ExpandsSeparate);

  Writer.WriteCollection(FConditions);
  Writer.WriteBoolean(ConditionsActive);

  // Если источник данных открыт на момент сохранения,
  // необходимо проверить поля - на случай, если они
  // уже не испоьлзуются в данной таблице (например, был
  // измене запрос - исчезли одни поля, добавились другие)

  if DataLink.Active then
    for I := FInternalColumns.Count - 1 downto 0 do
      if not (FInternalColumns[I] as TgsStoreColumn).IsValidField(DataLink) then
        FInternalColumns[I].Free;

  Writer.WriteCollection(FInternalColumns);

  Writer.WriteBoolean(ScaleColumns);
end;

{
  Считывание из потока.
}

procedure TCustomgsDBGrid.LoadFromStream(Stream: TStream);
var
  R: TReader;
begin
  R := TReader.Create(Stream, 1024);
  try
    Read(R);
  finally
    R.Free;
  end;
end;

{
  Запись в поток.
}

procedure TCustomgsDBGrid.SaveToStream(Stream: TStream);
var
  W: TWriter;
begin
  W := TWriter.Create(Stream, 1024);
  try
    Write(W);
    W.FlushBuffer;
  finally
    W.Free;
  end;
end;

{
  Определяет над какой ячейкой находится курсор.
}

function TCustomgsDBGrid.GridCoordFromMouse: TGridCoord;
begin
  Result := MouseCoord(HitTest.X, HitTest.Y);
  Dec(Result.X, Integer(dgIndicator in Options));
  Dec(Result.Y, Integer(dgTitles in Options));
end;

{
  ************************
  ***  Protected Part  ***
  ************************
}

{
  Осуществляет перерисовку таблицы.
}

procedure TCustomgsDBGrid.DrawCell(ACol, ARow: Longint; ARect: TRect;
  AState: TGridDrawState);
var
  OldActive: LongInt; // Сохраненный № пп в таблице
  HighLight: Boolean; // Флаг выделения записей таблицы
  Value: string; // Значение, которое будет нарисовано
  DrawColumn: TColumn; // Текущая таблица, в которой производится рисование
  ExpandsList: TList; // Список элементов расширенного отображения
  CurrExpand: TColumnExpand; // Текущий элемент расширенного отображения
  I: Integer; // Счетчик
  CurrLine: Integer; // Текущая линия
  DefRowHeight: Integer; // Высота ячейки
  IsCheckBoxField: Boolean; // Поле отмечено
  TheField: TField; // Поле
  CurrAlignment: TAlignment;

  // Производит рисование CheckBox-ов
  procedure DrawCheckBox(const BMP: TBitmap; const R: TRect);
  var
    Pos: Integer;
  begin
    Pos := ((R.Bottom - R.Top) - BMP.Height) div 2;

    Canvas.BrushCopy
    (
      Rect(R.Left, R.Top + Pos, R.Left + CHECK_WIDTH, R.Top + Pos + CHECK_HEIGHT),
      BMP,
      Rect(0, 0, CHECK_WIDTH, CHECK_HEIGHT),
      clNone{BMP.TransparentColor}
    );
  end;
begin
  // Получаем колонку
  if (ACol - Integer(dgIndicator in Options) >= 0) and
    (ACol - Integer(dgIndicator in Options) < Columns.Count)
  then
    DrawColumn := Columns[ACol - Integer(dgIndicator in Options)]
  else
    DrawColumn := nil;

  if gdFixed in AState then
  begin

    //////////////////////////////////////////
    // Производится рисование заглавий колонок

    if FExpandsActive and Assigned(DrawColumn) and Assigned(DrawColumn.Field) then
    begin
      //////////////////////////////////////////////
      // Используется режим расширенного отображения

      Value := GetFullCaption(DrawColumn);

      Canvas.Brush.Color := DrawColumn.Title.Color;
      Self.Canvas.Font := DrawColumn.Title.Font;

      WriteText
      (
        Canvas,
        ARect, ARect, 2, 2,
        Value, DrawColumn.Title.Alignment,
        UseRightToLeftAlignmentForField(DrawColumn.Field, DrawColumn.Title.Alignment),
        False
      );

      if [dgRowLines, dgColLines] * Options = [dgRowLines, dgColLines] then
      begin
        DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_BOTTOMRIGHT);
        DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_TOPLEFT);
      end;
    end else
      inherited DrawCell(ACol, ARow, ARect, AState);

  end else with Canvas do begin

    ////////////////////////////////////////
    // Производится рисование текста колонок

    // Возвращает высоту строчки
    DefRowHeight := GetDefaultRowHeight;

    // Устанавливаем шрифт и цвет
    Self.Canvas.Font := DrawColumn.Font;
    Brush.Color := DrawColumn.Color;

    // Если данных нет, то рисуем простой прямоугольник
    if not Assigned(DataLink) or not DataLink.Active then
    begin
      FillRect(ARect);
    end else begin

      //////////////////////////////////////////////////////////////////
      // Устанавливаем указатель в базе данных на необходимую запись для
      // получения данных

      OldActive := DataLink.ActiveRecord;
      try
        // Получаем необходиму запись
        DataLink.ActiveRecord := ARow - Integer(dgTitles in Options);

        // Получаем текст для рисования
        if Assigned(DrawColumn.Field) then
          Value := DrawColumn.Field.DisplayText
        else
          Value := '';

        // Устанавливаем необходимость рисования данной ячейки выделенной
        Highlight := HighlightCell(ACol, ARow, Value, AState);

        //////////////////////////////////////////////////////////
        // Проверяем дополнительные опции по выбору шрифта и цвета

        if Highlight then
        begin

          //////////////////////////////////////////////////////////////
          // Устанавливаем цвет и шрифт для рисования выделенного текста

          Brush.Color := FSelectedColor;
          Self.Canvas.Font := FSelectedFont;
        end else begin

          ///////////////////////////////////////
          // Используется режим полосатой таблицы

          // Выбираем цвет текущей полосы в таблице
          if FStriped then
          begin
            if (ARow mod 2) = 0 then
            begin
              if FMyOdd = skOdd then
                Brush.Color := FStripeOdd
              else if FMyOdd = skEven then
                Brush.Color := FStripeEven;
            end else begin
              if FMyEven = skOdd then
                Brush.Color := FStripeOdd
              else if FMyEven = skEven then
                Brush.Color := FStripeEven;
            end;
          end;

          ////////////////////////////////////////////
          // Если используется условное форматирование

          if FConditionsActive then
          begin
            for I := 0 to FConditions.Count - 1 do
            begin
              // Пропускаем условия с ошибками
              if FConditions[I].ConditionState = csError then Continue;

              // Работаем с условием только, если его следует отображать
              // в данной колонке
              if FConditions[I].Suits(DrawColumn.Field) then
              begin
               // Подготавливаем условия, если они еще не подготовлены
               if FConditions[I].ConditionState = csUnPrepared then
                  FConditions[I].Prepare;

                // Пропускаем условия с ошибками
                if FConditions[I].ConditionState = csError then Continue;

                // Производим проверку и нанесение цвета и шрифта
                FConditions[I].CheckAndApply;
              end;
            end;
          end;
        end;

        /////////////////////////////////////////////////////
        // Если необходимо рисоват текст самостоятельно, т.е.
        // не перекрыты события рисования OnDrawColumnCell,
        // OnDrawDataCell

        if DefaultDrawing then
        begin
          IsCheckBoxField :=
            FCheckBox.Visible
              and
            (AnsiCompareText(FCheckBox.FDisplayField, DrawColumn.FieldName) = 0);

          if FExpandsActive then
          begin
            //////////////////////////////////////////////
            // Используется режим расширенного отображения

            ExpandsList := TList.Create;

            try
              GetExpandsList(DrawColumn.Field, ExpandsList);
              CurrLine := 0;
              CurrExpand := FindMainExpand(ExpandsList);

              //////////////////////////////////////////////////////
              // Рисуем главное поле, если есть настройки для него -
              // используем эти настройки

              if Assigned(CurrExpand) then
              begin

                /////////////////////////////////////////////////////
                // Если поле memo и вывод более чем в одну строку, то
                // преобразуем в текст

                if
                  Assigned(DrawColumn.Field)
                    and
                  (DrawColumn.Field is TMemoField)
                    and
                  (CurrExpand.LineCount > 1)
                then
                  Value := DrawColumn.Field.AsString;


                WriteText
                (
                  Canvas,
                  Rect
                  (
                    ARect.Left,
                    ARect.Top,
                    ARect.Right,
                    ARect.Top + DefRowHeight * (CurrLine + CurrExpand.LineCount)
                  ),
                  ARect,
                  2 + (CHECK_WIDTH + 2) * Integer(IsCheckBoxField), 2,
                  Value, DrawColumn.Alignment,
                  UseRightToLeftAlignmentForField(DrawColumn.Field, DrawColumn.Alignment),
                  (CurrLine + CurrExpand.LineCount - 1) > 0
                );

                CurrLine := CurrExpand.LineCount;
              end else begin
                WriteText
                (
                  Canvas,
                  ARect, ARect,
                  2 + (CHECK_WIDTH + 2) * Integer(IsCheckBoxField), 2,
                  Value, DrawColumn.Alignment,
                  UseRightToLeftAlignmentForField(DrawColumn.Field, DrawColumn.Alignment),
                  False
                );

                CurrLine := 1;
              end;

              for I := 0 to ExpandsList.Count - 1 do
              begin
                CurrExpand := ExpandsList[I];

                if ceoAddField in CurrExpand.Options then
                begin
                  TheField := DataLink.DataSet.FindField(CurrExpand.FieldName);
                  if TheField <> nil then
                  begin
                    if TheField is TMemoField then
                      Value := TheField.AsString
                    else
                      Value := TheField.DisplayText;

                    CurrAlignment := TheField.Alignment;
                  end else begin
                    Value := '';
                    CurrAlignment := DrawColumn.Alignment;
                  end;

                  WriteText
                  (
                    Canvas,
                    Rect
                    (
                      ARect.Left,
                      ARect.Top + DefRowHeight * CurrLine,
                      ARect.Right,
                      ARect.Top + DefRowHeight * (CurrLine + CurrExpand.LineCount)
                    ),
                    Rect
                    (
                      ARect.Left,
                      ARect.Top + DefRowHeight * CurrLine,
                      ARect.Right,
                      ARect.Bottom
                    ),
                    2, 2, Value, CurrAlignment,
                    UseRightToLeftAlignmentForField(DrawColumn.Field, DrawColumn.Alignment),
                    ceoAddFieldMultiline in CurrExpand.Options
                  );

                  /////////////////////////////////////////////////
                  // Если используется режим визуального разделения
                  // элементов расширенного отображения

                  if FExpandsSeparate then
                  begin
                    MoveTo(ARect.Left, ARect.Top + DefRowHeight * CurrLine);
                    LineTo(ARect.Right, ARect.Top + DefRowHeight * CurrLine);
                  end;

                  Inc(CurrLine, CurrExpand.LineCount);
                end;
              end;

            finally
              ExpandsList.Free;
            end;


          end else begin

            //////////////////////////
            // Обычный режим рисования

            WriteText
            (
              Canvas, ARect, ARect,
              2 + (CHECK_WIDTH + 2) * Integer(IsCheckBoxField), 2,
              Value, DrawColumn.Alignment,
              UseRightToLeftAlignmentForField(DrawColumn.Field, DrawColumn.Alignment), False
            );
          end;

          if IsCheckBoxField then
            if FCheckBox.RecordChecked then
              DrawCheckBox
              (
                FCheckBox.GlyphChecked,
                Rect
                (
                  ARect.Left + 2,
                  ARect.Top,
                  ARect.Right,
                  ARect.Top + DefRowHeight + 1
                )
              )
            else
              DrawCheckBox
              (
                FCheckBox.GlyphUnChecked,
                Rect(
                  ARect.Left + 2,
                  ARect.Top,
                  ARect.Right,
                  ARect.Top + DefRowHeight + 1
                )
              );

        end;

      finally
        DataLink.ActiveRecord := OldActive;
      end;

      // Ресуем Focus
      if
        DefaultDrawing and (gdSelected in AState)
          and
        ((dgAlwaysShowSelection in Options) or Focused)
          and
        not (csDesigning in ComponentState)
          and
        not (dgRowSelect in Options)
          and
        (UpdateLock = 0)
          and
        (ValidParentForm(Self).ActiveControl = Self)
      then
        Windows.DrawFocusRect(Handle, ARect);
    end;
  end;
end;


{
  Изменение состояния источника данных. Необходимо
  произвести действия с колонками.
}

procedure TCustomgsDBGrid.LinkActive(Active: Boolean);
begin
  if not (csDesigning in ComponentState) and not Active then
    RememberColumns;

  inherited LinkActive(Active);

  FMyOdd := skOdd;
  FMyEven := skEven;

  CountScaleColumns;
end;

{
  При скроллинге необходимо решить проблему с
  полосатой перерисовкой.
}

procedure TCustomgsDBGrid.Scroll(Distance: Integer);
begin
  if Distance <> 0 then CountStripes(Distance);
  inherited Scroll(Distance);
end;

procedure TCustomgsDBGrid.LayoutChanged;
begin
  inherited LayoutChanged;
  if DataLink.Active then CountScaleColumns;
end;

procedure TCustomgsDBGrid.RowHeightsChanged;
begin
  if not FBlockSettings then
  try
    FBlockSettings := True;
    UpdateRowCount;
  finally
    FBlockSettings := False;
  end;

  inherited RowHeightsChanged;
end;

procedure TCustomgsDBGrid.ColWidthsChanged;
var
  Difference: Integer;
  I: Integer;
  Next: Integer;

  function GetNext(Index: Integer): Integer;
  var
    Z: Integer;
  begin
    for Z := Index + 1 to ColCount - 1 do
      if Columns[Z - Integer(dgIndicator in Options)].Visible then
      begin
        Result := Z;
        Exit;
      end;

    Result := -1;
  end;

begin
  if
    FScaleColumns and FCanScale and
    (FSizedIndex <> -1) and AcquireLayoutLock
  then begin
    try
      Next := GetNext(FSizedIndex);

      if Next = -1 then
        ColWidths[FSizedIndex] := FSizedOldWidth;

      if ColWidths[FSizedIndex] < FMinColWidth then
        ColWidths[FSizedIndex] := FMinColWidth;

      if ColWidths[FSizedIndex] > FSizedOldWidth then
      begin
        Difference := ColWidths[FSizedIndex] - FSizedOldWidth;

        if Next <> -1 then
        begin
          if ColWidths[Next] - Difference < FMinColWidth then
          begin
            ColWidths[FSizedIndex] := ColWidths[FSizedIndex] +
              (ColWidths[Next] - Difference - FMinColWidth);

            Difference := ColWidths[FSizedIndex] - FSizedOldWidth;
          end;

          ColWidths[Next] := ColWidths[Next] - Difference;
        end;

      end else if ColWidths[FSizedIndex] < FSizedOldWidth then
      begin
        Difference := FSizedOldWidth - ColWidths[FSizedIndex];
        Next := GetNext(FSizedIndex);

        if Next <> -1 then
          ColWidths[Next] := ColWidths[Next] + Difference;
      end;

      for I := 0 to Columns.Count - 1 do
        Columns[I].Width := ColWidths[I + Integer(dgIndicator in Options)];
    finally
      EndLayout;
    end;
  end;

  inherited ColWidthsChanged;
end;

procedure TCustomgsDBGrid.CalcSizingState(X, Y: Integer;
  var State: TGridState; var Index, SizingPos, SizingOfs: Integer;
  var FixedInfo: TGridDrawInfo);
begin
  inherited CalcSizingState(X, Y, State, Index, SizingPos, SizingOfs, FixedInfo);

  if State = gsColSizing then
  begin
    FSizedIndex := Index;
    FSizedOldWidth := ColWidths[Index];
  end else begin
    FSizedIndex := -1;
    FSizedOldWidth := -1;
  end;
end;

procedure TCustomgsDBGrid.KeyDown(var Key: Word; Shift: TShiftState);
begin
  if Key = VK_F3 then
    FFindAct.Execute;

  if Key = VK_F5 then
    FRefreshAct.Execute;

  if Key = VK_F10 then
    FMasterAct.Execute;

  inherited KeyDown(Key, Shift);
end;

{
  Если мышкой нажали на CheckBox, необходимо обработать
  его состояние.
}

procedure TCustomgsDBGrid.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  GridCoord: TGridCoord;
  OldActive: Integer;
  SelField, DataField: TField;

  function PtInRect(P: TPoint; const R: TRect): Boolean;
  begin
    with R, P do Result := (X >= Left) and (X <= Right) and (Y >= Top) and
      (Y <= Bottom);
  end;

  function IsInCheckRect: Boolean;
  var
    R: TRect;
    Center: Integer;
  begin
    R := CellRect(GridCoord.X, GridCoord.Y);
    R.Bottom := R.Top + GetDefaultRowHeight + 1;
    Center := ((R.Bottom - R.Top) - CHECK_HEIGHT) div 2;

    with R do
    Result := PtInRect
    (
      Point(X, Y),
      Rect(Left + 2, Top + Center, Left + 2 + CHECK_WIDTH, Top + Center + CHECK_HEIGHT)
    );
  end;

begin
  GridCoord := MouseCoord(X, Y);

  if DataLink.Active and (GridCoord.X >= 0) then
    SelField := GetColField(GridCoord.X - Integer(dgIndicator in Options))
  else
    SelField := nil;

  if
    (Button = mbLeft) and DataLink.Active and Assigned(SelField) and FCheckBox.Visible
      and
    IsInCheckRect and (GridCoord.X >= Integer(dgIndicator in Options))
      and
    (GridCoord.Y >= Integer(dgTitles in Options))
      and
    (SelField = DataLink.DataSet.FindField(FCheckBox.DisplayField))
      and
    (

      (InplaceEditor = nil)
        or
      ((InplaceEditor <> nil) and not InplaceEditor.Visible)
    )
  then begin
    BeginUpdate;
    OldActive := DataLink.ActiveRecord;

    FRestrictModify := True;

    try

      // Получаем необходиму запись
      DataLink.ActiveRecord := GridCoord.Y - Integer(dgTitles in Options);

      DataField := DataLink.DataSet.FindField(FCheckBox.FieldName);

      if not Assigned(DataField) then
        raise EgsDBGridException.Create('CheckBox data field not found!');
        
      if FCheckBox.RecordChecked then
        FCheckBox.DeleteCheck(DataField.DisplayText)
      else
        FCheckBox.AddCheck(DataField.DisplayText);

    finally
      // Возвращаем курсор на ранее установленную запись
      DataLink.ActiveRecord := OldActive;

      EndUpdate;

      inherited MouseDown(Button, Shift, X, Y);

      HideEditor;
      FRestrictModify := False;
    end;

    with GridCoord do
      DrawCell(X, Y, CellRect(X, Y), [gdSelected, gdFocused]);
  end else
    inherited MouseDown(Button, Shift, X, Y);
end;

{
  Двойной щелчек - осуществляем расчет размера колонки.
}

procedure TCustomgsDBGrid.DblClick;
var
  SizedColumn: TColumn;
  ExpandsList: TList;
  Main: TColumnExpand;
  CurrWidth, MaxWidth, CaptionWidth: Integer;
  OldActive: Integer;
  I: Integer;
begin
  if
    DataLink.Active and Sizing(HitTest.X, HitTest.Y)
      and
    (FSizedIndex >= Integer(dgIndicator in Options))
      and
    (FSizedIndex <= ColCount - 1)
  then begin
    SizedColumn := Columns[FSizedIndex - Integer(dgIndicator in Options)];

    if Assigned(SizedColumn) then
    begin
      ExpandsList := TList.Create;

      try
        GetExpandsList(SizedColumn.Field, ExpandsList);
        Main := FindMainExpand(ExpandsList);

        if
          Assigned(Main) and (Main.LineCount = 1)
            or
          not Assigned(Main)
        then begin
          Canvas.Font := SizedColumn.Font;
          MaxWidth := 0;

          OldActive := DataLink.ActiveRecord;
          try
            for I := 0 to VisibleRowCount - 1 - Integer(dgTitles in Options) do
            begin
              // Получаем необходиму запись
              DataLink.ActiveRecord := I;

              CurrWidth :=
                Canvas.TextWidth(SizedColumn.Field.DisplayText) + 4;

              if
                FCheckBox.Visible
                  and
                (AnsiCompareText(SizedColumn.FieldName, FCheckBox.DisplayField) = 0)
              then
                CurrWidth := CurrWidth + CHECK_WIDTH + 4;

              if MaxWidth < CurrWidth then MaxWidth := CurrWidth;
            end;
          finally
            DataLink.ActiveRecord := OldActive;

            Canvas.Font := SizedColumn.Title.Font;
            CaptionWidth := Canvas.TextWidth(GetFullCaption(SizedColumn)) + 4;

            if MaxWidth > CaptionWidth then
              SizedColumn.Width := MaxWidth
            else
              SizedColumn.Width := CaptionWidth;
          end;
        end;
      finally
        ExpandsList.Free;
      end;
    end;
  end;

  inherited DblClick;
end;

{
  Запрет на редактирование.
}

function TCustomgsDBGrid.CanEditShow: Boolean;
begin
  Result := inherited CanEditShow and not FRestrictModify;
end;

procedure TCustomgsDBGrid.ColEnter;
begin
  if not (csDesigning in ComponentState) and Assigned(SelectedField) and
    Assigned(FFindDlg) and IsWindowVisible(FFindDlg.Handle)
  then
    SetWindowText(FFindDlg.Handle, PChar('Поиск по: ' + SelectedField.DisplayName));
end;

function TCustomgsDBGrid.CreateColumns: TDBGridColumns;
begin
  Result := TDBGridColumns.Create(Self, TgsColumn);
end;

{
  Рассчитываем кол-во строчек
}

procedure TCustomgsDBGrid.UpdateRowCount;
var
  OldRowCount, OldHeight: Integer;
  NewRowHeight: Integer;
begin
  BeginLayout;

  try
    OldRowCount := RowCount;

    ////////////////////////////
    // Сохраняем размер заглавий

    if dgTitles in Options then
      OldHeight := RowHeights[0]
    else
      OldHeight := 0;

    //////////////////////////////////////////////////////////
    // Устанавливаем свой размер, но учитываем размер заглавий

    NewRowHeight := GetDefaultRowHeight * LineCount;

    //NewRowHeight := GetDefaultRowHeight * LineCount -
    //  Integer((dgRowLines in Options) and (LineCount > 1));

    if DefaultRowHeight <> NewRowHeight then
    begin
      inherited DefaultRowHeight := NewRowHeight;

      if dgTitles in Options then
        RowHeights[0] := OldHeight;
    end;

    if (RowCount <= Integer(dgTitles in Options)) then
      inherited RowCount := Integer(dgTitles in Options) + 1;

    FixedRows := Integer(dgTitles in Options);
    with DataLink do
      if not Active or (RecordCount = 0) or not HandleAllocated then
        inherited RowCount := 1 + Integer(dgTitles in Options)
      else
      begin
        inherited RowCount := 1000;
        DataLink.BufferCount := VisibleRowCount;
        inherited RowCount := RecordCount + Integer(dgTitles in Options);

        if dgRowSelect in Options then
          TopRow := FixedRows;
      end;

    if OldRowCount <> RowCount then
      Invalidate;

  finally
    EndLayout;
  end;
end;

{
  Возвращает полное наименование заглавия колонки.
}

function TCustomgsDBGrid.GetFullCaption(AColumn: TColumn): String;
var
  ExpandsList: Tlist;
  TheField: TField;
  I: Integer;
  CurrExpand: TColumnExpand;
begin
  if not Assigned(AColumn) or not Assigned(AColumn.Field) then
  begin
    Result := '';
    Exit;
  end;

  Result := AColumn.Field.DisplayName;
  ExpandsList := TList.Create;

  try
    GetExpandsList(AColumn.Field, ExpandsList);

    for I := 0 to ExpandsList.Count - 1 do
    begin
      CurrExpand := ExpandsList[I];
      TheField := DataLink.DataSet.FindField(CurrExpand.FieldName);

      if (ceoAddField in CurrExpand.Options) and Assigned(TheField) then
        Result := Result + '\' + TheField.DisplayName;
    end;
  finally
    ExpandsList.Free;
  end;
end;

procedure TCustomgsDBGrid.GetColumnFields(AColumn: TColumn; Fields: TList);
var
  I: Integer;
  ExpandsList: TList;
begin
  if not Assigned(AColumn) or not Assigned(AColumn.Field) then
    Exit;

  Fields.Add(AColumn.Field);
  ExpandsList := TList.Create;

  try
    GetExpandsList(AColumn.Field, ExpandsList);

    for I := 0 to ExpandsList.Count - 1 do
      Fields.Add(DataLink.DataSet.FindField(
        TColumnExpand(ExpandsList[I]).FieldName));
  finally
    ExpandsList.Free;
  end;
end;

procedure TCustomgsDBGrid.UpdateColumnWithInternalOne(Column: TColumn);
var
  I: Integer;
begin
  for I := 0 to FInternalColumns.Count - 1 do
    if AnsiCompareText(FInternalColumns[I].FieldName, Column.Fieldname) = 0 then
    begin
      FInternalColumns[I].Field := nil;
      Column.Assign(FInternalColumns[I]);

      //Column.Index := FInternalColumns[I].Index;

      Break;
    end;
end;

procedure TCustomgsDBGrid.SetParent(AParent: TWinControl);
begin
  inherited SetParent(AParent);

 if
   not (csDesigning in ComponentState)
     and
   Assigned(AParent)
 then
   FFormName := GetParentForm(Self).Name;
end;

{
  Изменено кол-во колонок - ячеек.
  В данной ситуации необходимо проверить случай добавления
  новых колонок в таблицу.
}

procedure TCustomgsDBGrid.SetColumnAttributes;
var
  I, K: Integer;
  CurrColumn, InternalColumn: TColumn;
  Found: Boolean;
begin
  inherited SetColumnAttributes;

  if Assigned(Columns) and not (csDesigning in ComponentState) then
  begin
    for I := 0 to Columns.Count - 1 do
    begin
      CurrColumn := Columns[I];
      Found := False;
      InternalColumn := nil;

      for K := 0 to FInternalColumns.Count - 1 do
        if AnsiCompareText(CurrColumn.FieldName, FInternalColumns[K].FieldName) = 0 then
        begin
          InternalColumn := FInternalColumns[K];
          Found := True;
          Break;
        end;

      //////////////////////////////
      // Если во внутренних колонках
      // нет данной - добавляем ее

      if Assigned(CurrColumn.Field) and not Found then
      begin
        InternalColumn := FInternalColumns.Add;
        InternalColumn.Field := CurrColumn.Field;
        InternalColumn.Assign(CurrColumn);

        (InternalColumn as TgsStoreColumn).IsStored := False;
        try
          InternalColumn.Index := CurrColumn.Index;
        finally
          (InternalColumn as TgsStoreColumn).IsStored := True;
        end;
      end;

      /////////////////////////
      // Восстанавливаем индекс

      if (CurrColumn as TgsColumn).Unassigned and Found then
      begin
        (CurrColumn as TgsColumn).Index :=
          InternalColumn.Index;
        (CurrColumn as TgsColumn).Unassigned := False;
      end;
    end;
  end;
end;

{
  Если удаляется объект, убираем ссылку на него.
}

procedure TCustomgsDBGrid.Notification(AComponent: TComponent; Operation: TOperation);
var
  I, K: Integer;
  CurrColumn, InternalColumn: TColumn;
begin
  if Operation = opRemove then
  begin

    // Пытаемся сохранить настройки поля
    // до его уничтожения

    if (AComponent is TField) then
    begin
      for I := 0 to Columns.Count - 1 do
      begin
        CurrColumn := Columns[I];

        if (CurrColumn.Field = AComponent) then
        begin
          InternalColumn := nil;

          for K := 0 to FInternalColumns.Count - 1 do
            if
              (AnsiCompareText(CurrColumn.FieldName,
                FInternalColumns[K].FieldName) = 0)
            then begin
              InternalColumn := FInternalColumns[K];
              Break;
            end;

          if Assigned(InternalColumn) then
          begin
            InternalColumn.Assign(CurrColumn);
            InternalColumn.Field := nil;
            InternalColumn.FieldName := CurrColumn.FieldName;

            (InternalColumn as TgsStoreColumn).IsStored := False;
            InternalColumn.Index := CurrColumn.Index;
            (InternalColumn as TgsStoreColumn).IsStored := False;
          end;
        end;
      end;
    end;
  end;

  inherited Notification(AComponent, Operation);

  if Operation = opRemove then
  begin
    if AComponent = FToolBar then
      ToolBar := nil;
  end;
end;

type
  PRectArray = ^TRectArray;
  TRectArray = array[0..MaxListSize div 4] of TRect;

  PIntegerArray = ^TIntegerArray;
  TIntegerArray = array[0..MaxListSize] of Integer;

procedure TCustomgsDBGrid.Paint;
var
  I: Integer;
  X, Y: Integer;
  DrawInfo: TGridDrawInfo;

  Rects, FixedRects: PRectArray;
  PointCount, FixedPointCount: PIntegerArray;

  TotalColCount, TotalRowCount: Integer;
  R: TRect;
  Rgn: hRgn;

  OldBrushColor, OldPenColor: TColor;
begin

  //////////////////////////////////////////////////////////////////
  // Если рисуем окончание таблицы, то необходимо ограничить область
  // переисовки для родительского класса

  if FFinishDrawing and DataLink.Active then
  begin
    // Вычисляем информацию о рисовании
    CalcDrawInfo(DrawInfo);

    Rgn := CreateRectRgn(0, 0, ClientWidth, DrawInfo.Vert.GridBoundary);
    try
      SelectClipRgn(Canvas.Handle, Rgn);
    finally
      DeleteObject(Rgn);
    end;
  end;

  inherited Paint;

  ////////////////////////////////////////////////////////////////////
  // Если используется режим рисования до пределов таблицы вертикально

  if FFinishDrawing and DataLink.Active then
  begin
    OldBrushColor := Canvas.Brush.Color;
    OldPenColor := Canvas.Pen.Color;

    SelectClipRgn(Canvas.Handle, 0);

    // Вычисляем кол-во обрабатываемых колонок и строчек
    TotalRowCount :=
      (ClientHeight - DrawInfo.Vert.GridBoundary) div DefaultRowHeight + 1;
    TotalColCount :=
      ColCount - LeftCol + Integer(dgIndicator in Options);

    // Выделяем память
    GetMem(Rects, Sizeof(TRect) * (TotalColCount + TotalRowCount));
    GetMem(PointCount, SizeOf(Integer) * (TotalColCount + TotalRowCount));

    FillChar(Rects^, Sizeof(TRect) * (TotalColCount + TotalRowCount), 0);
    FillChar(PointCount^, SizeOf(Integer) * (TotalColCount + TotalRowCount), 0);

    if dgIndicator in Options then
    begin
      GetMem(FixedRects, Sizeof(TRect) * (TotalRowCount + 1));
      GetMem(FixedPointCount, SizeOf(Integer) * (TotalRowCount + 1));

      FillChar(FixedRects^, Sizeof(TRect) * (TotalRowCount + 1), 0);
      FillChar(FixedPointCount^, SizeOf(Integer) * (TotalRowCount + 1), 0);
    end else begin
      FixedRects := nil;
      FixedPointCount := nil;
    end;

    try

      ///////////////////////////////////////////////////////
      // Осуществляется определение координат рисования линий
      // таблицы

      X := - Integer(dgColLines in Options) * GridLineWidth;
      Y := DrawInfo.Vert.GridBoundary - 1;

      ///////////////////////////////////////////////////////////////
      // Осуществляем расчет и заполнение массива точек для рисования
      // горизонтальных линий

      for I := 0 to TotalColCount - 1 do
      begin
        if (I = 0) and (dgIndicator in Options) then
          Inc(X, ColWidths[0] + GridLineWidth * Integer(dgColLines in Options))
        else
          Inc(X, ColWidths[LeftCol + I - Integer(dgIndicator in Options)] +
            GridLineWidth * Integer(dgColLines in Options));

        if dgColLines in Options then
        begin
          Rects^[I] := Rect(X, Y, X, ClientHeight);
          PointCount^[I] := 2;
        end;
      end;

      ///////////////////////////////////////////////////////////////
      // Осуществляем расчет и заполнение массива точек для рисования
      // вертикальных линий

      for I := TotalColCount to TotalColCount + TotalRowCount - 1 do
      begin
        Inc(Y, DefaultRowHeight + GridLineWidth * Integer(dgRowLines in Options));

        if dgRowLines in Options then
        begin
          Rects^[I] := Rect(
            ColWidths[0] * Integer(dgIndicator in Options),
            Y,
            X, Y
          );
          
          PointCount^[I] := 2;
        end;

        /////////////////////////////////////////
        // Если режим полосатости - рисуем полосы

        if FStriped then
        begin

          ///////////////////
          // Вычисляем полосу

          if (((I - TotalColCount) + RowCount) mod 2) = 0 then
          begin
            if FMyOdd = skOdd then
              Canvas.Brush.Color := FStripeOdd
            else if FMyOdd = skEven then
              Canvas.Brush.Color := FStripeEven;
          end else begin
            if FMyEven = skOdd then
              Canvas.Brush.Color := FStripeOdd
            else if FMyEven = skEven then
              Canvas.Brush.Color := FStripeEven;
          end;
        end else
          Canvas.Brush.Color := Color;

        ///////////////////////////////
        // Осуществляем рисование полос

        Canvas.FillRect(Rect
        (
          ColWidths[0] * Integer(dgindicator in Options),
          Y - DefaultRowHeight - GridLineWidth * Integer(dgRowLines in Options) +
            Integer(I = TotalColCount),
          X, Y
        ));

        ////////////////////////////////////
        // Осуществляем рисование индикатора

        if dgIndicator in Options then
        begin
          R := Rect(
            0, Y - DefaultRowHeight,
            ColWidths[0], Y
          );

          Canvas.Brush.Color := FixedColor;
          Canvas.FillRect(R);

          if [dgRowLines, dgColLines] * Options = [dgRowLines, dgColLines] then
          begin
            DrawEdge(Canvas.Handle, R, BDR_RAISEDINNER, BF_BOTTOMRIGHT);
            DrawEdge(Canvas.Handle, R, BDR_RAISEDINNER, BF_TOPLEFT);
          end;
        end;
      end;

      if (dgColLines in Options) or (dgRowLines in Options) then
      begin
        Canvas.Pen.Color := clSilver;
        if ColorToRGB(Color) = clSilver then Canvas.Pen.Color := clGray;
      end;

      if dgColLines in Options then
        PolyPolyLine(Canvas.Handle, Rects^, PointCount^, TotalColCount);


      if dgRowLines in Options then
        PolyPolyLine(
          Canvas.Handle,
          PRectArray(Rects)^[TotalColCount],
          PIntegerArray(PointCount)^[TotalColCount],
          TotalRowCount
        );


      ////////////////////////////////////////////////////////////////////////
      // Если используется индикатор, то осуществляем рисование линий для него

      if dgIndicator in Options then
      begin
        Y := DrawInfo.Vert.GridBoundary - 1;

        if dgColLines in Options then
        begin
          FixedRects^[TotalRowCount] := Rect(ColWidths[0], Y, ColWidths[0], ClientHeight);
          FixedPointCount^[TotalRowCount] := 2;
        end;

        if dgRowLines in Options then
          for I := 0 to TotalRowCount - 1 do
          begin
            Inc(Y, DefaultRowHeight + GridLineWidth * Integer(dgRowLines in Options));
            FixedRects^[I] := Rect(0, Y, ColWidths[0], Y);
            FixedPointCount^[I] := 2;
          end;

        Canvas.Pen.Color := clBlack;

        if dgRowLines in Options then
          PolyPolyLine(
            Canvas.Handle,
            FixedRects^,
            FixedPointCount^,
            TotalRowCount + Integer(dgColLines in Options)
          )
        else if dgColLines in Options then
          PolyPolyLine(
            Canvas.Handle,
            PRectArray(FixedRects)^[TotalRowCount],
            PIntegerArray(FixedPointCount)^[TotalRowCount],
            1
          );
      end;

      Canvas.Brush.Color := Color;
      Canvas.FillRect(Rect(
        X + Integer(dgColLines in Options) * GridLineWidth,
        DrawInfo.Vert.GridBoundary,
        ClientWidth,
        ClientHeight)
      );

    finally
      FreeMem(Rects, Sizeof(TRect) * (TotalColCount + TotalRowCount));
      FreeMem(PointCount, SizeOf(Integer) * (TotalColCount + TotalRowCount));

      if dgIndicator in Options then
      begin
        FreeMem(FixedRects, Sizeof(TRect) * (TotalRowCount + 1));
        FreeMem(FixedPointCount, SizeOf(Integer) * (TotalRowCount + 1));
      end;

      Canvas.Brush.Color := OldBrushColor;
      Canvas.Pen.Color := OldPenColor;
    end;
  end;
end;

class function TCustomgsDBGrid.GridClassType: TgsDBGridClass;
begin
  Result := TCustomgsDBGrid;
end;

{
  **********************
  ***  Private Part  ***
  **********************
}

function TCustomgsDBGrid.GetTableFont: TFont;
begin
  Result := inherited Font;
end;

procedure TCustomgsDBGrid.SetTableFont(const Value: TFont);
begin
  inherited Font := Value;
end;

function TCustomgsDBGrid.GetTableColor: TColor;
begin
  Result := Color;
end;

procedure TCustomgsDBGrid.SetTableColor(const Value: TColor);
begin
  Color := Value;
end;

function TCustomgsDBGrid.GetSelectedFont: TFont;
begin
  Result := FSelectedFont;
end;

procedure TCustomgsDBGrid.SetSelectedFont(const Value: TFont);
begin
  FSelectedFont.Assign(Value);
  if UpdateLock = 0 then Invalidate;
end;

function TCustomgsDBGrid.GetSelectedColor: TColor;
begin
  Result := FSelectedColor;
end;

procedure TCustomgsDBGrid.SetSelectedColor(const Value: TColor);
begin
  if FSelectedColor <> Value then
  begin
    FSelectedColor := Value;
    if UpdateLock = 0 then Invalidate;
  end;
end;

function TCustomgsDBGrid.GetTitleFont: TFont;
begin
  Result := inherited TitleFont;
end;

procedure TCustomgsDBGrid.SetTitleFont(const Value: TFont);
begin
  inherited TitleFont := Value;
end;

function TCustomgsDBGrid.GetTitleColor: TColor;
begin
  Result := FixedColor;
end;

procedure TCustomgsDBGrid.SetTitleColor(const Value: TColor);
begin
  FixedColor := Value;
end;

{
  Устанавливается новый источник данных. Необходимо получить
  сведения о настройках.
}

procedure TCustomgsDBGrid.SetDataSource(Value: TDataSource);
begin
  if (Value <> DataSource) and Assigned(DataSource) then
    FreeColumnsInfo;

  inherited DataSource := Value;
end;

{
  Устанавливается режим полосатой таблицы.
}

procedure TCustomgsDBGrid.SetStriped(const Value: Boolean);
begin
  if Value <> FStriped then
  begin
    FStriped := Value;
    if UpdateLock = 0 then Invalidate;
  end;
end;

{
  Устанавливается цвет первой полосы.
}

procedure TCustomgsDBGrid.SetStripeOdd(const Value: TColor);
begin
  if Value <> FStripeOdd then
  begin
    FStripeOdd := Value;
    if UpdateLock = 0 then Invalidate;
  end;
end;

{
  Устанавливается цвет второй полосы.
}

procedure TCustomgsDBGrid.SetStripeEven(const Value: TColor);
begin
  if Value <> FStripeEven then
  begin
    FStripeEven := Value;
    if UpdateLock = 0 then Invalidate;
  end;
end;

{
  Определяет кол-во линий.
}

function TCustomgsDBGrid.GetLineCount: Integer;
var
  CurrExpand: TColumnExpand;
  CurrField: TField;
  Lines: array of Integer;
  I: Integer;
begin
  Result := 1;
  if not FExpandsActive or not DataLink.Active then Exit;

  SetLength(Lines, DataLink.DataSet.FieldCount);

  for I := 0 to Length(Lines) - 1 do Lines[I] := 1;

  for I := FExpands.Count - 1 downto 0 do
  begin
    CurrExpand := FExpands[I];
    CurrField := DataLink.DataSet.FindField(CurrExpand.DisplayName);

    if not Assigned(CurrField) then
    begin
      // Если нет поля на расширенное
      // отображение - удаляем элемент
      FreeAndNil(CurrExpand);
      Continue;
    end else begin
      if ceoMultiline in CurrExpand.Options then
        Lines[CurrField.Index] := CurrExpand.LineCount
      else
        Lines[CurrField.Index] := Lines[CurrField.Index] + CurrExpand.LineCount;
    end;

    if Lines[CurrField.Index] > Result then
      Result := Lines[CurrField.Index];
  end;
end;

{
  Возвращает кол-во видимых колонок.
}

function TCustomgsDBGrid.GetVisibleColumnCount: Integer;
var
  I: Integer;
begin
  Result := 0;
  if Assigned(Columns) then
    for I := 0 to Columns.Count - 1 do
      if Columns[I].Visible then Inc(Result);
end;

{
  Устанавливаем настройки расширенного отображения.
}

procedure TCustomgsDBGrid.SetColumnExpands(const Value: TColumnExpands);
begin
  FExpands.Assign(Value);

  if LayoutLock = 0 then
    UpdateRowCount;
end;

{
  Использовать расширенное отображение или нет
}

procedure TCustomgsDBGrid.SetExpandsActive(const Value: Boolean);
begin
  if FExpandsActive <> Value then
  begin
    FExpandsActive := Value;

    if LayoutLock = 0 then
      UpdateRowCount;
  end;
end;

{
  Использовать резделитель элементов расширенного отображения.
}

procedure TCustomgsDBGrid.SetExpandsSeparate(const Value: Boolean);
begin
  if FExpandsSeparate <> Value then
  begin
    FExpandsSeparate := Value;

    if (UpdateLock = 0) and FExpandsActive then
      Invalidate;
  end;
end;

{
  Коллекция условий
}

procedure TCustomgsDBGrid.SetConditions(const Value: TGridConditions);
begin
  FConditions.Assign(Value);
  if FConditionsActive and (UpdateLock = 0) then Invalidate;
end;

{
  Используются ли уловия
}

procedure TCustomgsDBGrid.SetConditionsActive(const Value: Boolean);
begin
  if FConditionsActive <> Value then
  begin
    FConditionsActive := Value;
    if UpdateLock = 0 then Invalidate;
  end;
end;

{
  Устанавливаем значения класса TGridCheckBox.
}

procedure TCustomgsDBGrid.SetCheckBox(const Value: TGridCheckBox);
begin
  FCheckBox.Assign(Value);
end;

{
  Устанавливаем или снимаем режим растягивания колонок.
}

procedure TCustomgsDBGrid.SetScaleColumns(const Value: Boolean);
begin
  if FScaleColumns <> Value then
  begin
    FScaleColumns := Value;

    if (LayoutLock = 0) and FScaleColumns then
      CountScaleColumns;
  end;
end;

{
  Устанавливает минимальный размер колонок.
}

procedure TCustomgsDBGrid.SetMinColWidth(const Value: Integer);
begin
  if FMinColWidth <> Value then
  begin
    FMinColWidth := Value;
    CountScaleColumns;
    LayoutChanged;
  end;
end;

{
  Панель инструментов для данной таблицы
}

procedure TCustomgsDBGrid.SetToolBar(const Value: TToolBar);
begin
  if FToolBar <> Value then
  begin
    if
      Assigned(FToolBar)
        and
      not (csDesigning in ComponentState)
    then
      RemoveActions(FToolBar);

    FToolBar := Value;

    if
      Assigned(FToolBar)
        and
      not (csDesigning in ComponentState)
    then
      SetupActions(FToolBar);
  end;
end;

{
  Заканчивать ли рисование до края таблицы вертикально
}
procedure TCustomgsDBGrid.SetFinishDrawing(const Value: Boolean);
begin
  if Value <> FFinishDrawing then
  begin
    FFinishDrawing := Value;
    if UpdateLock = 0 then Invalidate;
  end;
end;

{
  Создает список действий для таблицы.
}

procedure TCustomgsDBGrid.CreateActionList;

  // Добавляет новое действие
  function NewAction: TAction;
  begin
    Result := TAction.Create(FActionList);
    Result.ActionList := FActionList;
  end;

begin
  FImages.Width := 16;
  FImages.Height := 16;

  FImages.GetResource(rtBitmap, 'ALL', 16, [lrDefaultColor], clOlive);
  FActionList.Images := FImages;

  // Пункт Мастер установок
  FMasterAct := NewAction;
  FMasterAct.OnExecute := DoShowMaster;
  FMasterAct.ShortCut := VK_F10;
  FMasterAct.Caption := MENU_MASTER;
  FMasterAct.ImageIndex := 0;
  FMasterAct.Hint := MENU_MASTER;

  // Пункт Обновить данные
  FRefreshAct := NewAction;
  FRefreshAct.OnExecute := DoOnRefresh;
  FRefreshAct.ShortCut := VK_F5;
  FRefreshAct.Caption := MENU_REFRESH;
  FRefreshAct.ImageIndex := 1;
  FRefreshAct.Hint := MENU_REFRESH;

  // Пункт Найти
  FFindAct := NewAction;
  FFindAct.OnExecute := DoOnFindExecute;
  FFindAct.ShortCut := VK_F3;
  FFindAct.Caption := MENU_FIND;
  FFindAct.ImageIndex := 2;
  FFindAct.Hint := MENU_FIND;

  // Пункт Панель инструментов
  FPanelAct := NewAction;
  FPanelAct.OnExecute := DoOnPanel;
  FPanelAct.Caption := MENU_PANEL;
  FPanelAct.ImageIndex := -1;
  FPanelAct.Hint := MENU_PANEL;
end;

{
  Создаем внутреннее меню.
}

procedure TCustomgsDBGrid.FullFillMenu(PopupColumn: TColumn;
  APopupMenu: TPopupMenu; Items: TList);

var
  MenuItem: TMenuItem;

  // Добавляем элемент в меню
  function AddItem(Group: TMenuItem; S: String): TMenuItem;
  begin
    Result := TMenuItem.Create(Self);
    Result.Caption := S;
    Group.Add(Result);
  end;

begin
  if Assigned(APopupMenu) then
  begin
    // Если нужен разделитель, добавляем его
    if (FInternalMenuKind = imkWithSeparator) and (APopupMenu.Items.Count > 0) then
      Items.Add(AddItem(APopupMenu.Items, '-'));

    // Пункт Мастер установок
    MenuItem := AddItem(APopupMenu.Items, '');
    MenuItem.Action := FMasterAct;
    Items.Add(MenuItem);

    if DataLink.Active then
    begin
      // Разделитель
      Items.Add(AddItem(APopupMenu.Items, '-'));

      // Пункт Обновить данные
      MenuItem := AddItem(APopupMenu.Items, '');
      MenuItem.Action := FRefreshAct;
      Items.Add(MenuItem);

      // Пункт Найти
      MenuItem := AddItem(APopupMenu.Items, '');
      MenuItem.Action := FFindAct;
      Items.Add(MenuItem);
    end;

    if Assigned(FToolBar) then
    begin
      // Разделитель
      Items.Add(AddItem(APopupMenu.Items, '-'));

      // Пункт панель инструментов
      MenuItem := AddItem(APopupMenu.Items, '');
      MenuItem.Action := FPanelAct;
      Items.Add(MenuItem);
      FPanelAct.Checked := FToolBar.Visible; 
    end;
  end;
end;

{
  Освобождаем память - удаляем колонки старого исчтоника
  данных.
}

procedure TCustomgsDBGrid.FreeColumnsInfo;
begin
  FInternalColumns.Clear;
end;

{
  Синхронизирует данные FInternalColumns с данными Columns
  наследуемого класса TCustomDBGrid.
}

procedure TCustomgsDBGrid.UpdateColumns;
var
  I, K: Integer;
  InternalColumn, CurrColumn: TColumn;
begin
  BeginLayout;
  //Columns.BeginUpdate;

  try
    ////////////////////////////////////////
    // Осуществляет перенос данных в колонки

    for I := 0 to FInternalColumns.Count - 1 do
    begin
      InternalColumn := FInternalColumns[I];
      (InternalColumn as TgsStoreColumn).UpdateDisplayFormat(DataLink);

      for K := 0 to Columns.Count - 1 do
      begin
        CurrColumn := Columns[K];

        if AnsiCompareText(CurrColumn.FieldName, InternalColumn.FieldName) = 0 then
        begin
          CurrColumn.Assign(InternalColumn);

          if InternalColumn.Index < Columns.Count then
          begin
            CurrColumn.Index := InternalColumn.Index;

            if Assigned(CurrColumn.Field) then
              CurrColumn.Field.Index := InternalColumn.Index;
          end else begin
            CurrColumn.Index := Columns.Count - 1;

            if Assigned(CurrColumn.Field) then
              CurrColumn.Field.Index := Columns.Count - 1;
          end;

          Break;
        end;
      end;
    end;

  finally
    //Columns.EndUpdate;
    EndLayout;
  end;
end;

procedure TCustomgsDBGrid.RememberColumns;
var
  I, K: Integer;
  InternalColumn, CurrColumn: TColumn;
begin
  ////////////////////////////////////////
  // Осуществляет перенос данных в колонки
  FInternalColumns.BeginUpdate;

  try
    for I := 0 to FInternalColumns.Count - 1 do
    begin
      InternalColumn := FInternalColumns[I];

      for K := 0 to Columns.Count - 1 do
      begin
        CurrColumn := Columns[K];

        if AnsiCompareText(CurrColumn.FieldName, InternalColumn.FieldName) = 0 then
        begin
          InternalColumn.Field := CurrColumn.Field;
          InternalColumn.Assign(CurrColumn);

          (InternalColumn as TgsStoreColumn).IsStored := False;
          try
            InternalColumn.Index := CurrColumn.Index;
          finally
            (InternalColumn as TgsStoreColumn).IsStored := True;
          end;

          Break;
        end;
      end;
    end;
  finally
    FInternalColumns.EndUpdate;
  end;
end;

{
  Добавляет кнопки в панель управления.
}

procedure TCustomgsDBGrid.SetupActions(AToolBar: TToolBar);
var
  T: TToolButton;

  // Позиция, куда будет добавлена новая кнопка
  function GetStartPosition: Integer;
  begin
    with AToolBar do
    begin
      if ButtonCount > 0 then
        Result := Buttons[ButtonCount - 1].Left +
          Buttons[ButtonCount - 1].Width
      else
        Result := 0;
    end;
  end;

begin
  AToolBar.Images := FImages;

  T := TToolButton.Create(AToolBar);
  AToolBar.InsertControl(T);
  T.Style := tbsButton;
  T.Left := GetStartPosition;
  T.Action := FMasterAct;
  T.Tag := Integer(Self);

  T := TToolButton.Create(AToolBar);
  AToolBar.InsertControl(T);
  T.Style := tbsButton;
  T.Left := GetStartPosition;
  T.Action := FRefreshAct;
  T.Tag := Integer(Self);

  T := TToolButton.Create(AToolBar);
  AToolBar.InsertControl(T);
  T.Style := tbsSeparator;
  T.Left := GetStartPosition;
  T.Tag := Integer(Self);

  T := TToolButton.Create(AToolBar);
  AToolBar.InsertControl(T);
  T.Style := tbsButton;
  T.Left := GetStartPosition;
  T.Action := FFindAct;
  T.Tag := Integer(Self);
end;

{
  Удаляет кнопки из панели управления.
}

procedure TCustomgsDBGrid.RemoveActions(AToolBar: TToolBar);
var
  I: Integer;
begin
  with AToolBar do
  for I := ButtonCount - 1 downto 0 do
    if (Pointer(Buttons[I].Tag) = Self) then
      Buttons[I].Free;
end;

{
  Показывает мастер установок таблицы.
}

procedure TCustomgsDBGrid.DoShowMaster(Sender: TObject);
var
  Master: TdlgMaster;
begin
  Master := TdlgMaster.Create(Self, GridClassType);
  try
    PrepareMaster(Master);

    if Master.ShowModal = mrOk then
      SetupGrid(Master);
  finally
    Master.Free;
  end;
end;

{
  Все настройки диалога переносятся в таблицу.
}

procedure TCustomgsDBGrid.DoApplyMaster(Sender: TObject);
var
  MasterForm: TdlgMaster;
begin
  MasterForm := (Sender as TAction).Owner as TdlgMaster;
  MasterForm.CheckSettings;
  SetupGrid(MasterForm);
end;

{
  Активация диалогового окна поиска.
}

procedure TCustomgsDBGrid.DoOnFindExecute(Sender: TObject);
begin
  if not DataLink.Active then Exit;

  if Assigned(SelectedField) and Assigned(FFindDlg) then
  begin
    FFindDlg.Execute;
    SetWindowText(FFindDlg.Handle, PChar('Поиск по: ' + SelectedField.DisplayName));
  end;
end;

{
  Осуществляет поиск данных в таблице.
}

procedure TCustomgsDBGrid.DoOnFind(Sender: TObject);
var
  BookMark: TBookmark;
  Found: Boolean;
  Text, CompareText: String;
  IsMovedToStart: Boolean;
  Fields: TList;
  I: Integer;
  CurrField: TField;
begin
  if (not DataLink.Active) or (not Assigned(FFindDlg)) then
     exit;

  Found := False;

  if not (frMatchCase in FFindDlg.Options) then
    Text := AnsiUpperCase(FFindDlg.FindText)
  else
    Text := FFindDlg.FindText;

  BookMark := DataSource.DataSet.GetBookmark;
  DataSource.DataSet.DisableControls;

  IsMovedToStart := False;
  Fields := TList.Create;

  try
    GetColumnFields(ColumnByField(SelectedField), Fields);

    while True do
    begin
      if frDown in FFindDlg.Options then
      begin
        DataSource.DataSet.Next;

        if DataSource.DataSet.EOF then
        begin
          if
            not IsMovedToStart
              and
            (MessageBox(Handle,
              'Заданное значение не найдено. Продолжить поиск с начала списка?',
              'Внимание!', MB_OKCANCEL or MB_ICONQUESTION) = ID_OK)
          then begin
            IsMovedToStart := True;
            DataSource.DataSet.First;
          end else
            Break;
        end;
      end else begin
        DataSource.DataSet.Prior;
        if DataSource.DataSet.BOF then Break;
      end;

      for I := 0 to Fields.Count - 1 do
      begin
        CurrField := Fields[I];
        if not Assigned(CurrField) then Continue;

        if not (frMatchCase in FFindDlg.Options) then
        begin
          if CurrField.DataType in [ftMemo, ftBlob] then
            CompareText := AnsiUpperCase(CurrField.AsString)
          else
            CompareText := AnsiUpperCase(CurrField.DisplayText);
        end else begin
          if CurrField.DataType in [ftMemo, ftBlob] then
            CompareText := CurrField.AsString
          else
            CompareText := CurrField.DisplayText;
        end;

        if
          (
            (frWholeWord in FFindDlg.Options)
              and
            (Text = CompareText)
          )
            or
          (
            not (frWholeWord in FFindDlg.Options)
              and
            (StrIPos(Text, CompareText) > 0)
          )
        then begin
          Found := True;
          Break;
        end;
      end;

      if Found then Break;
    end;

    if
      not Found
        and
      DataSource.DataSet.BookmarkValid(BookMark)
    then begin
      DataSource.DataSet.GotoBookmark(Bookmark);
      MessageBox(FFindDlg.Handle, 'Значение не найдено!', 'Внимание!', MB_OK or MB_ICONINFORMATION);
    end;
  finally
    DataSource.DataSet.EnableControls;
    DataSource.DataSet.FreeBookmark(Bookmark);
    Fields.Free;
  end;
end;

{
  Обновление данных.

  После полного обновления данных важно вернуть курсор на место.
  Мы запоминаем ИД записи, на которой стоял курсор до удаления
  и ИД следующей за ней записи. После обновления пытаемся найти
  такую запись. Если есть, то все нормально, если ее нет, то ищем
  ИД следующей записи.

  Проблемы, которые остались:

  1. Если и следующая запись будет удалена, то курсор
     станет на первую строку. Как решить непонятно. Запоимнать
     еще один ИД (следующий после следующего), а если и та запись будет
     удалена?

  2. Если выделено несколько записей, то надо запоминать ИД, той на которой стоит курсор
     и ИД следующей, за последней записью в выделенном блоке, в которм стоит кусор.

  3. На время, когда мы запоминаем ИД и бегаем по таблице -- деактивировать
     контролы.

  4. Проверки сделаны не оптимально. В большинстве случаев ИД будет  одно поле,
     а унас оптимизировано под ключи из нескольких полей.
}

{ TODO -oандрэй -cзрабіць : см. выше. }

procedure TCustomgsDBGrid.DoOnRefresh(Sender: TObject);
var
  Field: TField;
  SelectedFieldName: String;
  Values: array[1..2] of array of Variant;
  Fields: TStringList;
  I, OldTopRow, OldRow: Integer;

  procedure ParseFieldsString(S: String);
  (*
  var
    Z: Integer;
  *)
  begin
    CharReplace(S, ';', ',');
    Fields.CommaText := S;

    (*
    Fields.Clear;
    S := Trim(S);

    repeat
      Z := Pos(';', S);

      if Z > 0 then
      begin
        Fields.Add(Copy(S, 1, Z - 1));
        S := Copy(S, Z + 1, Length(S));
      end else begin
        Fields.Add(S);
        S := '';
      end;
    until Z <= 0;
    *)
  end;

begin
  if DataLink.Active then
    case FRefreshType of
      rtRefresh:
        DataSource.DataSet.Refresh;

      rtCloseOpen:
      begin
        Fields := TStringList.Create;
        SetLength(Values[1], 0);
        SetLength(Values[2], 0);
        OldTopRow := -1;
        OldRow := -1;

        DataLink.DataSet.DisableControls;
        try
          if FRememberPosition then
          begin
            OldTopRow := TopRow;
            OldRow := Row;

            ////////////////////////////////////
            // Разбиваем строку со списком полей

            ParseFieldsString(FRememberField);
            SetLength(Values[1], Fields.Count);

            /////////////////////////////
            // Считываем значения полей и
            // формируем массив

            for I := 0 to Fields.Count - 1 do
            begin
              Field := DataLink.DataSet.FindField(Fields[I]);

              if Assigned(Field) then
                Values[1][I] := Field.AsVariant
              else
                Values[1][I] := NULL;
            end;

            DataLink.DataSet.Next;

            if DataLink.DataSet.EOF then
              SetLength(Values[2], 0)
            else
            begin
              SetLength(Values[2], Fields.Count);

              for I := 0 to Fields.Count - 1 do
              begin
                Field := DataLink.DataSet.FindField(Fields[I]);

                if Assigned(Field) then
                  Values[2][I] := Field.AsVariant
                else
                  Values[2][I] := NULL;
              end;

              DataLink.DataSet.Prior;
            end;

          end else
          begin
            SelectedFieldName := '';
            SetLength(Values[1], 0);
            SetLength(Values[2], 0);
          end;

          ////////////////////////////////////
          // Сохраняем выделенное в визуальной
          // таблице поле

          if Assigned(SelectedField) then
            SelectedFieldName := SelectedField.FieldName
          else
            SelectedFieldName := '';

          ////////////////////////
          // Обноавляем сам запрос

          DataLink.DataSet.Close;
          DataLink.DataSet.Open;

          //////////////////////////////
          // Восстанавливаем положение в
          // визуальной таблице

          if SelectedFieldName <> '' then
            SelectedField := DataLink.DataSet.FindField(SelectedFieldName);

          if FRememberPosition then
          begin
            ////////////////////////////////////
            // Если несколько полей, то работаем
            // с массивом значений, если одно
            // работаем с вариант переменной

            if not (((Fields.Count > 1) and (DataLink.DataSet.Locate(FRememberField, VarArrayOf(Values[1]), []))) or
              ((Fields.Count = 1) and (DataLink.DataSet.Locate(FRememberField, Values[1][0], [])))) then
            begin
              if Length(Values[2]) > 0 then
              begin
                if Fields.Count > 1 then
                  DataLink.DataSet.Locate(FRememberField, VarArrayOf(Values[2]), [])
                else
                  DataLink.DataSet.Locate(FRememberField, Values[2][0], []);
              end else
                DataLink.DataSet.Last;
            end;

            if OldRow > -1 then
              Row := OldRow;

            if OldTopRow > -1 then
              TopRow := OldTopRow;

            (*
            if Fields.Count > 1 then
              DataLink.DataSet.Locate(FRememberField, VarArrayOf(Values), [])
            else
              DataLink.DataSet.Locate(FRememberField, Values[0], []);
            *)
          end;
        finally
          Fields.Free;
          SetLength(Values[1], 0);
          SetLength(Values[2], 0);
          DataLink.DataSet.EnableControls;
        end;
      end;
    end;
end;

{
  Устанавливам видимость панели управления
}

procedure TCustomgsDBGrid.DoOnPanel(Sender: TObject);
begin
  FToolBar.Visible := not FPanelAct.Checked;
end;

{
  Рассчет первой полосы.
}

procedure TCustomgsDBGrid.CountStripes(Distance: Integer);
begin
  if (Distance mod 2 <> 0) then
    if FMyOdd = skOdd then
    begin
      FMyOdd := skEven;
      FMyEven := skOdd;
    end else begin
      FMyOdd := skOdd;
      FMyEven := skEven;
    end;
end;

{
  Возвращает список элементов расширенного отображения по
  указанному полю.
}

procedure TCustomgsDBGrid.GetExpandsList(Field: TField; List: TList);
var
  I: Integer;
begin
  List.Clear;

  for I := 0 to FExpands.Count - 1 do
    if AnsiCompareText(FExpands[I].DisplayField, Field.FieldName) = 0 then
      List.Add(FExpands[I]);
end;

{
  Осуществляет поиск главного элемента расширенного отображения.
  Главный элемент - элемент для поля отображения, где может быть
  указано, кол-во строк для поля колонки.
}

function TCustomgsDBGrid.FindMainExpand(List: TList): TColumnExpand;
var
  I: Integer;
begin
  for I := 0 to List.Count - 1 do
    if ceoMultiline in TColumnExpand(List[I]).Options then
    begin
      Result := List[I];
      List.Delete(I);
      Exit;
    end;

  Result := nil;
end;

{
  Определяет размер заглавий
}

function TCustomgsDBGrid.GetDefaultRowHeight: Integer;
begin
  if not Canvas.Handle = 0 then
    Result := DefaultRowHeight
  else begin
    Canvas.Font := Font;
    Result := Canvas.TextHeight('Wg') + 3;
    if dgRowLines in Options then
      Inc(Result, GridLineWidth);
  end;
end;

{
  Если используется родительских шрифт,
  присваиваем его своим шрифтам.
}

procedure TCustomgsDBGrid.CMParentFontChanged(var Message: TMessage);
begin
  inherited;

  if ParentFont then
  begin
    TableFont := Font;
    TitleFont := Font;

    FSelectedFont.OnChange := nil;
    FSelectedFont.Assign(Font);

    if FSelectedFont.Color = clWindowText then
      FSelectedFont.Color := clHighlightText;

    FSelectedFont.OnChange := DoOnFontChanged;

    if UpdateLock = 0 then Invalidate;
  end;
end;

procedure TCustomgsDBGrid.WMChar(var Message: TWMChar);
var
  DataField: TField;
begin
  if
    (Message.CharCode = VK_SPACE) and DataLink.Active and FCheckBox.Visible
      and
    (SelectedField = DataLink.DataSet.FindField(FCheckBox.DisplayField))
      and
    (

      (InplaceEditor = nil)
        or
      ((InplaceEditor <> nil) and not InplaceEditor.Visible)
    )
  then begin
    BeginUpdate;

    try

      DataField := DataLink.DataSet.FindField(FCheckBox.FieldName);

      if FCheckBox.RecordChecked then
        FCheckBox.DeleteCheck(DataField.DisplayText)
      else
        FCheckBox.AddCheck(DataField.DisplayText);

    finally
      EndUpdate;
    end;

    DrawCell(Col, Row, CellRect(Col, Row), [gdSelected, gdFocused]);
  end else
    inherited;
end;

procedure TCustomgsDBGrid.WMEraseBkgnd(var Message: TWmEraseBkgnd);
begin
  Message.Result := 1;
end;

{
  Если изменен какой-либо из шрифтов, то убираем родтельский шрифт.
}

procedure TCustomgsDBGrid.DoOnFontChanged(Sender: TObject);
begin
  ParentFont := False;
end;

{
  Производит расчет растягиваемых колонок.
}

procedure TCustomgsDBGrid.CountScaleColumns;
var
  OldWidth, CurrWidth, Remains: Integer;
  Percent: Double;
  I: Integer;
  TotalyRemained: Integer;

  // Подсчитывает, какой кролонке следующей следует добавить
  // оставшиеся пикселы
  procedure CountNewRemainColumn(const Depth: Integer = 1);
  begin
    if FLastRemain < Columns.Count - 1 then
      Inc(FLastRemain)
    else
      FLastRemain := 0;
  end;

begin
  if FScaleColumns and FCanScale and DataLink.Active and Assigned(Parent) then
  begin
    OldWidth := 0;

    // Расчет старого размера
    if dgIndicator in Options then
      Inc(OldWidth, ColWidths[0] + GridLineWidth * Integer(dgColLines in Options));

    for I := 0 to Columns.Count - 1 do
      if Columns[I].Visible then
        Inc(OldWidth, Columns[I].Width +
          GridLineWidth * Integer(dgColLines in Options));

    if OldWidth > 0 then
      Percent := ClientWidth / OldWidth
    else
      Percent := 0;

    // Установка новых размеров
    if AcquireLayoutLock then
    try
      CurrWidth := 0;
      if dgIndicator in Options then
        Inc(CurrWidth, ColWidths[0] + GridLineWidth * Integer(dgColLines in Options));

      for I := Integer(dgIndicator in Options) to ColCount - 1 do
      begin
        if Columns[I - Integer(dgIndicator in Options)].Visible then
        begin
          ColWidths[I] := Round(ColWidths[I] * Percent);

          if ColWidths[I] < FMinColWidth then
            ColWidths[I] := FMinColWidth;

          Inc(CurrWidth, ColWidths[I] +
            GridLineWidth * Integer(dgColLines in Options));
        end;
      end;

      // Подсчет нового размера
      Remains := ClientWidth - CurrWidth;
      TotalyRemained := -1;

      repeat
        // Определяем колонку, которой отдаем весь остаток.
        CountNewRemainColumn;
        Inc(TotalyRemained);

        if (Remains <> 0) and (FLastRemain <> -1) and Columns[FLastRemain].Visible then
        begin
          ColWidths[FLastRemain + Integer(dgIndicator in Options)] :=
            ColWidths[FLastRemain + Integer(dgIndicator in Options)] + Remains;

          if ColWidths[FLastRemain + Integer(dgIndicator in Options)] < FMinColWidth then
          begin
            Remains := ColWidths[FLastRemain + Integer(dgIndicator in Options)] -
              FMinColWidth;

            ColWidths[FLastRemain + Integer(dgIndicator in Options)] := FMinColWidth;
          end else
            Remains := 0;
        end;
      until (Remains = 0) or (FLastRemain = -1) or (TotalyRemained >= Columns.Count - 1);

      for I := 0 to Columns.Count - 1 do
        if Columns[I].Visible then
          Columns[I].Width := ColWidths[I + Integer(dgIndicator in Options)];
    finally
      EndLayout;
    end;
  end;
end;

{
  Возвращает флаг - используется родительский шрифт или нет.
}

function TCustomgsDBGrid.NotParentFont: Boolean;
begin
  Result := not inherited ParentFont;
end;

function TCustomgsDBGrid.ColumnByField(AField: TField): TColumn;
var
  I: Integer;
begin
  if DataLink.Active and Assigned(AField) then
    for I := 0 to Columns.Count - 1 do
      if AnsiCompareText(Columns[I].FieldName, AField.FieldName) = 0 then
      begin
        Result := Columns[I];
        Exit;
      end;

  Result := nil;
end;

{
  -------------------------------
  ----    TgsDBGrid Class    ----
  -------------------------------
}


{
  *********************
  ***  Public Part  ***
  *********************
}


{
  ************************
  ***  Protected Part  ***
  ************************
}


{
  Возвращает класс визуальной таблицы
}

class function TgsDBGrid.GridClassType: TgsDBGridClass;
begin
  Result := TgsDBGrid;
end;


{
  **********************
  ***  Private Part  ***
  **********************
}


{
  ********************************
  ***  Registering Components  ***
  ********************************
}

type
  TDBStringProperty = class(TStringProperty)
  public
    function GetAttributes: TPropertyAttributes; override;
    procedure GetValueList(List: TStrings); virtual;
    procedure GetValues(Proc: TGetStrProc); override;
  end;

  TgsDataFieldProperty = class(TDBStringProperty)
  public
    procedure GetValueList(List: TStrings); override;
  end;

{ TDBStringProperty }

function TDBStringProperty.GetAttributes: TPropertyAttributes;
begin
  Result := [paValueList, paSortList, paMultiSelect];
end;

procedure TDBStringProperty.GetValueList(List: TStrings);
begin
end;

procedure TDBStringProperty.GetValues(Proc: TGetStrProc);
var
  I: Integer;
  Values: TStringList;
begin
  Values := TStringList.Create;
  try
    GetValueList(Values);
    for I := 0 to Values.Count - 1 do Proc(Values[I]);
  finally
    Values.Free;
  end;
end;

{ TgsDataFieldProperty }

procedure TgsDataFieldProperty.GetValueList(List: TStrings);
var
  DataSource: TDataSource;
  Comp: TPersistent;
begin
  Comp := GetComponent(0);

  if not Assigned(Comp) then Exit;

  if Comp is TGridCheckBox then
    DataSource := (Comp as TGridCheckBox).Grid.DataSource
  else

  if Comp is TCondition then
    DataSource := (Comp as TCondition).Grid.DataSource
  else

  if Comp is TColumnExpand then
    DataSource := (Comp as TColumnExpand).Grid.DataSource
  else

  if Comp is TCustomgsDBGrid then
    DataSource := (Comp as TCustomgsDBGrid).DataSource
  else
    DataSource := nil;

  if (DataSource <> nil) and (DataSource.DataSet <> nil) then
    DataSource.DataSet.GetFieldNames(List);
end;


procedure Register;
begin
  RegisterComponents('gsNew', [TgsDBGrid]);

  RegisterPropertyEditor(TypeInfo(string), TCustomgsDBGrid, 'RememberField', TgsDataFieldProperty);

  RegisterPropertyEditor(TypeInfo(string), TGridCheckBox, 'FieldName', TgsDataFieldProperty);
  RegisterPropertyEditor(TypeInfo(string), TGridCheckBox, 'DisplayField', TgsDataFieldProperty);

  RegisterPropertyEditor(TypeInfo(string), TCondition, 'FieldName', TgsDataFieldProperty);
  RegisterPropertyEditor(TypeInfo(string), TCondition, 'DisplayFields', TgsDataFieldProperty);

  RegisterPropertyEditor(TypeInfo(string), TColumnExpand, 'FieldName', TgsDataFieldProperty);
  RegisterPropertyEditor(TypeInfo(string), TColumnExpand, 'DisplayField', TgsDataFieldProperty);
end;

end.

